<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>contrib/brl/bseg/brip/brip_vil1_float_ops.cxx Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">contrib/brl/bseg/brip/brip_vil1_float_ops.cxx</div>  </div>
</div>
<div class="contents">
<a href="brip__vil1__float__ops_8cxx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="brip__vil1__float__ops_8h.html" title="operations on memory_image_of&lt;float&gt; operands">brip_vil1_float_ops.h</a>&quot;</span>
<a name="l00002"></a>00002 <span class="comment">//:</span>
<a name="l00003"></a>00003 <span class="comment">// \file</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;vcl_fstream.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/vul__timer_8h.html">vul/vul_timer.h</a>&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__numeric__traits_8h.html">vnl/vnl_numeric_traits.h</a>&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__math_8h.html">vnl/vnl_math.h</a>&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;vcl_complex.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/vbl__array__1d_8h.html">vbl/vbl_array_1d.h</a>&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__fft__prime__factors_8h.html">vnl/algo/vnl_fft_prime_factors.h</a>&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__svd_8h.html">vnl/algo/vnl_svd.h</a>&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__inverse_8h.html">vnl/vnl_inverse.h</a>&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;vil1/vil1_smooth.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../../contrib/gel/vsol/html" href="../../../../../contrib/gel/vsol/html/vsol__box__2d_8h.html">vsol/vsol_box_2d.h</a>&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../../contrib/gel/vsol/html" href="../../../../../contrib/gel/vsol/html/vsol__polygon__2d__sptr_8h.html">vsol/vsol_polygon_2d_sptr.h</a>&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../../contrib/gel/vsol/html" href="../../../../../contrib/gel/vsol/html/vsol__polygon__2d_8h.html">vsol/vsol_polygon_2d.h</a>&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_brl_bbas_bsol.tag:../../../../../contrib/brl/bbas/bsol/html" href="../../../../../contrib/brl/bbas/bsol/html/bsol__algs_8h.html">bsol/bsol_algs.h</a>&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;<a class="code" href="brip__roi_8h.html" title="A composite region of interest class for image processing operations.">brip/brip_roi.h</a>&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="comment">//------------------------------------------------------------</span>
<a name="l00022"></a>00022 <span class="comment">//:  Convolve with a kernel</span>
<a name="l00023"></a>00023 <span class="comment">//   It&#39;s assumed that the kernel is square with odd dimensions</span>
<a name="l00024"></a>00024 vil1_memory_image_of&lt;float&gt;
<a name="l00025"></a><a class="code" href="classbrip__vil1__float__ops.html#af0b86fc57a2724c417e71c356967320a">00025</a> <a class="code" href="classbrip__vil1__float__ops.html#af0b86fc57a2724c417e71c356967320a" title="convolves with the specified kernel.">brip_vil1_float_ops::convolve</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l00026"></a>00026                               <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;float&gt;</a> <span class="keyword">const</span> &amp; kernel)
<a name="l00027"></a>00027 {
<a name="l00028"></a>00028   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l00029"></a>00029   <span class="keyword">const</span> <span class="keywordtype">int</span> kw = kernel.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html#a5d1d6d4ecc26eff6b99e456078924be6">cols</a>(); <span class="comment">// kh = kernel.rows();</span>
<a name="l00030"></a>00030   <span class="comment">// add a check for kernels that are not equal dimensions of odd size JLM</span>
<a name="l00031"></a>00031   <span class="keywordtype">int</span> n = (kw-1)/2;
<a name="l00032"></a>00032   vil1_memory_image_of&lt;float&gt; output;
<a name="l00033"></a>00033   output.resize(w,h);
<a name="l00034"></a>00034   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = n; y&lt;(h-n); y++)
<a name="l00035"></a>00035     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = n; x&lt;(w-n); x++)
<a name="l00036"></a>00036     {
<a name="l00037"></a>00037       <span class="keywordtype">float</span> accum = 0;
<a name="l00038"></a>00038       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = -n; j&lt;=n; j++)
<a name="l00039"></a>00039         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = -n; i&lt;=n; i++)
<a name="l00040"></a>00040         {
<a name="l00041"></a>00041           <span class="keywordtype">float</span> x1 = input(x+i,y+j);
<a name="l00042"></a>00042           <span class="keywordtype">float</span> x2 = kernel[i+n][j+n];
<a name="l00043"></a>00043           accum += x1*x2;
<a name="l00044"></a>00044         }
<a name="l00045"></a>00045       output(x,y)=accum;
<a name="l00046"></a>00046     }
<a name="l00047"></a>00047   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(output, n, 0.0f);
<a name="l00048"></a>00048   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(output, n, 0.0f);
<a name="l00049"></a>00049   <span class="keywordflow">return</span> output;
<a name="l00050"></a>00050 }
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">static</span> <span class="keywordtype">void</span> fill_1d_array(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l00053"></a>00053                           <span class="keyword">const</span> <span class="keywordtype">int</span> y, <span class="keywordtype">float</span>* output)
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width();
<a name="l00056"></a>00056   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00057"></a>00057     output[x] = input(x,y);
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="comment">//: Downsamples the 1-d array by 2 using the Burt-Adelson reduction algorithm.</span>
<a name="l00061"></a><a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef">00061</a> <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef" title="sub-sample a 1-d array using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution_1d</a>(<span class="keyword">const</span> <span class="keywordtype">float</span>* input, <span class="keywordtype">int</span> width,
<a name="l00062"></a>00062                                              <span class="keyword">const</span> <span class="keywordtype">float</span> k0, <span class="keyword">const</span> <span class="keywordtype">float</span> k1,
<a name="l00063"></a>00063                                              <span class="keyword">const</span> <span class="keywordtype">float</span> k2, <span class="keywordtype">float</span>* output)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065   <span class="keywordtype">float</span> w[5];
<a name="l00066"></a>00066   <span class="keywordtype">int</span> n = 0;
<a name="l00067"></a>00067   <span class="keywordflow">for</span> (; n&lt;5; n++)
<a name="l00068"></a>00068     w[n]=input[n];
<a name="l00069"></a>00069   output[0]=k0*w[0]+ 2.0f*(k1*w[1] + k2*w[2]);<span class="comment">//reflect at boundary</span>
<a name="l00070"></a>00070   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 1; x&lt;width; x++)
<a name="l00071"></a>00071   {
<a name="l00072"></a>00072     output[x]=k0*w[2]+ k1*(w[1]+w[3]) + k2*(w[0]+w[4]);
<a name="l00073"></a>00073     <span class="comment">//shift the window, w, over by two pixels</span>
<a name="l00074"></a>00074     w[0] = w[2];       w[1] = w[3];     w[2] = w[4];
<a name="l00075"></a>00075     <span class="comment">//handle the boundary conditions</span>
<a name="l00076"></a>00076     <span class="keywordflow">if</span> (x+2&lt;width)
<a name="l00077"></a>00077       w[3] = input[n++], w[4] = input[n++];
<a name="l00078"></a>00078     <span class="keywordflow">else</span>
<a name="l00079"></a>00079       w[3] = w[1], w[4] = w[0];
<a name="l00080"></a>00080   }
<a name="l00081"></a>00081 }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">//: Downsamples the image by 2 using the Burt-Adelson reduction algorithm.</span>
<a name="l00084"></a>00084 <span class="comment">// Convolution with a 5-point kernel [(0.5-ka)/2, 0.25, ka, 0.25, (0.5-ka)/2]</span>
<a name="l00085"></a>00085 <span class="comment">// ka = 0.6  maximum decorrelation, wavelet for image compression.</span>
<a name="l00086"></a>00086 <span class="comment">// ka = 0.5  linear interpolation,</span>
<a name="l00087"></a>00087 <span class="comment">// ka = 0.4  Gaussian filter</span>
<a name="l00088"></a>00088 <span class="comment">// ka = 0.359375 min aliasing, wider than Gaussian</span>
<a name="l00089"></a>00089 <span class="comment">// The image sizes are related by: output_dimension = (input_dimension +1)/2.</span>
<a name="l00090"></a>00090 vil1_memory_image_of&lt;float&gt;
<a name="l00091"></a><a class="code" href="classbrip__vil1__float__ops.html#ab7053e53d3ee78c9a1564bc5f4471530">00091</a> <a class="code" href="classbrip__vil1__float__ops.html#ab7053e53d3ee78c9a1564bc5f4471530" title="downsamples the input using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l00092"></a>00092                                      <span class="keywordtype">float</span> filter_coef)
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l00095"></a>00095   <span class="keywordtype">float</span> k0 = filter_coef, k1 = 0.25f*filter_coef, k2 = 0.5f*(0.5f-filter_coef);
<a name="l00096"></a>00096   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l00097"></a>00097   <span class="keywordtype">int</span> half_w =(w+1)/2, half_h = (h+1)/2;
<a name="l00098"></a>00098   vil1_memory_image_of&lt;float&gt; output;
<a name="l00099"></a>00099   output.resize(half_w, half_h);
<a name="l00100"></a>00100   <span class="comment">//Generate input/output arrays</span>
<a name="l00101"></a>00101   <span class="keywordtype">int</span> n = 0;
<a name="l00102"></a>00102   <span class="keywordtype">float</span>* in0 = <span class="keyword">new</span> <span class="keywordtype">float</span>[w];  <span class="keywordtype">float</span>* in1 = <span class="keyword">new</span> <span class="keywordtype">float</span>[w];
<a name="l00103"></a>00103   <span class="keywordtype">float</span>* in2 = <span class="keyword">new</span> <span class="keywordtype">float</span>[w];  <span class="keywordtype">float</span>* in3 = <span class="keyword">new</span> <span class="keywordtype">float</span>[w];
<a name="l00104"></a>00104   <span class="keywordtype">float</span>* in4 = <span class="keyword">new</span> <span class="keywordtype">float</span>[w];
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   <span class="keywordtype">float</span>* out0 = <span class="keyword">new</span> <span class="keywordtype">float</span>[half_w];  <span class="keywordtype">float</span>* out1 = <span class="keyword">new</span> <span class="keywordtype">float</span>[half_w];
<a name="l00107"></a>00107   <span class="keywordtype">float</span>* out2 = <span class="keyword">new</span> <span class="keywordtype">float</span>[half_w];  <span class="keywordtype">float</span>* out3 = <span class="keyword">new</span> <span class="keywordtype">float</span>[half_w];
<a name="l00108"></a>00108   <span class="keywordtype">float</span>* out4 = <span class="keyword">new</span> <span class="keywordtype">float</span>[half_w];
<a name="l00109"></a>00109   <span class="comment">//Initialize arrays</span>
<a name="l00110"></a>00110   fill_1d_array(input, n++, in0);   fill_1d_array(input, n++, in1);
<a name="l00111"></a>00111   fill_1d_array(input, n++, in2);   fill_1d_array(input, n++, in3);
<a name="l00112"></a>00112   fill_1d_array(input, n++, in4);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <span class="comment">//downsample initial arrays</span>
<a name="l00115"></a>00115   <a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef" title="sub-sample a 1-d array using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution_1d</a>(in0, half_w, k0, k1, k2, out0);
<a name="l00116"></a>00116   <a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef" title="sub-sample a 1-d array using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution_1d</a>(in1, half_w, k0, k1, k2, out1);
<a name="l00117"></a>00117   <a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef" title="sub-sample a 1-d array using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution_1d</a>(in2, half_w, k0, k1, k2, out2);
<a name="l00118"></a>00118   <a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef" title="sub-sample a 1-d array using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution_1d</a>(in3, half_w, k0, k1, k2, out3);
<a name="l00119"></a>00119   <a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef" title="sub-sample a 1-d array using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution_1d</a>(in4, half_w, k0, k1, k2, out4);
<a name="l00120"></a>00120   <span class="keywordtype">int</span> x=0, y;
<a name="l00121"></a>00121   <span class="comment">//do the first output line</span>
<a name="l00122"></a>00122   <span class="keywordflow">for</span> (;x&lt;half_w;x++)
<a name="l00123"></a>00123     output(x,0)= k0*out0[x]+ 2.0f*(k1*out1[x]+k2*out2[x]);
<a name="l00124"></a>00124   <span class="comment">//normal lines</span>
<a name="l00125"></a>00125   <span class="keywordflow">for</span> (y=1; y&lt;half_h; y++)
<a name="l00126"></a>00126   {
<a name="l00127"></a>00127     <span class="keywordflow">for</span> (x=0; x&lt;half_w; x++)
<a name="l00128"></a>00128       output(x,y) = k0*out2[x]+ k1*(out1[x]+out3[x]) + k2*(out0[x]+out4[x]);
<a name="l00129"></a>00129     <span class="comment">//shift the neighborhood down two lines</span>
<a name="l00130"></a>00130     <span class="keywordtype">float</span>* temp0 = out0;
<a name="l00131"></a>00131     <span class="keywordtype">float</span>* temp1 = out1;
<a name="l00132"></a>00132     out0 = out2;  out1 = out3;  out2 = out4;
<a name="l00133"></a>00133     out3 = temp0; out4 = temp1;<span class="comment">//reflect values</span>
<a name="l00134"></a>00134     <span class="comment">//test border condition</span>
<a name="l00135"></a>00135     <span class="keywordflow">if</span> (y&lt;half_h-2)
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137       <span class="comment">//normal processing, so don&#39;t reflect</span>
<a name="l00138"></a>00138       fill_1d_array(input, n++, in3);
<a name="l00139"></a>00139       fill_1d_array(input, n++, in4);
<a name="l00140"></a>00140       <a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef" title="sub-sample a 1-d array using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution_1d</a>(in3, half_w, k0, k1, k2, out3);
<a name="l00141"></a>00141       <a class="code" href="classbrip__vil1__float__ops.html#a6f238424040162b76b1048f39d6d75ef" title="sub-sample a 1-d array using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution_1d</a>(in4, half_w, k0, k1, k2, out4);
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143   }
<a name="l00144"></a>00144   <span class="keyword">delete</span> [] in0;  <span class="keyword">delete</span> [] in1; <span class="keyword">delete</span> [] in2;
<a name="l00145"></a>00145   <span class="keyword">delete</span> [] in3;  <span class="keyword">delete</span> [] in4;
<a name="l00146"></a>00146   <span class="keyword">delete</span> [] out0;  <span class="keyword">delete</span> [] out1; <span class="keyword">delete</span> [] out2;
<a name="l00147"></a>00147   <span class="keyword">delete</span> [] out3;  <span class="keyword">delete</span> [] out4;
<a name="l00148"></a>00148   vcl_cout &lt;&lt; <span class="stringliteral">&quot;\nDownsample a &quot;</span>&lt;&lt; w &lt;&lt;<span class="stringliteral">&quot; x &quot;</span> &lt;&lt; h &lt;&lt; <span class="stringliteral">&quot; image in &quot;</span>&lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs.\n&quot;</span>;
<a name="l00149"></a>00149   <span class="keywordflow">return</span> output;
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; <a class="code" href="classbrip__vil1__float__ops.html#ab7053e53d3ee78c9a1564bc5f4471530" title="downsamples the input using the Bert-Adelson algorithm.">brip_vil1_float_ops::</a>
<a name="l00153"></a><a class="code" href="classbrip__vil1__float__ops.html#a9dfddbfae7b8b37e0c66a7579d289513">00153</a> <a class="code" href="classbrip__vil1__float__ops.html#ab7053e53d3ee78c9a1564bc5f4471530" title="downsamples the input using the Bert-Adelson algorithm.">half_resolution</a>(vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; <span class="keyword">const</span> &amp; input,
<a name="l00154"></a>00154                 <span class="keywordtype">float</span> filter_coef)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156   <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l00157"></a>00157   <span class="comment">//make the three color planes</span>
<a name="l00158"></a>00158   vil1_memory_image_of&lt;float&gt; red(w,h), grn(w,h), blu(w,h);
<a name="l00159"></a>00159   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = 0; row&lt;h; row++)
<a name="l00160"></a>00160     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col = 0; col&lt;w; col++)
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162       vil1_rgb&lt;unsigned char&gt; <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__vector__2d_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a> = input(col,row);
<a name="l00163"></a>00163       red(col,row) = v.r;
<a name="l00164"></a>00164       grn(col,row) = v.g;
<a name="l00165"></a>00165       blu(col,row) = v.b;
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167   vil1_memory_image_of&lt;float&gt; red_half =
<a name="l00168"></a>00168     <a class="code" href="classbrip__vil1__float__ops.html#ab7053e53d3ee78c9a1564bc5f4471530" title="downsamples the input using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution</a>(red, filter_coef);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   vil1_memory_image_of&lt;float&gt; grn_half =
<a name="l00171"></a>00171     <a class="code" href="classbrip__vil1__float__ops.html#ab7053e53d3ee78c9a1564bc5f4471530" title="downsamples the input using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution</a>(grn, filter_coef);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   vil1_memory_image_of&lt;float&gt; blu_half =
<a name="l00174"></a>00174     <a class="code" href="classbrip__vil1__float__ops.html#ab7053e53d3ee78c9a1564bc5f4471530" title="downsamples the input using the Bert-Adelson algorithm.">brip_vil1_float_ops::half_resolution</a>(blu, filter_coef);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176   vil1_memory_image_of&lt;unsigned char&gt; red_half_char =
<a name="l00177"></a>00177     <a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947" title="converts a float image to a byte value range.">brip_vil1_float_ops::convert_to_byte</a>(red_half);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   vil1_memory_image_of&lt;unsigned char&gt; grn_half_char =
<a name="l00180"></a>00180     <a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947" title="converts a float image to a byte value range.">brip_vil1_float_ops::convert_to_byte</a>(grn_half);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   vil1_memory_image_of&lt;unsigned char&gt; blu_half_char =
<a name="l00183"></a>00183     <a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947" title="converts a float image to a byte value range.">brip_vil1_float_ops::convert_to_byte</a>(blu_half);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="keywordtype">int</span> w2 = red_half.width(), h2 = red_half.height();
<a name="l00186"></a>00186   vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; out(w2,h2);
<a name="l00187"></a>00187   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = 0; row&lt;h2; row++)
<a name="l00188"></a>00188     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col = 0; col&lt;w2; col++)
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rduc = red_half_char(col,row);
<a name="l00191"></a>00191       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> gruc = grn_half_char(col,row);
<a name="l00192"></a>00192       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bluc = blu_half_char(col,row);
<a name="l00193"></a>00193       vil1_rgb&lt;unsigned char&gt; <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__vector__2d_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>(rduc, gruc, bluc);
<a name="l00194"></a>00194       out(col, row) = v;
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196   <span class="keywordflow">return</span> out;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 vil1_memory_image_of&lt;float&gt;
<a name="l00200"></a><a class="code" href="classbrip__vil1__float__ops.html#aa002d476d96f3cee197d611b85f8ea8f">00200</a> <a class="code" href="classbrip__vil1__float__ops.html#aa002d476d96f3cee197d611b85f8ea8f" title="convolves with a Gaussian kernel.">brip_vil1_float_ops::gaussian</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input, <span class="keywordtype">float</span> sigma)
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202   vil1_memory_image_of&lt;float&gt; output(vil1_smooth_gaussian(input, sigma));
<a name="l00203"></a>00203   <span class="keywordflow">return</span> output;
<a name="l00204"></a>00204 }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="comment">//-------------------------------------------------------------------</span>
<a name="l00207"></a>00207 <span class="comment">// Determine if the center of a (2n+1)x(2n+1) neighborhood is a local maximum</span>
<a name="l00208"></a>00208 <span class="comment">//</span>
<a name="l00209"></a>00209 <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#a26f2854e44baa9346a991ec22729ccb7" title="find if the center pixel of a neighborhood is the maximum value.">brip_vil1_float_ops::</a>
<a name="l00210"></a><a class="code" href="classbrip__vil1__float__ops.html#a26f2854e44baa9346a991ec22729ccb7">00210</a> <a class="code" href="classbrip__vil1__float__ops.html#a26f2854e44baa9346a991ec22729ccb7" title="find if the center pixel of a neighborhood is the maximum value.">local_maximum</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;float&gt;</a> <span class="keyword">const</span> &amp; neighborhood,
<a name="l00211"></a>00211               <span class="keywordtype">int</span> n, <span class="keywordtype">float</span>&amp; value)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213   <span class="keywordtype">bool</span> local_max = <span class="keyword">true</span>;
<a name="l00214"></a>00214   value = 0;
<a name="l00215"></a>00215   <span class="keywordtype">float</span> center = neighborhood[n][n];
<a name="l00216"></a>00216   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = -n; y&lt;=n; y++)
<a name="l00217"></a>00217     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = -n; x&lt;=n; x++)
<a name="l00218"></a>00218       local_max = local_max&amp;&amp;(neighborhood[y+n][x+n]&lt;=center);
<a name="l00219"></a>00219   <span class="keywordflow">if</span> (!local_max)
<a name="l00220"></a>00220     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00221"></a>00221   value = center;
<a name="l00222"></a>00222   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00223"></a>00223 }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="comment">//-------------------------------------------------------------------</span>
<a name="l00226"></a>00226 <span class="comment">// Interpolate the sub-pixel position of a neighborhood using a</span>
<a name="l00227"></a>00227 <span class="comment">// second order expansion on a 3x3 sub-neighborhood. Return the</span>
<a name="l00228"></a>00228 <span class="comment">// offset to the maximum, i.e. x=x0+dx, y = y0+dy. The design is</span>
<a name="l00229"></a>00229 <span class="comment">// similar to the droid counterpoint by fsm, which uses the Beaudet Hessian</span>
<a name="l00230"></a>00230 <span class="comment">//</span>
<a name="l00231"></a>00231 <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#ac3a45b800c9e4abc09ba4866adfd6671" title="find the sub-pixel offset to the maximum using a 3x3 quad interpolation.">brip_vil1_float_ops::</a>
<a name="l00232"></a><a class="code" href="classbrip__vil1__float__ops.html#ac3a45b800c9e4abc09ba4866adfd6671">00232</a> <a class="code" href="classbrip__vil1__float__ops.html#ac3a45b800c9e4abc09ba4866adfd6671" title="find the sub-pixel offset to the maximum using a 3x3 quad interpolation.">interpolate_center</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;float&gt;</a> <span class="keyword">const</span> &amp; neighborhood,
<a name="l00233"></a>00233                    <span class="keywordtype">float</span>&amp; dx, <span class="keywordtype">float</span>&amp; dy)
<a name="l00234"></a>00234 {
<a name="l00235"></a>00235   dx = 0; dy=0;
<a name="l00236"></a>00236   <span class="comment">//extract the neighborhood</span>
<a name="l00237"></a>00237   <span class="keywordtype">float</span> n_m1_m1 = neighborhood[0][0];
<a name="l00238"></a>00238   <span class="keywordtype">float</span> n_m1_0 = neighborhood[0][1];
<a name="l00239"></a>00239   <span class="keywordtype">float</span> n_m1_1 = neighborhood[0][2];
<a name="l00240"></a>00240   <span class="keywordtype">float</span> n_0_m1 = neighborhood[1][0];
<a name="l00241"></a>00241   <span class="keywordtype">float</span> n_0_0 = neighborhood[1][1];
<a name="l00242"></a>00242   <span class="keywordtype">float</span> n_0_1 = neighborhood[1][2];
<a name="l00243"></a>00243   <span class="keywordtype">float</span> n_1_m1 = neighborhood[2][0];
<a name="l00244"></a>00244   <span class="keywordtype">float</span> n_1_0 = neighborhood[2][1];
<a name="l00245"></a>00245   <span class="keywordtype">float</span> n_1_1 = neighborhood[2][2];
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="comment">//Compute the 2nd order quadratic coefficients</span>
<a name="l00248"></a>00248   <span class="comment">//      1/6 * [ -1  0 +1 ]</span>
<a name="l00249"></a>00249   <span class="comment">// Ix =       [ -1  0 +1 ]</span>
<a name="l00250"></a>00250   <span class="comment">//            [ -1  0 +1 ]</span>
<a name="l00251"></a>00251   <span class="keywordtype">float</span> Ix =(-n_m1_m1+n_m1_1-n_0_m1+n_0_1-n_1_m1+n_1_1)/6.0f;
<a name="l00252"></a>00252   <span class="comment">//      1/6 * [ -1 -1 -1 ]</span>
<a name="l00253"></a>00253   <span class="comment">// Iy =       [  0  0  0 ]</span>
<a name="l00254"></a>00254   <span class="comment">//            [ +1 +1 +1 ]</span>
<a name="l00255"></a>00255   <span class="keywordtype">float</span> Iy =(-n_m1_m1-n_m1_0-n_m1_1+n_1_m1+n_1_0+n_1_1)/6.0f;
<a name="l00256"></a>00256   <span class="comment">//      1/3 * [ +1 -2 +1 ]</span>
<a name="l00257"></a>00257   <span class="comment">// Ixx =      [ +1 -2 +1 ]</span>
<a name="l00258"></a>00258   <span class="comment">//            [ +1 -2 +1 ]</span>
<a name="l00259"></a>00259   <span class="keywordtype">float</span> Ixx = ((n_m1_m1+n_0_m1+n_1_m1+n_m1_1+n_0_1+n_1_1)
<a name="l00260"></a>00260                -2.0f*(n_m1_0+n_0_0+n_1_0))/3.0f;
<a name="l00261"></a>00261   <span class="comment">//      1/4 * [ +1  0 -1 ]</span>
<a name="l00262"></a>00262   <span class="comment">// Ixy =      [  0  0  0 ]</span>
<a name="l00263"></a>00263   <span class="comment">//            [ -1  0 +1 ]</span>
<a name="l00264"></a>00264   <span class="keywordtype">float</span> Ixy = (n_m1_m1-n_m1_1+n_1_m1+n_1_1)/4.0f;
<a name="l00265"></a>00265   <span class="comment">//      1/3 * [ +1 +1 +1 ]</span>
<a name="l00266"></a>00266   <span class="comment">// Iyy =      [ -2 -2 -2 ]</span>
<a name="l00267"></a>00267   <span class="comment">//            [ +1 +1 +1 ]</span>
<a name="l00268"></a>00268   <span class="keywordtype">float</span> Iyy = ((n_m1_m1+n_m1_0+n_m1_1+n_1_m1+n_1_0+n_1_1)
<a name="l00269"></a>00269                -2.0f*(n_0_m1 + n_0_0 + n_1_0))/3.0f;
<a name="l00270"></a>00270   <span class="comment">//</span>
<a name="l00271"></a>00271   <span class="comment">// The next bit is to find the extremum of the fitted surface by setting its</span>
<a name="l00272"></a>00272   <span class="comment">// partial derivatives to zero. We need to solve the following linear system :</span>
<a name="l00273"></a>00273   <span class="comment">// Given the fitted surface is</span>
<a name="l00274"></a>00274   <span class="comment">// I(x,y) = Io + Ix x + Iy y + 1/2 Ixx x^2 + Ixy x y + 1/2 Iyy y^2</span>
<a name="l00275"></a>00275   <span class="comment">// we solve for the maximum (x,y),</span>
<a name="l00276"></a>00276   <span class="comment">//</span>
<a name="l00277"></a>00277   <span class="comment">//  [ Ixx Ixy ] [ dx ] + [ Ix ] = [ 0 ]      (dI/dx = 0)</span>
<a name="l00278"></a>00278   <span class="comment">//  [ Ixy Iyy ] [ dy ]   [ Iy ]   [ 0 ]      (dI/dy = 0)</span>
<a name="l00279"></a>00279   <span class="comment">//</span>
<a name="l00280"></a>00280   <span class="keywordtype">float</span> det = Ixx*Iyy - Ixy*Ixy;
<a name="l00281"></a>00281   <span class="comment">// det&gt;0 corresponds to a true local extremum otherwise a saddle point</span>
<a name="l00282"></a>00282   <span class="keywordflow">if</span> (det&gt;0)
<a name="l00283"></a>00283   {
<a name="l00284"></a>00284     dx = (Iy*Ixy - Ix*Iyy) / det;
<a name="l00285"></a>00285     dy = (Ix*Ixy - Iy*Ixx) / det;
<a name="l00286"></a>00286     <span class="comment">// more than one pixel away</span>
<a name="l00287"></a>00287     <span class="keywordflow">if</span> (vcl_fabs(dx) &gt; 1.0 || vcl_fabs(dy) &gt; 1.0)
<a name="l00288"></a>00288       dx = 0; dy = 0;
<a name="l00289"></a>00289   }
<a name="l00290"></a>00290 }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="comment">//---------------------------------------------------------------</span>
<a name="l00293"></a>00293 <span class="comment">// Compute the local maxima of the input on a (2n+1)x(2n+2)</span>
<a name="l00294"></a>00294 <span class="comment">// neighborhood above the given threshold. At each local maximum,</span>
<a name="l00295"></a>00295 <span class="comment">// compute the sub-pixel location, (x_pos, y_pos).</span>
<a name="l00296"></a>00296 <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#a7ee806ca6238a314fbdb38d95f7727a8" title="non-maximum suppression on a NxN neighborhood, with sub-pixel location.">brip_vil1_float_ops::</a>
<a name="l00297"></a><a class="code" href="classbrip__vil1__float__ops.html#a7ee806ca6238a314fbdb38d95f7727a8">00297</a> <a class="code" href="classbrip__vil1__float__ops.html#a7ee806ca6238a314fbdb38d95f7727a8" title="non-maximum suppression on a NxN neighborhood, with sub-pixel location.">non_maximum_suppression</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l00298"></a>00298                         <span class="keyword">const</span> <span class="keywordtype">int</span> n,
<a name="l00299"></a>00299                         <span class="keyword">const</span> <span class="keywordtype">float</span> thresh,
<a name="l00300"></a>00300                         vcl_vector&lt;float&gt;&amp; x_pos,
<a name="l00301"></a>00301                         vcl_vector&lt;float&gt;&amp; y_pos,
<a name="l00302"></a>00302                         vcl_vector&lt;float&gt;&amp; value)
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l00305"></a>00305   <span class="keyword">const</span> <span class="keywordtype">int</span> N = 2*n+1;
<a name="l00306"></a>00306   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l00307"></a>00307   x_pos.clear();  x_pos.clear();   value.clear();
<a name="l00308"></a>00308   <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;float&gt;</a> neighborhood(N,N);
<a name="l00309"></a>00309   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y =n; y&lt;h-n; y++)
<a name="l00310"></a>00310     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = n; x&lt;w-n; x++)
<a name="l00311"></a>00311     {
<a name="l00312"></a>00312       <span class="comment">//If the center is not above threshold then there is</span>
<a name="l00313"></a>00313       <span class="comment">//no hope</span>
<a name="l00314"></a>00314       <span class="keywordflow">if</span> (input(x,y)&lt;thresh)
<a name="l00315"></a>00315         <span class="keywordflow">continue</span>;
<a name="l00316"></a>00316       <span class="comment">//Fill the neighborhood</span>
<a name="l00317"></a>00317       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = -n; i&lt;=n; i++)
<a name="l00318"></a>00318         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = -n; j&lt;=n; j++)
<a name="l00319"></a>00319           neighborhood.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html#a67eebbfbe4e8a3b8822abf94f35ceb43">put</a>(j+n,i+n,input(x+i, y+j));
<a name="l00320"></a>00320       <span class="comment">//Check if the center is a local maximum</span>
<a name="l00321"></a>00321       <span class="keywordtype">float</span> dx, dy, max_v;
<a name="l00322"></a>00322       <span class="keywordflow">if</span> (<a class="code" href="classbrip__vil1__float__ops.html#a26f2854e44baa9346a991ec22729ccb7" title="find if the center pixel of a neighborhood is the maximum value.">brip_vil1_float_ops::local_maximum</a>(neighborhood, n, max_v))
<a name="l00323"></a>00323       {
<a name="l00324"></a>00324         <span class="comment">//if so sub-pixel interpolate (3x3) and output results</span>
<a name="l00325"></a>00325         <a class="code" href="classbrip__vil1__float__ops.html#ac3a45b800c9e4abc09ba4866adfd6671" title="find the sub-pixel offset to the maximum using a 3x3 quad interpolation.">brip_vil1_float_ops::interpolate_center</a>(neighborhood, dx, dy);
<a name="l00326"></a>00326         x_pos.push_back(x+dx);
<a name="l00327"></a>00327         y_pos.push_back(y+dy);
<a name="l00328"></a>00328         value.push_back(max_v);
<a name="l00329"></a>00329       }
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331   vcl_cout &lt;&lt; <span class="stringliteral">&quot;\nCompute non-maximum suppression on a &quot;</span>&lt;&lt; w &lt;&lt;<span class="stringliteral">&quot; x &quot;</span> &lt;&lt; h &lt;&lt; <span class="stringliteral">&quot; image in &quot;</span>&lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs.\n&quot;</span>;
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="comment">// -----------------------------------------------------------------</span>
<a name="l00335"></a>00335 <span class="comment">// Subtract image_1 from image_2.</span>
<a name="l00336"></a>00336 <span class="comment">// Will not operate unless the two input images are the same dimensions</span>
<a name="l00337"></a>00337 <span class="comment">//</span>
<a name="l00338"></a>00338 vil1_memory_image_of&lt;float&gt;
<a name="l00339"></a><a class="code" href="classbrip__vil1__float__ops.html#a9179bb60c67952e28adfc7110dd7b74d">00339</a> <a class="code" href="classbrip__vil1__float__ops.html#a9179bb60c67952e28adfc7110dd7b74d" title="subtracts image_1 from image_2.">brip_vil1_float_ops::difference</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image_1,
<a name="l00340"></a>00340                                 vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image_2)
<a name="l00341"></a>00341 {
<a name="l00342"></a>00342   <span class="keyword">const</span> <span class="keywordtype">int</span> w1 = image_1.width(), h1 = image_1.height();
<a name="l00343"></a>00343   <span class="keyword">const</span> <span class="keywordtype">int</span> w2 = image_2.width(), h2 = image_2.height();
<a name="l00344"></a>00344   vil1_memory_image_of&lt;float&gt; temp(w1, h1);
<a name="l00345"></a>00345   <span class="keywordflow">if</span> (w1!=w2||h1!=h2)
<a name="l00346"></a>00346   {
<a name="l00347"></a>00347     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::difference(..) - images are not the same dimensions\n&quot;</span>;
<a name="l00348"></a>00348     <span class="keywordflow">return</span> temp;
<a name="l00349"></a>00349   }
<a name="l00350"></a>00350   vil1_memory_image_of&lt;float&gt; out;
<a name="l00351"></a>00351   out.resize(w1, h1);
<a name="l00352"></a>00352   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h1; y++)
<a name="l00353"></a>00353     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w1; x++)
<a name="l00354"></a>00354       out(x,y) = image_2(x,y)-image_1(x,y);
<a name="l00355"></a>00355   <span class="keywordflow">return</span> out;
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 vil1_memory_image_of&lt;float&gt;
<a name="l00359"></a><a class="code" href="classbrip__vil1__float__ops.html#a4ecf1029abd3cc10487452fd7bba1422">00359</a> <a class="code" href="classbrip__vil1__float__ops.html#a4ecf1029abd3cc10487452fd7bba1422" title="sets absolute values greater than thresh to specified level.">brip_vil1_float_ops::abs_clip_to_level</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image,
<a name="l00360"></a>00360                                        <span class="keyword">const</span> <span class="keywordtype">float</span> thresh, <span class="keyword">const</span> <span class="keywordtype">float</span> level)
<a name="l00361"></a>00361 {
<a name="l00362"></a>00362   vil1_memory_image_of&lt;float&gt; out;
<a name="l00363"></a>00363   <span class="keyword">const</span> <span class="keywordtype">int</span> w = image.width(), h = image.height();
<a name="l00364"></a>00364   out.resize(w, h);
<a name="l00365"></a>00365   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00366"></a>00366     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00367"></a>00367     {
<a name="l00368"></a>00368       <span class="keywordflow">if</span> (vcl_fabs(image(x,y))&gt;thresh)
<a name="l00369"></a>00369         out(x,y) = level;
<a name="l00370"></a>00370       <span class="keywordflow">else</span>
<a name="l00371"></a>00371         out(x,y) = image(x,y);
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373   <span class="keywordflow">return</span> out;
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 <span class="comment">//----------------------------------------------------------------</span>
<a name="l00377"></a>00377 <span class="comment">// Compute the gradient of the input, use a 3x3 mask</span>
<a name="l00378"></a>00378 <span class="comment">//</span>
<a name="l00379"></a>00379 <span class="comment">//         1  |-1  0  1|         1  |-1 -1 -1|</span>
<a name="l00380"></a>00380 <span class="comment">//   Ix = --- |-1  0  1|   Iy = --- | 0  0  0|</span>
<a name="l00381"></a>00381 <span class="comment">//         6  |-1  0  1|         6  | 1  1  1|</span>
<a name="l00382"></a>00382 <span class="comment">//</span>
<a name="l00383"></a>00383 <span class="comment">// Larger masks are computed by pre-convolving with a Gaussian</span>
<a name="l00384"></a>00384 <span class="comment">//</span>
<a name="l00385"></a><a class="code" href="classbrip__vil1__float__ops.html#aec84e5cc2efbae9c61d08c306ae467ed">00385</a> <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#aec84e5cc2efbae9c61d08c306ae467ed" title="The gradient using a 3x3 kernel.">brip_vil1_float_ops::gradient_3x3</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l00386"></a>00386                                        vil1_memory_image_of&lt;float&gt;&amp; grad_x,
<a name="l00387"></a>00387                                        vil1_memory_image_of&lt;float&gt;&amp; grad_y)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l00390"></a>00390   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l00391"></a>00391   <span class="keywordtype">float</span> scale = 1.0f/6.0f;
<a name="l00392"></a>00392   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 1; y&lt;h-1; y++)
<a name="l00393"></a>00393     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 1; x&lt;w-1; x++)
<a name="l00394"></a>00394     {
<a name="l00395"></a>00395       <span class="keywordtype">float</span> gx = input(x+1,y-1)+input(x+1,y)+ input(x+1,y-1)
<a name="l00396"></a>00396         -input(x-1,y-1) -input(x-1,y) -input(x-1,y-1);
<a name="l00397"></a>00397       <span class="keywordtype">float</span> gy = input(x+1,y+1)+input(x,y+1)+ input(x-1,y+1)
<a name="l00398"></a>00398         -input(x+1,y-1) -input(x,y-1) -input(x-1,y-1);
<a name="l00399"></a>00399       grad_x(x,y) = scale*gx;
<a name="l00400"></a>00400       grad_y(x,y) = scale*gy;
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(grad_x, 1, 0.0f);
<a name="l00403"></a>00403   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(grad_x, 1, 0.0f);
<a name="l00404"></a>00404   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(grad_y, 1, 0.0f);
<a name="l00405"></a>00405   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(grad_y, 1, 0.0f);
<a name="l00406"></a>00406 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>  vcl_cout &lt;&lt; <span class="stringliteral">&quot;\nCompute Gradient in &quot;</span> &lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs.\n&quot;</span>;
<a name="l00408"></a>00408 <span class="preprocessor">#endif</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>}
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="comment">//----------------------------------------------------------------</span>
<a name="l00412"></a>00412 <span class="comment">// Compute the Hessian of the input, use a 3x3 mask</span>
<a name="l00413"></a>00413 <span class="comment">//</span>
<a name="l00414"></a>00414 <span class="comment">//          1 | 1  -2  1|          1 |  1  1  1|         1  | 1  0 -1|</span>
<a name="l00415"></a>00415 <span class="comment">//   Ixx = ---| 1  -2  1|   Iyy = ---| -2 -2 -2|  Ixy = --- | 0  0  0|</span>
<a name="l00416"></a>00416 <span class="comment">//          3 | 1  -2  1|          3 |  1  1  1|         4  |-1  0  1|</span>
<a name="l00417"></a>00417 <span class="comment">//</span>
<a name="l00418"></a>00418 <span class="comment">// Larger masks are computed by pre-convolving with a Gaussian</span>
<a name="l00419"></a>00419 <span class="comment">//</span>
<a name="l00420"></a><a class="code" href="classbrip__vil1__float__ops.html#a181dd7e4a432696a1ecd694d8abbc240">00420</a> <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#a181dd7e4a432696a1ecd694d8abbc240">brip_vil1_float_ops::hessian_3x3</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l00421"></a>00421                                       vil1_memory_image_of&lt;float&gt;&amp; Ixx,
<a name="l00422"></a>00422                                       vil1_memory_image_of&lt;float&gt;&amp; Ixy,
<a name="l00423"></a>00423                                       vil1_memory_image_of&lt;float&gt;&amp; Iyy)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l00426"></a>00426   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l00427"></a>00427   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 1; y&lt;h-1; y++)
<a name="l00428"></a>00428     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 1; x&lt;w-1; x++)
<a name="l00429"></a>00429     {
<a name="l00430"></a>00430       <span class="keywordtype">float</span> xx = input(x-1,y-1)+input(x-1,y)+input(x+1,y)+
<a name="l00431"></a>00431         input(x+1,y-1)+input(x+1,y)+input(x+1,y+1)-
<a name="l00432"></a>00432         2.0f*(input(x,y-1)+input(x,y)+input(x,y+1));
<a name="l00433"></a>00433 
<a name="l00434"></a>00434       <span class="keywordtype">float</span> xy = (input(x-1,y-1)+input(x+1,y+1))-
<a name="l00435"></a>00435         (input(x-1,y+1)+input(x+1,y-1));
<a name="l00436"></a>00436 
<a name="l00437"></a>00437       <span class="keywordtype">float</span> yy = input(x-1,y-1)+input(x,y-1)+input(x+1,y-1)+
<a name="l00438"></a>00438         input(x-1,y+1)+input(x,y+1)+input(x+1,y+1)-
<a name="l00439"></a>00439         2.0f*(input(x-1,y)+input(x,y)+input(x+1,y));
<a name="l00440"></a>00440 
<a name="l00441"></a>00441       Ixx(x,y) = xx/3.0f;
<a name="l00442"></a>00442       Ixy(x,y) = xy/4.0f;
<a name="l00443"></a>00443       Iyy(x,y) = yy/3.0f;
<a name="l00444"></a>00444     }
<a name="l00445"></a>00445   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(Ixx, 1, 0.0f);
<a name="l00446"></a>00446   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(Ixx, 1, 0.0f);
<a name="l00447"></a>00447   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(Ixy, 1, 0.0f);
<a name="l00448"></a>00448   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(Ixy, 1, 0.0f);
<a name="l00449"></a>00449   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(Iyy, 1, 0.0f);
<a name="l00450"></a>00450   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(Iyy, 1, 0.0f);
<a name="l00451"></a>00451   vcl_cout &lt;&lt; <span class="stringliteral">&quot;\nCompute a hessian matrix &quot;</span>&lt;&lt; w &lt;&lt;<span class="stringliteral">&quot; x &quot;</span> &lt;&lt; h &lt;&lt; <span class="stringliteral">&quot; image in &quot;</span>&lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs.\n&quot;</span>;
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 vil1_memory_image_of&lt;float&gt;
<a name="l00455"></a><a class="code" href="classbrip__vil1__float__ops.html#a6f57a2dc606b6d369dd1d55b916ee631">00455</a> <a class="code" href="classbrip__vil1__float__ops.html#a6f57a2dc606b6d369dd1d55b916ee631">brip_vil1_float_ops::beaudet</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; Ixx,
<a name="l00456"></a>00456                              vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; Ixy,
<a name="l00457"></a>00457                              vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; Iyy)
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459   <span class="keyword">const</span> <span class="keywordtype">int</span> w = Ixx.width(), h = Ixx.height();
<a name="l00460"></a>00460   vil1_memory_image_of&lt;float&gt; output;
<a name="l00461"></a>00461   output.resize(w, h);
<a name="l00462"></a>00462   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00463"></a>00463     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00464"></a>00464     {
<a name="l00465"></a>00465       <span class="keywordtype">float</span> xx = Ixx(x,y), xy = Ixy(x,y), yy = Iyy(x,y);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467       <span class="comment">//compute eigenvalues for experimentation</span>
<a name="l00468"></a>00468       <span class="keywordtype">float</span> det = xx*yy-xy*xy;
<a name="l00469"></a>00469       <span class="keywordtype">float</span> tr = xx+yy;
<a name="l00470"></a>00470       <span class="keywordtype">float</span> arg = tr*tr-4.f*det, lambda0 = 0, lambda1=0;
<a name="l00471"></a>00471       <span class="keywordflow">if</span> (arg&gt;0)
<a name="l00472"></a>00472       {
<a name="l00473"></a>00473         lambda0 = tr+vcl_sqrt(arg);
<a name="l00474"></a>00474         lambda1 = tr-vcl_sqrt(arg);
<a name="l00475"></a>00475       }
<a name="l00476"></a>00476       output(x,y) = lambda0*lambda1; <span class="comment">//just det for now</span>
<a name="l00477"></a>00477     }
<a name="l00478"></a>00478   <span class="keywordflow">return</span> output;
<a name="l00479"></a>00479 }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment">//----------------------------------------------------------------</span>
<a name="l00482"></a>00482 <span class="comment">//   t</span>
<a name="l00483"></a>00483 <span class="comment">//IxIx gradient matrix elements</span>
<a name="l00484"></a>00484 <span class="comment">// That is,</span>
<a name="l00485"></a>00485 <span class="comment">//                        _                           _</span>
<a name="l00486"></a>00486 <span class="comment">//                       | (dI/dx)^2    (dI/dx)(dI/dy) |</span>
<a name="l00487"></a>00487 <span class="comment">//                       |                             |</span>
<a name="l00488"></a>00488 <span class="comment">//  A = Sum(neighborhood)|                             |</span>
<a name="l00489"></a>00489 <span class="comment">//                       |(dI/dx)(dI/dy)   (dI/dx)^2   |</span>
<a name="l00490"></a>00490 <span class="comment">//                       |_                           _|</span>
<a name="l00491"></a>00491 <span class="comment">//</span>
<a name="l00492"></a>00492 <span class="comment">// over a 2n+1 x 2n+1 neighborhood</span>
<a name="l00493"></a>00493 <span class="comment">//</span>
<a name="l00494"></a>00494 <span class="keywordtype">void</span>
<a name="l00495"></a><a class="code" href="classbrip__vil1__float__ops.html#a913334f267170e8cf0c76ef122911590">00495</a> <a class="code" href="classbrip__vil1__float__ops.html#a913334f267170e8cf0c76ef122911590" title="IxIx.transpose gradient matrix elements (N = 2n+1).">brip_vil1_float_ops::grad_matrix_NxN</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l00496"></a>00496                                      <span class="keyword">const</span> <span class="keywordtype">int</span> n,
<a name="l00497"></a>00497                                      vil1_memory_image_of&lt;float&gt;&amp; IxIx,
<a name="l00498"></a>00498                                      vil1_memory_image_of&lt;float&gt;&amp; IxIy,
<a name="l00499"></a>00499                                      vil1_memory_image_of&lt;float&gt;&amp; IyIy)
<a name="l00500"></a>00500 {
<a name="l00501"></a>00501   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l00502"></a>00502   <span class="keyword">const</span> <span class="keywordtype">int</span> N = (2*n+1)*(2*n+1);
<a name="l00503"></a>00503   vil1_memory_image_of&lt;float&gt; grad_x, grad_y, output;
<a name="l00504"></a>00504   grad_x.resize(w,h);
<a name="l00505"></a>00505   grad_y.resize(w,h);
<a name="l00506"></a>00506   output.resize(w,h);
<a name="l00507"></a>00507   <a class="code" href="classbrip__vil1__float__ops.html#aec84e5cc2efbae9c61d08c306ae467ed" title="The gradient using a 3x3 kernel.">brip_vil1_float_ops::gradient_3x3</a>(input, grad_x, grad_y);
<a name="l00508"></a>00508   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l00509"></a>00509   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = n; y&lt;h-n;y++)
<a name="l00510"></a>00510     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = n; x&lt;w-n;x++)
<a name="l00511"></a>00511     {
<a name="l00512"></a>00512       <span class="keywordtype">float</span> xx=0, xy=0, yy=0;
<a name="l00513"></a>00513       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = -n; i&lt;=n; i++)
<a name="l00514"></a>00514         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = -n; j&lt;=n; j++)
<a name="l00515"></a>00515         {
<a name="l00516"></a>00516           <span class="keywordtype">float</span> gx = grad_x(x+i, y+j), gy = grad_y(x+i, y+j);
<a name="l00517"></a>00517           xx += gx*gx;
<a name="l00518"></a>00518           xy += gx*gy;
<a name="l00519"></a>00519           yy += gy*gy;
<a name="l00520"></a>00520         }
<a name="l00521"></a>00521       IxIx(x,y) = xx/N;
<a name="l00522"></a>00522       IxIy(x,y) = xy/N;
<a name="l00523"></a>00523       IyIy(x,y) = yy/N;
<a name="l00524"></a>00524     }
<a name="l00525"></a>00525   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(IxIx, n, 0.0f);
<a name="l00526"></a>00526   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(IxIx, n, 0.0f);
<a name="l00527"></a>00527   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(IxIy, n, 0.0f);
<a name="l00528"></a>00528   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(IxIy, n, 0.0f);
<a name="l00529"></a>00529   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(IyIy, n, 0.0f);
<a name="l00530"></a>00530   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(IyIy, n, 0.0f);
<a name="l00531"></a>00531   vcl_cout &lt;&lt; <span class="stringliteral">&quot;\nCompute a gradient matrix &quot;</span>&lt;&lt; w &lt;&lt;<span class="stringliteral">&quot; x &quot;</span> &lt;&lt; h &lt;&lt; <span class="stringliteral">&quot; image in &quot;</span>&lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs.\n&quot;</span>;
<a name="l00532"></a>00532 }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 vil1_memory_image_of&lt;float&gt;
<a name="l00535"></a><a class="code" href="classbrip__vil1__float__ops.html#a59388e61679ddfdce70ce9b558c764d3">00535</a> <a class="code" href="classbrip__vil1__float__ops.html#a59388e61679ddfdce70ce9b558c764d3" title="Computes the Harris corner measure.">brip_vil1_float_ops::harris</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; IxIx,
<a name="l00536"></a>00536                             vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; IxIy,
<a name="l00537"></a>00537                             vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; IyIy,
<a name="l00538"></a>00538                             <span class="keyword">const</span> <span class="keywordtype">double</span> scale)
<a name="l00539"></a>00539 {
<a name="l00540"></a>00540   <span class="keyword">const</span> <span class="keywordtype">int</span> w = IxIx.width(), h = IxIx.height();
<a name="l00541"></a>00541   <span class="keywordtype">float</span> norm = 1e-3f; <span class="comment">// Scale the output to values in the 10-&gt;1000 range</span>
<a name="l00542"></a>00542   vil1_memory_image_of&lt;float&gt; output;
<a name="l00543"></a>00543   output.resize(w, h);
<a name="l00544"></a>00544   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00545"></a>00545     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00546"></a>00546     {
<a name="l00547"></a>00547       <span class="keywordtype">float</span> xx = IxIx(x,y), xy = IxIy(x,y), yy = IyIy(x,y);
<a name="l00548"></a>00548       <span class="keywordtype">float</span> det = xx*yy-xy*xy, <a class="codeRef" doxygen="core_vil.tag:../../../../../core/vil/html" href="../../../../../core/vil/html/vil__jpeg__decompressor_8cxx.html#a2526a8fa89c481f1f1b6f21c4957345a">trace</a> = xx+yy;
<a name="l00549"></a>00549       output(x,y) = float(det - scale*trace*trace)*norm;
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551   <span class="keywordflow">return</span> output;
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">//----------------------------------------------------------------</span>
<a name="l00555"></a>00555 <span class="comment">// Compute the sqrt of the product of the eigenvalues of the</span>
<a name="l00556"></a>00556 <span class="comment">// gradient matrix over a 2n+1 x 2n+1 neighborhood</span>
<a name="l00557"></a>00557 <span class="comment">// That is,</span>
<a name="l00558"></a>00558 <span class="comment">//                        _                           _</span>
<a name="l00559"></a>00559 <span class="comment">//                       | (dI/dx)^2    (dI/dx)(dI/dy) |</span>
<a name="l00560"></a>00560 <span class="comment">//                       |                             |</span>
<a name="l00561"></a>00561 <span class="comment">//  A = Sum(neighborhood)|                             |</span>
<a name="l00562"></a>00562 <span class="comment">//                       |(dI/dx)(dI/dy)   (dI/dx)^2   |</span>
<a name="l00563"></a>00563 <span class="comment">//                       |_                           _|</span>
<a name="l00564"></a>00564 <span class="comment">//</span>
<a name="l00565"></a>00565 <span class="comment">//  The output image is sqrt(lamba_1*lambda_2) where lambda_i are the</span>
<a name="l00566"></a>00566 <span class="comment">//  eigenvalues</span>
<a name="l00567"></a>00567 <span class="comment">//</span>
<a name="l00568"></a>00568 vil1_memory_image_of&lt;float&gt;
<a name="l00569"></a><a class="code" href="classbrip__vil1__float__ops.html#a11929c9d41e4eb1eeeb827fdfc95b6f8">00569</a> <a class="code" href="classbrip__vil1__float__ops.html#a11929c9d41e4eb1eeeb827fdfc95b6f8" title="computes the conditioning of the 2n+1 x 2n+1 gradient neighborhood.">brip_vil1_float_ops::sqrt_grad_singular_values</a>(vil1_memory_image_of&lt;float&gt; &amp; input,
<a name="l00570"></a>00570                                                <span class="keywordtype">int</span> n)
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572   <span class="keyword">const</span> <span class="keywordtype">int</span> N = (2*n+1)*(2*n+1);
<a name="l00573"></a>00573   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l00574"></a>00574   vil1_memory_image_of&lt;float&gt; grad_x, grad_y, output;
<a name="l00575"></a>00575   grad_x.resize(w,h);
<a name="l00576"></a>00576   grad_y.resize(w,h);
<a name="l00577"></a>00577   output.resize(w,h);
<a name="l00578"></a>00578   <a class="code" href="classbrip__vil1__float__ops.html#aec84e5cc2efbae9c61d08c306ae467ed" title="The gradient using a 3x3 kernel.">brip_vil1_float_ops::gradient_3x3</a>(input, grad_x, grad_y);
<a name="l00579"></a>00579   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l00580"></a>00580   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = n; y&lt;h-n;y++)
<a name="l00581"></a>00581     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = n; x&lt;w-n;x++)
<a name="l00582"></a>00582     {
<a name="l00583"></a>00583       <span class="keywordtype">float</span> IxIx=0, IxIy=0, IyIy=0;
<a name="l00584"></a>00584       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = -n; i&lt;=n; i++)
<a name="l00585"></a>00585         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = -n; j&lt;=n; j++)
<a name="l00586"></a>00586         {
<a name="l00587"></a>00587           <span class="keywordtype">float</span> gx = grad_x(x+i, y+j), gy = grad_y(x+i, y+j);
<a name="l00588"></a>00588           IxIx += gx*gx;
<a name="l00589"></a>00589           IxIy += gx*gy;
<a name="l00590"></a>00590           IyIy += gy*gy;
<a name="l00591"></a>00591         }
<a name="l00592"></a>00592       <span class="keywordtype">float</span> det = (IxIx*IyIy-IxIy*IxIy)/N;
<a name="l00593"></a>00593       output(x,y)=vcl_sqrt(vcl_fabs(det));
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(output, n, 0.0f);
<a name="l00596"></a>00596   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(output, n, 0.0f);
<a name="l00597"></a>00597   vcl_cout &lt;&lt; <span class="stringliteral">&quot;\nCompute sqrt(sigma0*sigma1) in&quot;</span> &lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs.\n&quot;</span>;
<a name="l00598"></a>00598   <span class="keywordflow">return</span> output;
<a name="l00599"></a>00599 }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l00602"></a>00602 <span class="comment">// Lucas-Kanade motion vectors:  Solve for the motion vectors over a</span>
<a name="l00603"></a>00603 <span class="comment">// (2n+1)x(2n+1) neighborhood. The time derivative of intensity is computed</span>
<a name="l00604"></a>00604 <span class="comment">// from the previous_frame. The threshold eliminates small values of</span>
<a name="l00605"></a>00605 <span class="comment">// the product of the time derivative and the motion matrix eigenvalues,</span>
<a name="l00606"></a>00606 <span class="comment">// i.e, |lambda_1*lambda_2*dI/dt|&lt;thresh.  Thus motion is only reported when</span>
<a name="l00607"></a>00607 <span class="comment">// the solution is well-conditioned.</span>
<a name="l00608"></a>00608 <span class="comment">//</span>
<a name="l00609"></a>00609 <span class="keywordtype">void</span>
<a name="l00610"></a><a class="code" href="classbrip__vil1__float__ops.html#a80dea910cd8941b769fa9a2c33b8238b">00610</a> <a class="code" href="classbrip__vil1__float__ops.html#a80dea910cd8941b769fa9a2c33b8238b" title="computes Lucas-Kanade optical flow on a 2n+1 neighborhood.">brip_vil1_float_ops::Lucas_KanadeMotion</a>(vil1_memory_image_of&lt;float&gt; &amp; current_frame,
<a name="l00611"></a>00611                                         vil1_memory_image_of&lt;float&gt; &amp; previous_frame,
<a name="l00612"></a>00612                                         <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> thresh,
<a name="l00613"></a>00613                                         vil1_memory_image_of&lt;float&gt;&amp; vx,
<a name="l00614"></a>00614                                         vil1_memory_image_of&lt;float&gt;&amp; vy)
<a name="l00615"></a>00615 {
<a name="l00616"></a>00616   <span class="keyword">const</span> <span class="keywordtype">int</span> N = (2*n+1)*(2*n+1);
<a name="l00617"></a>00617   <span class="keyword">const</span> <span class="keywordtype">int</span> w = current_frame.width(), h = current_frame.height();
<a name="l00618"></a>00618   vil1_memory_image_of&lt;float&gt; grad_x, grad_y, diff;
<a name="l00619"></a>00619   grad_x.resize(w,h);
<a name="l00620"></a>00620   grad_y.resize(w,h);
<a name="l00621"></a>00621   <span class="comment">//compute the gradient vector and the time derivative</span>
<a name="l00622"></a>00622   <a class="code" href="classbrip__vil1__float__ops.html#aec84e5cc2efbae9c61d08c306ae467ed" title="The gradient using a 3x3 kernel.">brip_vil1_float_ops::gradient_3x3</a>(current_frame, grad_x, grad_y);
<a name="l00623"></a>00623   diff = <a class="code" href="classbrip__vil1__float__ops.html#a9179bb60c67952e28adfc7110dd7b74d" title="subtracts image_1 from image_2.">brip_vil1_float_ops::difference</a>(previous_frame, current_frame);
<a name="l00624"></a>00624   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l00625"></a>00625   <span class="comment">//sum the motion terms over the (2n+1)x(2n+1) neighborhood.</span>
<a name="l00626"></a>00626   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = n; y&lt;h-n;y++)
<a name="l00627"></a>00627     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = n; x&lt;w-n;x++)
<a name="l00628"></a>00628     {
<a name="l00629"></a>00629       <span class="keywordtype">float</span> IxIx=0, IxIy=0, IyIy=0, IxIt=0, IyIt=0;
<a name="l00630"></a>00630       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = -n; i&lt;=n; i++)
<a name="l00631"></a>00631         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = -n; j&lt;=n; j++)
<a name="l00632"></a>00632         {
<a name="l00633"></a>00633           <span class="keywordtype">float</span> gx = grad_x(x+i, y+j), gy = grad_y(x+i, y+j);
<a name="l00634"></a>00634           <span class="keywordtype">float</span> dt = diff(x+i, y+j);
<a name="l00635"></a>00635           IxIx += gx*gx;
<a name="l00636"></a>00636           IxIy += gx*gy;
<a name="l00637"></a>00637           IyIy += gy*gy;
<a name="l00638"></a>00638           IxIt += gx*dt;
<a name="l00639"></a>00639           IyIt += gy*dt;
<a name="l00640"></a>00640         }
<a name="l00641"></a>00641       <span class="comment">//Divide by the number of pixels in the neighborhood</span>
<a name="l00642"></a>00642       IxIx/=N;  IxIy/=N; IyIy/=N; IxIt/=N; IyIt/=N;
<a name="l00643"></a>00643       <span class="keywordtype">float</span> det = float(IxIx*IyIy-IxIy*IxIy);
<a name="l00644"></a>00644       <span class="comment">//Eliminate small motion factors</span>
<a name="l00645"></a>00645       <span class="keywordtype">float</span> dif = diff(x,y);
<a name="l00646"></a>00646       <span class="keywordtype">float</span> motion_factor = vcl_fabs(det*dif);
<a name="l00647"></a>00647       <span class="keywordflow">if</span> (motion_factor&lt;thresh)
<a name="l00648"></a>00648       {
<a name="l00649"></a>00649         vx(x,y) = 0.0f;
<a name="l00650"></a>00650         vy(x,y) = 0.0f;
<a name="l00651"></a>00651         <span class="keywordflow">continue</span>;
<a name="l00652"></a>00652       }
<a name="l00653"></a>00653       <span class="comment">//solve for the motion vector</span>
<a name="l00654"></a>00654       vx(x,y) = (IyIy*IxIt-IxIy*IyIt)/det;
<a name="l00655"></a>00655       vy(x,y) = (-IxIy*IxIt + IxIx*IyIt)/det;
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(vx, n, 0.0f);
<a name="l00658"></a>00658   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(vx, n, 0.0f);
<a name="l00659"></a>00659   <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(vy, n, 0.0f);
<a name="l00660"></a>00660   <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(vy, n, 0.0f);
<a name="l00661"></a>00661   vcl_cout &lt;&lt; <span class="stringliteral">&quot;\nCompute Lucas-Kanade in &quot;</span> &lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs.\n&quot;</span>;
<a name="l00662"></a>00662 }
<a name="l00663"></a>00663 
<a name="l00664"></a><a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66">00664</a> <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#acd2c4ad0e93c5492b3990008361dbf66" title="fills a border of width w on left and right of image with value.">brip_vil1_float_ops::fill_x_border</a>(vil1_memory_image_of&lt;float&gt; &amp; image,
<a name="l00665"></a>00665                                         <span class="keywordtype">int</span> w, <span class="keywordtype">float</span> value)
<a name="l00666"></a>00666 {
<a name="l00667"></a>00667   <span class="keyword">const</span> <span class="keywordtype">int</span> width = image.width(), height = image.height();
<a name="l00668"></a>00668   <span class="keywordflow">if</span> (2*w&gt;width)
<a name="l00669"></a>00669   {
<a name="l00670"></a>00670     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::fill_x_border(..) - 2xborder exceeds image width\n&quot;</span>;
<a name="l00671"></a>00671     <span class="keywordflow">return</span>;
<a name="l00672"></a>00672   }
<a name="l00673"></a>00673   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;height; y++)
<a name="l00674"></a>00674     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00675"></a>00675       image(x, y) = value;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;height; y++)
<a name="l00678"></a>00678     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = width-w; x&lt;width; x++)
<a name="l00679"></a>00679       image(x, y) = value;
<a name="l00680"></a>00680 }
<a name="l00681"></a>00681 
<a name="l00682"></a><a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294">00682</a> <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#ae30290a2a51bd446d7cde72c3dd58294" title="fills a border of width h on top and bottom of image with value.">brip_vil1_float_ops::fill_y_border</a>(vil1_memory_image_of&lt;float&gt; &amp; image,
<a name="l00683"></a>00683                                         <span class="keywordtype">int</span> h, <span class="keywordtype">float</span> value)
<a name="l00684"></a>00684 {
<a name="l00685"></a>00685   <span class="keyword">const</span> <span class="keywordtype">int</span> width = image.width(), height = image.height();
<a name="l00686"></a>00686   <span class="keywordflow">if</span> (2*h&gt;height)
<a name="l00687"></a>00687   {
<a name="l00688"></a>00688     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::fill_y_border(..) - 2xborder exceeds image height\n&quot;</span>;
<a name="l00689"></a>00689     <span class="keywordflow">return</span>;
<a name="l00690"></a>00690   }
<a name="l00691"></a>00691   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00692"></a>00692     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;width; x++)
<a name="l00693"></a>00693       image(x, y) = value;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = height-h; y&lt;height; y++)
<a name="l00696"></a>00696     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;width; x++)
<a name="l00697"></a>00697       image(x, y) = value;
<a name="l00698"></a>00698 }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700 vil1_memory_image_of&lt;unsigned char&gt;
<a name="l00701"></a><a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947">00701</a> <a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947" title="converts a float image to a byte value range.">brip_vil1_float_ops::convert_to_byte</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image)
<a name="l00702"></a>00702 {
<a name="l00703"></a>00703   <span class="comment">//determine the max min values</span>
<a name="l00704"></a>00704   <span class="keywordtype">float</span> min_val = vnl_numeric_traits&lt;float&gt;::maxval;
<a name="l00705"></a>00705   <span class="keywordtype">float</span> max_val = -min_val;
<a name="l00706"></a>00706   <span class="keyword">const</span> <span class="keywordtype">int</span> w = image.width(), h = image.height();
<a name="l00707"></a>00707   vil1_memory_image_of&lt;unsigned char&gt; output;
<a name="l00708"></a>00708   output.resize(w,h);
<a name="l00709"></a>00709   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00710"></a>00710     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00711"></a>00711     {
<a name="l00712"></a>00712       min_val = <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__decnum_8h.html#ac7064c7fc83d5d457e5f903eacac9f73">vnl_math_min</a>(min_val, image(x,y));
<a name="l00713"></a>00713       max_val = <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__decnum_8h.html#a17c47eb693cfd88c7b181b162eca8dec">vnl_math_max</a>(max_val, image(x,y));
<a name="l00714"></a>00714     }
<a name="l00715"></a>00715   <span class="keywordtype">float</span> range = max_val-min_val;
<a name="l00716"></a>00716   <span class="keywordflow">if</span> (range == 0.f)
<a name="l00717"></a>00717     range = 1.f;
<a name="l00718"></a>00718   <span class="keywordflow">else</span>
<a name="l00719"></a>00719     range = 255.f/range;
<a name="l00720"></a>00720   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00721"></a>00721     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00722"></a>00722       output(x,y) = (<span class="keywordtype">unsigned</span> char)((image(x,y)-min_val)*range);
<a name="l00723"></a>00723   <span class="keywordflow">return</span> output;
<a name="l00724"></a>00724 }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 <span class="comment">//------------------------------------------------------------</span>
<a name="l00727"></a>00727 <span class="comment">// Convert the range between min_val and max_val to 255</span>
<a name="l00728"></a>00728 vil1_memory_image_of&lt;unsigned char&gt;
<a name="l00729"></a><a class="code" href="classbrip__vil1__float__ops.html#a3bb2c9ae61bb811b83a03a8efa48d420">00729</a> <a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947" title="converts a float image to a byte value range.">brip_vil1_float_ops::convert_to_byte</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image,
<a name="l00730"></a>00730                                      <span class="keyword">const</span> <span class="keywordtype">float</span> min_val, <span class="keyword">const</span> <span class="keywordtype">float</span> max_val)
<a name="l00731"></a>00731 {
<a name="l00732"></a>00732   <span class="keyword">const</span> <span class="keywordtype">int</span> w = image.width(), h = image.height();
<a name="l00733"></a>00733   vil1_memory_image_of&lt;unsigned char&gt; output;
<a name="l00734"></a>00734   output.resize(w,h);
<a name="l00735"></a>00735   <span class="keywordtype">float</span> range = max_val-min_val;
<a name="l00736"></a>00736   <span class="keywordflow">if</span> (range == 0.f)
<a name="l00737"></a>00737     range = 1.f;
<a name="l00738"></a>00738   <span class="keywordflow">else</span>
<a name="l00739"></a>00739     range = 255.f/range;
<a name="l00740"></a>00740   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00741"></a>00741     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00742"></a>00742     {
<a name="l00743"></a>00743       <span class="keywordtype">float</span> <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__vector__2d_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a> = (image(x,y)-min_val)*range;
<a name="l00744"></a>00744       <span class="keywordflow">if</span> (v&gt;255)
<a name="l00745"></a>00745         v=255;
<a name="l00746"></a>00746       <span class="keywordflow">if</span> (v&lt;0)
<a name="l00747"></a>00747         v=0;
<a name="l00748"></a>00748       output(x,y) = (<span class="keywordtype">unsigned</span> char)v;
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750   <span class="keywordflow">return</span> output;
<a name="l00751"></a>00751 }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 vil1_memory_image_of&lt;unsigned short&gt;
<a name="l00754"></a><a class="code" href="classbrip__vil1__float__ops.html#a81b88a75f199932f76a5fb278c9822fa">00754</a> <a class="code" href="classbrip__vil1__float__ops.html#a81b88a75f199932f76a5fb278c9822fa" title="converts a float image to an unsigned short image within a range.">brip_vil1_float_ops::convert_to_short</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image,
<a name="l00755"></a>00755                                       <span class="keyword">const</span> <span class="keywordtype">float</span> min_val, <span class="keyword">const</span> <span class="keywordtype">float</span> max_val)
<a name="l00756"></a>00756 {
<a name="l00757"></a>00757   <span class="keyword">const</span> <span class="keywordtype">int</span> w = image.width(), h = image.height();
<a name="l00758"></a>00758   <span class="keywordtype">float</span> max_short = 65355.f;
<a name="l00759"></a>00759   vil1_memory_image_of&lt;unsigned short&gt; output;
<a name="l00760"></a>00760   output.resize(w,h);
<a name="l00761"></a>00761   <span class="keywordtype">float</span> range = max_val-min_val;
<a name="l00762"></a>00762   <span class="keywordflow">if</span> (!range)
<a name="l00763"></a>00763     range = 1;
<a name="l00764"></a>00764   <span class="keywordflow">else</span>
<a name="l00765"></a>00765     range = max_short/range;
<a name="l00766"></a>00766   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00767"></a>00767     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00768"></a>00768     {
<a name="l00769"></a>00769       <span class="keywordtype">float</span> <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__vector__2d_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a> = (image(x,y)-min_val)*range;
<a name="l00770"></a>00770       <span class="keywordflow">if</span> (v&gt;max_short)
<a name="l00771"></a>00771         v=max_short;
<a name="l00772"></a>00772       <span class="keywordflow">if</span> (v&lt;0)
<a name="l00773"></a>00773         v=0;
<a name="l00774"></a>00774       output(x,y) = (<span class="keywordtype">unsigned</span> short)v;
<a name="l00775"></a>00775     }
<a name="l00776"></a>00776   <span class="keywordflow">return</span> output;
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt;
<a name="l00780"></a><a class="code" href="classbrip__vil1__float__ops.html#ab938a96490b91f91f636a308dba7838d">00780</a> <a class="code" href="classbrip__vil1__float__ops.html#ab938a96490b91f91f636a308dba7838d" title="converts a float image to a color rgb image with all equal planes.">brip_vil1_float_ops::convert_to_rgb</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image)
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782   vil1_memory_image_of&lt;unsigned char&gt; temp = <a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947" title="converts a float image to a byte value range.">brip_vil1_float_ops::convert_to_byte</a>(image);
<a name="l00783"></a>00783   <span class="keyword">const</span> <span class="keywordtype">int</span> w = temp.width(), h = temp.height();
<a name="l00784"></a>00784   vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; out(w, h);
<a name="l00785"></a>00785   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;h; r++)
<a name="l00786"></a>00786     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c&lt;w; c++)
<a name="l00787"></a>00787       out(c,r).r = out(c,r).g = out(c,r).b = temp(c,r);
<a name="l00788"></a>00788   <span class="keywordflow">return</span> out;
<a name="l00789"></a>00789 }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt;
<a name="l00792"></a><a class="code" href="classbrip__vil1__float__ops.html#a33900d44acce15885a81e5c07e314038">00792</a> <a class="code" href="classbrip__vil1__float__ops.html#ab938a96490b91f91f636a308dba7838d" title="converts a float image to a color rgb image with all equal planes.">brip_vil1_float_ops::convert_to_rgb</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image,
<a name="l00793"></a>00793                                     <span class="keyword">const</span> <span class="keywordtype">float</span> min_val, <span class="keyword">const</span> <span class="keywordtype">float</span> max_val)
<a name="l00794"></a>00794 {
<a name="l00795"></a>00795   vil1_memory_image_of&lt;unsigned char&gt; temp = <a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947" title="converts a float image to a byte value range.">brip_vil1_float_ops::convert_to_byte</a>(image,min_val,max_val);
<a name="l00796"></a>00796   <span class="keyword">const</span> <span class="keywordtype">int</span> w = temp.width(), h = temp.height();
<a name="l00797"></a>00797   vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; out(w, h);
<a name="l00798"></a>00798   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;h; r++)
<a name="l00799"></a>00799     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c&lt;w; c++)
<a name="l00800"></a>00800       out(c,r).r = out(c,r).g = out(c,r).b = temp(c,r);
<a name="l00801"></a>00801   <span class="keywordflow">return</span> out;
<a name="l00802"></a>00802 }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 vil1_memory_image_of&lt;float&gt;
<a name="l00806"></a><a class="code" href="classbrip__vil1__float__ops.html#ae9cfa5ff5b484fddaf0f7a22c13229be">00806</a> <a class="code" href="classbrip__vil1__float__ops.html#ad72be5f2d266971edde5ec8fcaebb9d9" title="converts a vil1_image to a float image.">brip_vil1_float_ops::convert_to_float</a>(vil1_memory_image_of&lt;unsigned char&gt; <span class="keyword">const</span> &amp; image)
<a name="l00807"></a>00807 {
<a name="l00808"></a>00808   vil1_memory_image_of&lt;float&gt; output;
<a name="l00809"></a>00809   <span class="keyword">const</span> <span class="keywordtype">int</span> w = image.width(), h = image.height();
<a name="l00810"></a>00810   output.resize(w,h);
<a name="l00811"></a>00811   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00812"></a>00812     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00813"></a>00813       output(x,y) = (float)image(x,y);
<a name="l00814"></a>00814   <span class="keywordflow">return</span> output;
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 vil1_memory_image_of&lt;float&gt;
<a name="l00818"></a><a class="code" href="classbrip__vil1__float__ops.html#a0d6dd505ef94b0a51b323318642e09db">00818</a> <a class="code" href="classbrip__vil1__float__ops.html#ad72be5f2d266971edde5ec8fcaebb9d9" title="converts a vil1_image to a float image.">brip_vil1_float_ops::convert_to_float</a>(vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; <span class="keyword">const</span> &amp; image)
<a name="l00819"></a>00819 {
<a name="l00820"></a>00820   vil1_memory_image_of&lt;float&gt; output;
<a name="l00821"></a>00821   <span class="keyword">const</span> <span class="keywordtype">int</span> w = image.width(), h = image.height();
<a name="l00822"></a>00822   output.resize(w,h);
<a name="l00823"></a>00823   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l00824"></a>00824     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l00825"></a>00825       output(x,y) = (float)image(x,y).grey();
<a name="l00826"></a>00826   <span class="keywordflow">return</span> output;
<a name="l00827"></a>00827 }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 vil1_memory_image_of&lt;float&gt;
<a name="l00830"></a><a class="code" href="classbrip__vil1__float__ops.html#a6e36e8c353faa0771475a6c42b3634ba">00830</a> <a class="code" href="classbrip__vil1__float__ops.html#ad72be5f2d266971edde5ec8fcaebb9d9" title="converts a vil1_image to a float image.">brip_vil1_float_ops::convert_to_float</a>(<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;float&gt;</a> <span class="keyword">const</span> &amp; matrix)
<a name="l00831"></a>00831 {
<a name="l00832"></a>00832   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nr = matrix.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>(), nc = matrix.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00833"></a>00833   vil1_memory_image_of&lt;float&gt; out(nc, nr);
<a name="l00834"></a>00834   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r&lt;nr; ++r)
<a name="l00835"></a>00835     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c&lt;nc; ++c)
<a name="l00836"></a>00836       out(c,r)=matrix[r][c];
<a name="l00837"></a>00837   <span class="keywordflow">return</span> out;
<a name="l00838"></a>00838 }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 <span class="keyword">static</span> <span class="keywordtype">void</span> rgb_to_ihs(vil1_rgb&lt;unsigned char&gt; <span class="keyword">const</span> &amp; rgb,
<a name="l00841"></a>00841                        <span class="keywordtype">float</span>&amp; i, <span class="keywordtype">float</span>&amp; h, <span class="keywordtype">float</span>&amp; s)
<a name="l00842"></a>00842 {
<a name="l00843"></a>00843   <span class="comment">// Reference: figure 13.36, page 595 of Foley &amp; van Dam</span>
<a name="l00844"></a>00844   <span class="keywordtype">float</span> r = rgb.R(), g = rgb.G(), b = rgb.B();
<a name="l00845"></a>00845   i = rgb.grey();
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   <span class="keywordtype">float</span> <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/vbl__attributes_8h.html#aa183d966bcf99457a0c040f19e9aaf78">maxval</a> = <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__decnum_8h.html#a17c47eb693cfd88c7b181b162eca8dec">vnl_math_max</a>(r, <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__decnum_8h.html#a17c47eb693cfd88c7b181b162eca8dec">vnl_math_max</a>(g, b));
<a name="l00848"></a>00848   <span class="keywordtype">float</span> <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/vbl__attributes_8h.html#a5279cd0ed4e58a0d88bfd450a6cded2a">minval</a> = <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__decnum_8h.html#ac7064c7fc83d5d457e5f903eacac9f73">vnl_math_min</a>(r, <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__decnum_8h.html#ac7064c7fc83d5d457e5f903eacac9f73">vnl_math_min</a>(g, b));
<a name="l00849"></a>00849 
<a name="l00850"></a>00850   <span class="comment">//lightness</span>
<a name="l00851"></a>00851   <span class="keywordtype">float</span> la = (maxval + minval) / 2.f;
<a name="l00852"></a>00852   <span class="comment">// Achromatic case, intensity is grey or near black or white</span>
<a name="l00853"></a>00853   <span class="keywordflow">if</span> (maxval == minval||i&lt;20||i&gt;235)
<a name="l00854"></a>00854   {
<a name="l00855"></a>00855     s = -1.f;
<a name="l00856"></a>00856     h = 0.f;
<a name="l00857"></a>00857   }
<a name="l00858"></a>00858   <span class="keywordflow">else</span><span class="comment">//the chromatic case</span>
<a name="l00859"></a>00859   {
<a name="l00860"></a>00860     <span class="comment">// Calculate the saturation.</span>
<a name="l00861"></a>00861     <span class="keywordflow">if</span> (la &lt;= 127)
<a name="l00862"></a>00862     {
<a name="l00863"></a>00863       s = (255.f*(maxval - minval))/(maxval + minval);
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865     <span class="keywordflow">else</span>
<a name="l00866"></a>00866     {
<a name="l00867"></a>00867       s = (255.f*(maxval - minval)) / (512.f - maxval - minval);
<a name="l00868"></a>00868       <span class="keywordflow">if</span> (s&lt;0)
<a name="l00869"></a>00869         s = 0.f;
<a name="l00870"></a>00870       <span class="keywordflow">if</span> (s&gt;255)
<a name="l00871"></a>00871         s = 255.f;
<a name="l00872"></a>00872     }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     <span class="comment">// Calculate the hue.</span>
<a name="l00875"></a>00875     <span class="keywordtype">float</span> delta = maxval - minval;
<a name="l00876"></a>00876     <span class="keywordflow">if</span> (r == maxval)
<a name="l00877"></a>00877     {
<a name="l00878"></a>00878       <span class="comment">// The resulting color is between yellow and magenta.</span>
<a name="l00879"></a>00879       h = (60*(g - b))/ delta;
<a name="l00880"></a>00880     }
<a name="l00881"></a>00881     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (g == maxval)
<a name="l00882"></a>00882     {
<a name="l00883"></a>00883       <span class="comment">// The resulting color is between cyan and yellow.</span>
<a name="l00884"></a>00884       h = 120.f + (60*(b - r))/delta;
<a name="l00885"></a>00885     }
<a name="l00886"></a>00886     <span class="keywordflow">else</span>
<a name="l00887"></a>00887     {
<a name="l00888"></a>00888       <span class="comment">// The resulting color is between magenta and cyan.</span>
<a name="l00889"></a>00889       h = 240.f + (60*(r - g))/delta;
<a name="l00890"></a>00890     }
<a name="l00891"></a>00891     <span class="comment">// Be sure 0 &lt;= hue &lt;= 360</span>
<a name="l00892"></a>00892     <span class="keywordflow">if</span> (h &lt; 0)
<a name="l00893"></a>00893       h += 360.f;
<a name="l00894"></a>00894     <span class="keywordflow">if</span> (h &gt; 360)
<a name="l00895"></a>00895       h -= 360.f;
<a name="l00896"></a>00896   }
<a name="l00897"></a>00897 }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#ac9a2cee2f0b49c0710cafe4f1089a23f" title="convert a color image to float IHS images.">brip_vil1_float_ops::</a>
<a name="l00901"></a><a class="code" href="classbrip__vil1__float__ops.html#ac9a2cee2f0b49c0710cafe4f1089a23f">00901</a> <a class="code" href="classbrip__vil1__float__ops.html#ac9a2cee2f0b49c0710cafe4f1089a23f" title="convert a color image to float IHS images.">convert_to_IHS</a>(vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt;<span class="keyword">const</span>&amp; image,
<a name="l00902"></a>00902                vil1_memory_image_of&lt;float&gt;&amp; I,
<a name="l00903"></a>00903                vil1_memory_image_of&lt;float&gt;&amp; H,
<a name="l00904"></a>00904                vil1_memory_image_of&lt;float&gt;&amp; S)
<a name="l00905"></a>00905 {
<a name="l00906"></a>00906   <span class="keyword">const</span> <span class="keywordtype">int</span> w = image.width(), h = image.height();
<a name="l00907"></a>00907   I.resize(w,h);
<a name="l00908"></a>00908   H.resize(w,h);
<a name="l00909"></a>00909   S.resize(w,h);
<a name="l00910"></a>00910   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; h; r++)
<a name="l00911"></a>00911     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; w; c++)
<a name="l00912"></a>00912     {
<a name="l00913"></a>00913       <span class="keywordtype">float</span> in, hue, sat;
<a name="l00914"></a>00914       rgb_to_ihs(image(c,r), in, hue, sat);
<a name="l00915"></a>00915       I(c,r) = in;
<a name="l00916"></a>00916       H(c,r) = hue;
<a name="l00917"></a>00917       S(c,r) = sat;
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919 }
<a name="l00920"></a>00920 
<a name="l00921"></a>00921 <span class="preprocessor">#if 0 // this method commented out</span>
<a name="l00922"></a>00922 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#a649925a76feb21c9df4917410dcb4b6e" title="display IHS images as RGB (not conversion from IHS to RGB).">brip_vil1_float_ops::</a>
<a name="l00923"></a>00923 <a class="code" href="classbrip__vil1__float__ops.html#a649925a76feb21c9df4917410dcb4b6e" title="display IHS images as RGB (not conversion from IHS to RGB).">display_IHS_as_RGB</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; I,
<a name="l00924"></a>00924                    vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; H,
<a name="l00925"></a>00925                    vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; S,
<a name="l00926"></a>00926                    vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt;&amp; image)
<a name="l00927"></a>00927 {
<a name="l00928"></a>00928   <span class="keyword">const</span> <span class="keywordtype">int</span> w = I.width(), h = I.height();
<a name="l00929"></a>00929   image.resize(w,h);
<a name="l00930"></a>00930   <span class="keywordtype">float</span> s = 255.0f/360.0f;
<a name="l00931"></a>00931   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; h; r++)
<a name="l00932"></a>00932     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; w; c++)
<a name="l00933"></a>00933     {
<a name="l00934"></a>00934       <span class="keywordtype">float</span> in, hue, sat;
<a name="l00935"></a>00935       in = I(c,r);
<a name="l00936"></a>00936       hue = H(c,r);
<a name="l00937"></a>00937       sat = S(c,r);
<a name="l00938"></a>00938       <span class="keywordflow">if</span> (in&lt;0)
<a name="l00939"></a>00939         in = 0;
<a name="l00940"></a>00940       <span class="keywordflow">if</span> (sat&lt;0)
<a name="l00941"></a>00941         sat = 0;
<a name="l00942"></a>00942       <span class="keywordflow">if</span> (hue&lt;0)
<a name="l00943"></a>00943         hue = 0;
<a name="l00944"></a>00944       <span class="keywordflow">if</span> (in&gt;255)
<a name="l00945"></a>00945         in = 255;
<a name="l00946"></a>00946       hue *=s;
<a name="l00947"></a>00947       <span class="keywordflow">if</span> (hue&gt;255)
<a name="l00948"></a>00948         hue = 255;
<a name="l00949"></a>00949       <span class="keywordflow">if</span> (sat&gt;255)
<a name="l00950"></a>00950         sat = 255;
<a name="l00951"></a>00951       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> vi = (<span class="keywordtype">unsigned</span> char)in, vh = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)hue, vs = (<span class="keywordtype">unsigned</span> char)sat;
<a name="l00952"></a>00952       image(c,r) = vil1_rgb&lt;unsigned char&gt;(vi, vh, vs);
<a name="l00953"></a>00953     }
<a name="l00954"></a>00954 }
<a name="l00955"></a>00955 <span class="preprocessor">#endif // 0</span>
<a name="l00956"></a>00956 <span class="preprocessor"></span>
<a name="l00957"></a>00957 <span class="comment">//: map so that intensity is proportional to saturation and hue is color</span>
<a name="l00958"></a>00958 <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#a649925a76feb21c9df4917410dcb4b6e" title="display IHS images as RGB (not conversion from IHS to RGB).">brip_vil1_float_ops::</a>
<a name="l00959"></a><a class="code" href="classbrip__vil1__float__ops.html#a649925a76feb21c9df4917410dcb4b6e">00959</a> <a class="code" href="classbrip__vil1__float__ops.html#a649925a76feb21c9df4917410dcb4b6e" title="display IHS images as RGB (not conversion from IHS to RGB).">display_IHS_as_RGB</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; I,
<a name="l00960"></a>00960                    vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; H,
<a name="l00961"></a>00961                    vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; S,
<a name="l00962"></a>00962                    vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt;&amp; image)
<a name="l00963"></a>00963 {
<a name="l00964"></a>00964   <span class="keyword">const</span> <span class="keywordtype">int</span> w = I.width(), h = I.height();
<a name="l00965"></a>00965   image.resize(w,h);
<a name="l00966"></a>00966 
<a name="l00967"></a>00967   <span class="keyword">const</span> <span class="keywordtype">float</span> deg_to_rad = float(vnl_math::pi_over_180);
<a name="l00968"></a>00968   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; h; r++)
<a name="l00969"></a>00969     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; w; c++)
<a name="l00970"></a>00970     {
<a name="l00971"></a>00971       <span class="keywordtype">float</span> hue = H(c,r);
<a name="l00972"></a>00972       <span class="keywordtype">float</span> sat = 2.f*S(c,r);
<a name="l00973"></a>00973       <span class="keywordflow">if</span> (sat&lt;0)
<a name="l00974"></a>00974         sat = 0.f;
<a name="l00975"></a>00975       <span class="keywordflow">if</span> (sat&gt;255)
<a name="l00976"></a>00976         sat = 255.f;
<a name="l00977"></a>00977       <span class="keywordtype">float</span> ang = deg_to_rad*hue;
<a name="l00978"></a>00978       <span class="keywordtype">float</span> cs = vcl_cos(ang), si = vcl_fabs(vcl_sin(ang));
<a name="l00979"></a>00979       <span class="keywordtype">float</span> red,green,blue;
<a name="l00980"></a>00980       green = si*sat;
<a name="l00981"></a>00981       <span class="keywordflow">if</span> (cs&gt;=0)
<a name="l00982"></a>00982       {
<a name="l00983"></a>00983         red = cs*sat;
<a name="l00984"></a>00984         blue = 0;
<a name="l00985"></a>00985       }
<a name="l00986"></a>00986       <span class="keywordflow">else</span>
<a name="l00987"></a>00987       {
<a name="l00988"></a>00988         red = 0;
<a name="l00989"></a>00989         blue = sat*(-cs);
<a name="l00990"></a>00990       }
<a name="l00991"></a>00991       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rc = (<span class="keywordtype">unsigned</span> char)red,
<a name="l00992"></a>00992         gc = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)green, bc = (<span class="keywordtype">unsigned</span> char)blue;
<a name="l00993"></a>00993       image(c,r)= vil1_rgb&lt;unsigned char&gt;(rc, gc, bc);
<a name="l00994"></a>00994     }
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 vil1_memory_image_of&lt;float&gt;
<a name="l00998"></a><a class="code" href="classbrip__vil1__float__ops.html#ad72be5f2d266971edde5ec8fcaebb9d9">00998</a> <a class="code" href="classbrip__vil1__float__ops.html#ad72be5f2d266971edde5ec8fcaebb9d9" title="converts a vil1_image to a float image.">brip_vil1_float_ops::convert_to_float</a>(vil1_image <span class="keyword">const</span> &amp; image)
<a name="l00999"></a>00999 {
<a name="l01000"></a>01000   vil1_memory_image_of&lt;float&gt; fimg;
<a name="l01001"></a>01001   <span class="keywordflow">if</span> (image.components()==1)
<a name="l01002"></a>01002   {
<a name="l01003"></a>01003     <span class="keywordflow">if</span> (image.component_format()==VIL1_COMPONENT_FORMAT_IEEE_FLOAT)
<a name="l01004"></a>01004     <span class="comment">//already a float image</span>
<a name="l01005"></a>01005     {
<a name="l01006"></a>01006       fimg = vil1_memory_image_of&lt;float&gt;(image);
<a name="l01007"></a>01007       <span class="keywordflow">return</span> fimg;
<a name="l01008"></a>01008     }
<a name="l01009"></a>01009     vil1_memory_image_of&lt;unsigned char&gt; temp(image);
<a name="l01010"></a>01010     fimg = <a class="code" href="classbrip__vil1__float__ops.html#ad72be5f2d266971edde5ec8fcaebb9d9" title="converts a vil1_image to a float image.">brip_vil1_float_ops::convert_to_float</a>(temp);
<a name="l01011"></a>01011   }
<a name="l01012"></a>01012   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (image.components()==3)
<a name="l01013"></a>01013   {
<a name="l01014"></a>01014     vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; temp(image);
<a name="l01015"></a>01015     fimg = <a class="code" href="classbrip__vil1__float__ops.html#ad72be5f2d266971edde5ec8fcaebb9d9" title="converts a vil1_image to a float image.">brip_vil1_float_ops::convert_to_float</a>(temp);
<a name="l01016"></a>01016   }
<a name="l01017"></a>01017   <span class="keywordflow">else</span>
<a name="l01018"></a>01018   {
<a name="l01019"></a>01019     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::convert_to_float - input not color or grey\n&quot;</span>;
<a name="l01020"></a>01020     <span class="keywordflow">return</span> vil1_memory_image_of&lt;float&gt;();
<a name="l01021"></a>01021   }
<a name="l01022"></a>01022   <span class="keywordflow">return</span> fimg;
<a name="l01023"></a>01023 }
<a name="l01024"></a>01024 
<a name="l01025"></a>01025 <span class="comment">//-----------------------------------------------------------------</span>
<a name="l01026"></a>01026 <span class="comment">// : convert a vil1_rgb&lt;unsigned char&gt; image to an unsigned_char image.</span>
<a name="l01027"></a>01027 vil1_memory_image_of&lt;unsigned char&gt;
<a name="l01028"></a><a class="code" href="classbrip__vil1__float__ops.html#aaf71ab7cc9d1287fa039a5e07c21326b">01028</a> <a class="code" href="classbrip__vil1__float__ops.html#aaf71ab7cc9d1287fa039a5e07c21326b" title="converts a generic image to greyscale (RGB&lt;unsigned char&gt;).">brip_vil1_float_ops::convert_to_grey</a>(vil1_image <span class="keyword">const</span>&amp; image)
<a name="l01029"></a>01029 {
<a name="l01030"></a>01030   <span class="keywordflow">if</span> (!image)
<a name="l01031"></a>01031     <span class="keywordflow">return</span> vil1_memory_image_of&lt;unsigned char&gt;();
<a name="l01032"></a>01032 
<a name="l01033"></a>01033   <span class="comment">//Check if the image is a float</span>
<a name="l01034"></a>01034   <span class="keywordflow">if</span> (image.components()==1 &amp;&amp;
<a name="l01035"></a>01035       image.component_format()==VIL1_COMPONENT_FORMAT_IEEE_FLOAT)
<a name="l01036"></a>01036     <span class="keywordflow">return</span> <a class="code" href="classbrip__vil1__float__ops.html#a8c280ca5933effd5217f76a1e4e73947" title="converts a float image to a byte value range.">brip_vil1_float_ops::convert_to_byte</a>(vil1_memory_image_of&lt;float&gt;(image));
<a name="l01037"></a>01037 
<a name="l01038"></a>01038   <span class="comment">//Here we assume that the image is an unsigned char</span>
<a name="l01039"></a>01039   <span class="comment">//In this case we should just return it.</span>
<a name="l01040"></a>01040   <span class="keywordflow">if</span> (image.components()!=3)
<a name="l01041"></a>01041     <span class="keywordflow">return</span> vil1_memory_image_of&lt;unsigned char&gt;(image);
<a name="l01042"></a>01042 
<a name="l01043"></a>01043   <span class="comment">// the image is color so we should convert it to greyscale</span>
<a name="l01044"></a>01044   <span class="comment">// Here we assume the color elements are unsigned char.</span>
<a name="l01045"></a>01045   vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; color_image(image);
<a name="l01046"></a>01046   <span class="keyword">const</span> <span class="keywordtype">int</span> width = color_image.width(), height = color_image.height();
<a name="l01047"></a>01047   <span class="comment">// the output image</span>
<a name="l01048"></a>01048   vil1_memory_image_of&lt;unsigned char&gt; grey_image;
<a name="l01049"></a>01049   grey_image.resize(width, height);
<a name="l01050"></a>01050   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;height; y++)
<a name="l01051"></a>01051     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;width; x++)
<a name="l01052"></a>01052       grey_image(x,y) = color_image(x,y).grey();
<a name="l01053"></a>01053   <span class="keywordflow">return</span> grey_image;
<a name="l01054"></a>01054 }
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 <span class="comment">//--------------------------------------------------------------</span>
<a name="l01057"></a>01057 <span class="comment">// Read a convolution kernel from file</span>
<a name="l01058"></a>01058 <span class="comment">// Assumes a square kernel with odd dimensions, i.e., w,h = 2n+1</span>
<a name="l01059"></a>01059 <span class="comment">// format:</span>
<a name="l01060"></a>01060 <span class="comment">//     n</span>
<a name="l01061"></a>01061 <span class="comment">//     scale</span>
<a name="l01062"></a>01062 <span class="comment">//     k00  k01  ... k02n</span>
<a name="l01063"></a>01063 <span class="comment">//           ...</span>
<a name="l01064"></a>01064 <span class="comment">//     k2n0 k2n1 ... k2n2n</span>
<a name="l01065"></a>01065 <span class="comment">//</span>
<a name="l01066"></a><a class="code" href="classbrip__vil1__float__ops.html#a5d24d53b89cd063e0c87864121b50217">01066</a> <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;float&gt;</a> <a class="code" href="classbrip__vil1__float__ops.html#a5d24d53b89cd063e0c87864121b50217" title="loads a 2n+1 x 2n+1 convolution kernel (see .cxx for file format).">brip_vil1_float_ops::load_kernel</a>(vcl_string <span class="keyword">const</span> &amp; file)
<a name="l01067"></a>01067 {
<a name="l01068"></a>01068   vcl_ifstream instr(file.c_str(), vcl_ios::in);
<a name="l01069"></a>01069   <span class="keywordflow">if</span> (!instr)
<a name="l01070"></a>01070   {
<a name="l01071"></a>01071     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::load_kernel - failed to load kernel\n&quot;</span>;
<a name="l01072"></a>01072     <span class="keywordflow">return</span> <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;float&gt;</a>(0,0);
<a name="l01073"></a>01073   }
<a name="l01074"></a>01074   <span class="keywordtype">int</span> n;
<a name="l01075"></a>01075   <span class="keywordtype">float</span> scale;
<a name="l01076"></a>01076   <span class="keywordtype">float</span> <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__vector__2d_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a> =0;
<a name="l01077"></a>01077   instr &gt;&gt; n;
<a name="l01078"></a>01078   instr &gt;&gt; scale;
<a name="l01079"></a>01079   <span class="keywordtype">int</span> N = 2*n+1;
<a name="l01080"></a>01080   <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;float&gt;</a> output(N, N);
<a name="l01081"></a>01081   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;N; y++)
<a name="l01082"></a>01082     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;N; x++)
<a name="l01083"></a>01083     {
<a name="l01084"></a>01084       instr &gt;&gt; v;
<a name="l01085"></a>01085       output.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html#a67eebbfbe4e8a3b8822abf94f35ceb43">put</a>(x, y, v/scale);
<a name="l01086"></a>01086     }
<a name="l01087"></a>01087   vcl_cout &lt;&lt; <span class="stringliteral">&quot;The Kernel\n&quot;</span>;
<a name="l01088"></a>01088   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;N; y++)
<a name="l01089"></a>01089   {
<a name="l01090"></a>01090     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;N; x++)
<a name="l01091"></a>01091       vcl_cout &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt;  output[x][y];
<a name="l01092"></a>01092     vcl_cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l01093"></a>01093   }
<a name="l01094"></a>01094   <span class="keywordflow">return</span> output;
<a name="l01095"></a>01095 }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097 <span class="keyword">static</span> <span class="keywordtype">void</span> insert_image(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; image, <span class="keywordtype">int</span> col,
<a name="l01098"></a>01098                          <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;float&gt;</a> &amp; I)
<a name="l01099"></a>01099 {
<a name="l01100"></a>01100   <span class="keyword">const</span> <span class="keywordtype">int</span> width = image.width(), height = image.height();
<a name="l01101"></a>01101   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0, row = 0; y&lt;height; ++y)
<a name="l01102"></a>01102     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;width; x++, ++row) <span class="comment">// row runs from 0 to width*height-1</span>
<a name="l01103"></a>01103       I.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html#a45a132d7cafb7f0ceb414efd48802fb0">put</a>(row, col, image(x,y));
<a name="l01104"></a>01104 }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#a7bd38a3edacf21df0f82f9a78c4fec17" title="compute basis images for a set of input images.">brip_vil1_float_ops::</a>
<a name="l01107"></a><a class="code" href="classbrip__vil1__float__ops.html#a7bd38a3edacf21df0f82f9a78c4fec17">01107</a> <a class="code" href="classbrip__vil1__float__ops.html#a7bd38a3edacf21df0f82f9a78c4fec17" title="compute basis images for a set of input images.">basis_images</a>(vcl_vector&lt;vil1_memory_image_of&lt;float&gt; &gt; <span class="keyword">const</span> &amp; input_images,
<a name="l01108"></a>01108              vcl_vector&lt;vil1_memory_image_of&lt;float&gt; &gt; &amp; basis)
<a name="l01109"></a>01109 {
<a name="l01110"></a>01110   basis.clear();
<a name="l01111"></a>01111   <span class="keywordtype">int</span> n_images = input_images.size();
<a name="l01112"></a>01112   <span class="keywordflow">if</span> (!n_images)
<a name="l01113"></a>01113   {
<a name="l01114"></a>01114     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::basis_images(.) - no input images\n&quot;</span>;
<a name="l01115"></a>01115     <span class="keywordflow">return</span>;
<a name="l01116"></a>01116   }
<a name="l01117"></a>01117   <span class="keyword">const</span> <span class="keywordtype">int</span> width = input_images[0].width(), height = input_images[0].height();
<a name="l01118"></a>01118   <span class="keyword">const</span> <span class="keywordtype">int</span> npix = width*height;
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="comment">//Insert the images into matrix I</span>
<a name="l01121"></a>01121   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;float&gt;</a> I(npix, n_images, 0.f);
<a name="l01122"></a>01122   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;n_images; i++)
<a name="l01123"></a>01123     insert_image(input_images[i], i, I);
<a name="l01124"></a>01124 
<a name="l01125"></a>01125   <span class="comment">//Compute the SVD of matrix I</span>
<a name="l01126"></a>01126   vcl_cout &lt;&lt; <span class="stringliteral">&quot;Computing Singular values of a &quot;</span> &lt;&lt;  npix &lt;&lt; <span class="stringliteral">&quot; by &quot;</span>
<a name="l01127"></a>01127            &lt;&lt; n_images &lt;&lt; <span class="stringliteral">&quot; matrix\n&quot;</span>;
<a name="l01128"></a>01128   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l01129"></a>01129   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__svd.html">vnl_svd&lt;float&gt;</a> svd(I);
<a name="l01130"></a>01130   vcl_cout &lt;&lt; <span class="stringliteral">&quot;SVD Took &quot;</span> &lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs\n&quot;</span>
<a name="l01131"></a>01131            &lt;&lt; <span class="stringliteral">&quot;Eigenvalues:\n&quot;</span>;
<a name="l01132"></a>01132   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;n_images; i++)
<a name="l01133"></a>01133     vcl_cout &lt;&lt; svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__svd.html#a3b3197be0858ae3315117e6d49cfa4ff">W</a>(i) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l01134"></a>01134 
<a name="l01135"></a>01135   <span class="comment">//Extract the Basis images</span>
<a name="l01136"></a>01136   <span class="keywordtype">int</span> rank = svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__svd.html#a8bd7961063ebeda214bfb7fad8e63c3c">rank</a>();
<a name="l01137"></a>01137   <span class="keywordflow">if</span> (!rank)
<a name="l01138"></a>01138   {
<a name="l01139"></a>01139     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::basis_images(.) - I has zero rank\n&quot;</span>;
<a name="l01140"></a>01140     <span class="keywordflow">return</span>;
<a name="l01141"></a>01141   }
<a name="l01142"></a>01142   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;float&gt;</a> U = svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__svd.html#ab90d87b0dd53bb3afe92e7c4e6a1d090">U</a>();
<a name="l01143"></a>01143   <span class="comment">//Output the basis images</span>
<a name="l01144"></a>01144   <span class="keywordtype">int</span> rows = U.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>();
<a name="l01145"></a>01145   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k&lt;rank; k++)
<a name="l01146"></a>01146   {
<a name="l01147"></a>01147     vil1_memory_image_of&lt;float&gt; out(width, height);
<a name="l01148"></a>01148     <span class="keywordtype">int</span> x =0, y = 0;
<a name="l01149"></a>01149     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;rows; r++)
<a name="l01150"></a>01150     {
<a name="l01151"></a>01151       out(x, y) = U(r,k);
<a name="l01152"></a>01152       x++;
<a name="l01153"></a>01153       <span class="keywordflow">if</span> (x&gt;=width)
<a name="l01154"></a>01154       {
<a name="l01155"></a>01155         y++;
<a name="l01156"></a>01156         x=0;
<a name="l01157"></a>01157       }
<a name="l01158"></a>01158       <span class="keywordflow">if</span> (y&gt;=width)
<a name="l01159"></a>01159       {
<a name="l01160"></a>01160         vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::basis_images(.) - shouldn&#39;t happen\n&quot;</span>;
<a name="l01161"></a>01161         <span class="keywordflow">return</span>;
<a name="l01162"></a>01162       }
<a name="l01163"></a>01163     }
<a name="l01164"></a>01164     basis.push_back(out);
<a name="l01165"></a>01165   }
<a name="l01166"></a>01166 }
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="comment">//: 1d fourier transform</span>
<a name="l01169"></a>01169 <span class="comment">//-------------------------------------------------------------------------</span>
<a name="l01170"></a>01170 <span class="comment">// This computes an in-place complex-to-complex FFT</span>
<a name="l01171"></a>01171 <span class="comment">// x and y are the real and imaginary arrays of 2^m points.</span>
<a name="l01172"></a>01172 <span class="comment">// dir =  1 gives forward transform</span>
<a name="l01173"></a>01173 <span class="comment">// dir = -1 gives reverse transform</span>
<a name="l01174"></a>01174 <span class="comment">//</span>
<a name="l01175"></a>01175 <span class="comment">//   Formula: forward</span>
<a name="l01176"></a>01176 <span class="comment">//                N-1</span>
<a name="l01177"></a>01177 <span class="comment">//                ---</span>
<a name="l01178"></a>01178 <span class="comment">//            1   \          - j k 2 pi n / N</span>
<a name="l01179"></a>01179 <span class="comment">//    X(n) = ---   &gt;   x(k) e                    = forward transform</span>
<a name="l01180"></a>01180 <span class="comment">//            N   /                                n=0..N-1</span>
<a name="l01181"></a>01181 <span class="comment">//                ---</span>
<a name="l01182"></a>01182 <span class="comment">//                k=0</span>
<a name="l01183"></a>01183 <span class="comment">//</span>
<a name="l01184"></a>01184 <span class="comment">//    Formula: reverse</span>
<a name="l01185"></a>01185 <span class="comment">//                N-1</span>
<a name="l01186"></a>01186 <span class="comment">//                ---</span>
<a name="l01187"></a>01187 <span class="comment">//                \          j k 2 pi n / N</span>
<a name="l01188"></a>01188 <span class="comment">//    X(n) =       &gt;   x(k) e                    = forward transform</span>
<a name="l01189"></a>01189 <span class="comment">//                /                                n=0..N-1</span>
<a name="l01190"></a>01190 <span class="comment">//                ---</span>
<a name="l01191"></a>01191 <span class="comment">//                k=0</span>
<a name="l01192"></a><a class="code" href="classbrip__vil1__float__ops.html#a13769b750efa7c9fe54412adf8b9978d">01192</a> <span class="comment">//</span>
<a name="l01193"></a>01193 <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#a13769b750efa7c9fe54412adf8b9978d" title="One-dimensional fft.">brip_vil1_float_ops::fft_1d</a>(<span class="keywordtype">int</span> dir, <span class="keywordtype">int</span> m, <span class="keywordtype">double</span>* x, <span class="keywordtype">double</span>* y)
<a name="l01194"></a>01194 {
<a name="l01195"></a>01195   <span class="keywordtype">long</span> nn,i,i1,j,k,i2,<a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__homg__line__2d_8h.html#a1cb503ddd20ff3cf9588d2b5abd202d8">l</a>,l1,l2;
<a name="l01196"></a>01196   <span class="keywordtype">double</span> c1,c2,tx,ty,t1,t2,u1,u2,z;
<a name="l01197"></a>01197 
<a name="l01198"></a>01198   <span class="comment">/* Calculate the number of points */</span>
<a name="l01199"></a>01199   nn = 1;
<a name="l01200"></a>01200   <span class="keywordflow">for</span> (i=0;i&lt;m;i++)
<a name="l01201"></a>01201     nn *= 2;
<a name="l01202"></a>01202 
<a name="l01203"></a>01203   <span class="comment">/* Do the bit reversal */</span>
<a name="l01204"></a>01204   i2 = nn &gt;&gt; 1;
<a name="l01205"></a>01205   j = 0;
<a name="l01206"></a>01206   <span class="keywordflow">for</span> (i=0;i&lt;nn-1;i++) {
<a name="l01207"></a>01207     <span class="keywordflow">if</span> (i &lt; j) {
<a name="l01208"></a>01208       tx = x[i];
<a name="l01209"></a>01209       ty = y[i];
<a name="l01210"></a>01210       x[i] = x[j];
<a name="l01211"></a>01211       y[i] = y[j];
<a name="l01212"></a>01212       x[j] = tx;
<a name="l01213"></a>01213       y[j] = ty;
<a name="l01214"></a>01214     }
<a name="l01215"></a>01215     k = i2;
<a name="l01216"></a>01216     <span class="keywordflow">while</span> (k &lt;= j) {
<a name="l01217"></a>01217       j -= k;
<a name="l01218"></a>01218       k &gt;&gt;= 1;
<a name="l01219"></a>01219     }
<a name="l01220"></a>01220     j += k;
<a name="l01221"></a>01221   }
<a name="l01222"></a>01222 
<a name="l01223"></a>01223   <span class="comment">// Compute the FFT</span>
<a name="l01224"></a>01224   c1 = -1.0;
<a name="l01225"></a>01225   c2 = 0.0;
<a name="l01226"></a>01226   l2 = 1;
<a name="l01227"></a>01227   <span class="keywordflow">for</span> (l=0;l&lt;m;l++) {
<a name="l01228"></a>01228     l1 = l2;
<a name="l01229"></a>01229     l2 &lt;&lt;= 1;
<a name="l01230"></a>01230     u1 = 1.0;
<a name="l01231"></a>01231     u2 = 0.0;
<a name="l01232"></a>01232     <span class="keywordflow">for</span> (j=0;j&lt;l1;j++) {
<a name="l01233"></a>01233       <span class="keywordflow">for</span> (i=j;i&lt;nn;i+=l2) {
<a name="l01234"></a>01234         i1 = i + l1;
<a name="l01235"></a>01235         t1 = u1 * x[i1] - u2 * y[i1];
<a name="l01236"></a>01236         t2 = u1 * y[i1] + u2 * x[i1];
<a name="l01237"></a>01237         x[i1] = x[i] - t1;
<a name="l01238"></a>01238         y[i1] = y[i] - t2;
<a name="l01239"></a>01239         x[i] += t1;
<a name="l01240"></a>01240         y[i] += t2;
<a name="l01241"></a>01241       }
<a name="l01242"></a>01242       z =  u1 * c1 - u2 * c2;
<a name="l01243"></a>01243       u2 = u1 * c2 + u2 * c1;
<a name="l01244"></a>01244       u1 = z;
<a name="l01245"></a>01245     }
<a name="l01246"></a>01246     c2 = vcl_sqrt((1.0 - c1) / 2.0);
<a name="l01247"></a>01247     <span class="keywordflow">if</span> (dir == 1)
<a name="l01248"></a>01248       c2 = -c2;
<a name="l01249"></a>01249     c1 = vcl_sqrt((1.0 + c1) / 2.0);
<a name="l01250"></a>01250   }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   <span class="comment">// Scaling for forward transform</span>
<a name="l01253"></a>01253   <span class="keywordflow">if</span> (dir == 1) {
<a name="l01254"></a>01254     <span class="keywordflow">for</span> (i=0;i&lt;nn;i++) {
<a name="l01255"></a>01255       x[i] /= (double)nn;
<a name="l01256"></a>01256       y[i] /= (double)nn;
<a name="l01257"></a>01257     }
<a name="l01258"></a>01258   }
<a name="l01259"></a>01259 
<a name="l01260"></a>01260   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01261"></a>01261 }
<a name="l01262"></a>01262 
<a name="l01263"></a>01263 <span class="comment">//-------------------------------------------------------------------------</span>
<a name="l01264"></a>01264 <span class="comment">//  Perform a 2D FFT inplace given a complex 2D array</span>
<a name="l01265"></a>01265 <span class="comment">//  The direction dir, 1 for forward, -1 for reverse</span>
<a name="l01266"></a>01266 <span class="comment">//  The size of the array (nx,ny)</span>
<a name="l01267"></a>01267 <span class="comment">//  Return false if there are memory problems or</span>
<a name="l01268"></a>01268 <span class="comment">//  the dimensions are not powers of 2</span>
<a name="l01269"></a><a class="code" href="classbrip__vil1__float__ops.html#aa33839a37f709d4df78b8e5ccb62a7dc">01269</a> <span class="comment">//</span>
<a name="l01270"></a>01270 <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#aa33839a37f709d4df78b8e5ccb62a7dc" title="Two-dimensional fft.">brip_vil1_float_ops::fft_2d</a>(<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix</a>&lt;vcl_complex&lt;double&gt; &gt;&amp; c,<span class="keywordtype">int</span> nx,<span class="keywordtype">int</span> ny,<span class="keywordtype">int</span> dir)
<a name="l01271"></a>01271 {
<a name="l01272"></a>01272   <span class="keywordtype">int</span> i,j;
<a name="l01273"></a>01273   <span class="keywordtype">int</span> mx, my;
<a name="l01274"></a>01274   <span class="keywordtype">double</span> *real,*imag;
<a name="l01275"></a>01275   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/structvnl__fft__prime__factors.html">vnl_fft_prime_factors&lt;double&gt;</a> pfx (nx);
<a name="l01276"></a>01276   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/structvnl__fft__prime__factors.html">vnl_fft_prime_factors&lt;double&gt;</a> pfy (ny);
<a name="l01277"></a>01277   mx = (int)pfx.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/structvnl__fft__prime__factors.html#a42171f28a2bc49207339986a5c514230">pqr</a>()[0];
<a name="l01278"></a>01278   my = (int)pfy.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/structvnl__fft__prime__factors.html#a42171f28a2bc49207339986a5c514230">pqr</a>()[0];
<a name="l01279"></a>01279   <span class="comment">/* Transform the rows */</span>
<a name="l01280"></a>01280   real = <span class="keyword">new</span> <span class="keywordtype">double</span>[nx];
<a name="l01281"></a>01281   imag = <span class="keyword">new</span> <span class="keywordtype">double</span>[nx];
<a name="l01282"></a>01282   <span class="keywordflow">if</span> (real == 0 || imag == 0)
<a name="l01283"></a>01283     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01284"></a>01284   <span class="keywordflow">for</span> (j=0;j&lt;ny;j++) {
<a name="l01285"></a>01285     <span class="keywordflow">for</span> (i=0;i&lt;nx;i++) {
<a name="l01286"></a>01286       real[i] = c[j][i].real();
<a name="l01287"></a>01287       imag[i] = c[j][i].imag();
<a name="l01288"></a>01288     }
<a name="l01289"></a>01289     <a class="code" href="classbrip__vil1__float__ops.html#a13769b750efa7c9fe54412adf8b9978d" title="One-dimensional fft.">brip_vil1_float_ops::fft_1d</a>(dir,mx,real,imag);
<a name="l01290"></a>01290     <span class="keywordflow">for</span> (i=0;i&lt;nx;i++) {
<a name="l01291"></a>01291       vcl_complex&lt;double&gt; <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__vector__2d_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>(real[i], imag[i]);
<a name="l01292"></a>01292       c[j][i] = v;
<a name="l01293"></a>01293     }
<a name="l01294"></a>01294   }
<a name="l01295"></a>01295   <span class="keyword">delete</span> [] real;
<a name="l01296"></a>01296   <span class="keyword">delete</span> [] imag;
<a name="l01297"></a>01297   <span class="comment">/* Transform the columns */</span>
<a name="l01298"></a>01298   real = <span class="keyword">new</span> <span class="keywordtype">double</span>[ny];
<a name="l01299"></a>01299   imag = <span class="keyword">new</span> <span class="keywordtype">double</span>[ny];
<a name="l01300"></a>01300   <span class="keywordflow">if</span> (real == 0 || imag == 0)
<a name="l01301"></a>01301     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01302"></a>01302   <span class="keywordflow">for</span> (i=0;i&lt;nx;i++) {
<a name="l01303"></a>01303     <span class="keywordflow">for</span> (j=0;j&lt;ny;j++) {
<a name="l01304"></a>01304       real[j] = c[j][i].real();
<a name="l01305"></a>01305       imag[j] = c[j][i].imag();
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307     <a class="code" href="classbrip__vil1__float__ops.html#a13769b750efa7c9fe54412adf8b9978d" title="One-dimensional fft.">fft_1d</a>(dir,my,real,imag);
<a name="l01308"></a>01308     <span class="keywordflow">for</span> (j=0;j&lt;ny;j++) {
<a name="l01309"></a>01309       vcl_complex&lt;double&gt; <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__vector__2d_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>(real[j], imag[j]);
<a name="l01310"></a>01310       c[j][i] =  v;
<a name="l01311"></a>01311     }
<a name="l01312"></a>01312   }
<a name="l01313"></a>01313   <span class="keyword">delete</span> [] real;
<a name="l01314"></a>01314   <span class="keyword">delete</span> [] imag;
<a name="l01315"></a>01315   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01316"></a>01316 }
<a name="l01317"></a>01317 
<a name="l01318"></a>01318 <span class="comment">//: reorder the transform values to sequential frequencies as in conventional Fourier transforms.</span>
<a name="l01319"></a>01319 <span class="comment">//  The transformation is its self-inverse.</span>
<a name="l01320"></a><a class="code" href="classbrip__vil1__float__ops.html#a29af65234efff96e5a3d78687bfb615e">01320</a> <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#a29af65234efff96e5a3d78687bfb615e" title="Transform the fft coefficients from/to fft/frequency order(self inverse).">brip_vil1_float_ops::</a>
<a name="l01321"></a>01321 <a class="code" href="classbrip__vil1__float__ops.html#a29af65234efff96e5a3d78687bfb615e" title="Transform the fft coefficients from/to fft/frequency order(self inverse).">ftt_fourier_2d_reorder</a>(<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix</a>&lt;vcl_complex&lt;double&gt; &gt; <span class="keyword">const</span>&amp; F1,
<a name="l01322"></a>01322                        <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix</a>&lt;vcl_complex&lt;double&gt; &gt; &amp; F2)
<a name="l01323"></a>01323 {
<a name="l01324"></a>01324   <span class="keywordtype">int</span> rows = F1.rows(), cols = F1.cols();
<a name="l01325"></a>01325   <span class="keywordtype">int</span> half_rows = rows/2, half_cols = cols/2;
<a name="l01326"></a>01326   <span class="keywordtype">int</span> ri, ci;
<a name="l01327"></a>01327   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;rows; r++)
<a name="l01328"></a>01328   {
<a name="l01329"></a>01329     <span class="keywordflow">if</span> (r&lt;half_rows)
<a name="l01330"></a>01330       ri = half_rows+r;
<a name="l01331"></a>01331     <span class="keywordflow">else</span>
<a name="l01332"></a>01332       ri = r-half_rows;
<a name="l01333"></a>01333     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c&lt;cols; c++)
<a name="l01334"></a>01334     {
<a name="l01335"></a>01335       <span class="keywordflow">if</span> (c&lt;half_cols)
<a name="l01336"></a>01336         ci = half_cols+c;
<a name="l01337"></a>01337       <span class="keywordflow">else</span>
<a name="l01338"></a>01338         ci = c-half_cols;
<a name="l01339"></a>01339       F2[ri][ci]=F1[r][c];
<a name="l01340"></a>01340     }
<a name="l01341"></a>01341   }
<a name="l01342"></a>01342 }
<a name="l01343"></a>01343 
<a name="l01344"></a>01344 <span class="comment">//:  Compute the fourier transform.</span>
<a name="l01345"></a>01345 <span class="comment">//   If the image dimensions are not a power of 2 then the operation fails.</span>
<a name="l01346"></a><a class="code" href="classbrip__vil1__float__ops.html#abe98c2ba039e15c2441cc5e7c2821faf">01346</a> <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#abe98c2ba039e15c2441cc5e7c2821faf" title="compute the Fourier transform using the vnl FFT algorithm.">brip_vil1_float_ops::</a>
<a name="l01347"></a>01347 <a class="code" href="classbrip__vil1__float__ops.html#abe98c2ba039e15c2441cc5e7c2821faf" title="compute the Fourier transform using the vnl FFT algorithm.">fourier_transform</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l01348"></a>01348                   vil1_memory_image_of&lt;float&gt;&amp; mag,
<a name="l01349"></a>01349                   vil1_memory_image_of&lt;float&gt;&amp; phase)
<a name="l01350"></a>01350 {
<a name="l01351"></a>01351   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l01352"></a>01352   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/structvnl__fft__prime__factors.html">vnl_fft_prime_factors&lt;float&gt;</a> pfx (w);
<a name="l01353"></a>01353   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/structvnl__fft__prime__factors.html">vnl_fft_prime_factors&lt;float&gt;</a> pfy (h);
<a name="l01354"></a>01354   <span class="keywordflow">if</span> (!pfx.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/structvnl__fft__prime__factors.html#a42171f28a2bc49207339986a5c514230">pqr</a>()[0]||!pfy.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/structvnl__fft__prime__factors.html#a42171f28a2bc49207339986a5c514230">pqr</a>()[0])
<a name="l01355"></a>01355     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01356"></a>01356   <span class="comment">//fill the fft matrix</span>
<a name="l01357"></a>01357   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;vcl_complex&lt;double&gt;</a> &gt; fft_matrix(h, w), fourier_matrix(h,w);
<a name="l01358"></a>01358   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l01359"></a>01359     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x =0; x&lt;w; x++)
<a name="l01360"></a>01360     {
<a name="l01361"></a>01361       vcl_complex&lt;double&gt; cv(input(x,y), 0.0);
<a name="l01362"></a>01362       fft_matrix.put(y, x, cv);
<a name="l01363"></a>01363     }
<a name="l01364"></a>01364 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l01365"></a>01365 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;h; r++)
<a name="l01366"></a>01366     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c =0; c&lt;w; c++)
<a name="l01367"></a>01367     {
<a name="l01368"></a>01368       vcl_complex&lt;double&gt; res = fft_matrix[r][c];
<a name="l01369"></a>01369       vcl_cout &lt;&lt; res &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l01370"></a>01370     }
<a name="l01371"></a>01371 <span class="preprocessor">#endif</span>
<a name="l01372"></a>01372 <span class="preprocessor"></span>
<a name="l01373"></a>01373   <a class="code" href="classbrip__vil1__float__ops.html#aa33839a37f709d4df78b8e5ccb62a7dc" title="Two-dimensional fft.">brip_vil1_float_ops::fft_2d</a>(fft_matrix, w, h, 1);
<a name="l01374"></a>01374   <a class="code" href="classbrip__vil1__float__ops.html#a29af65234efff96e5a3d78687bfb615e" title="Transform the fft coefficients from/to fft/frequency order(self inverse).">brip_vil1_float_ops::ftt_fourier_2d_reorder</a>(fft_matrix, fourier_matrix);
<a name="l01375"></a>01375   mag.resize(w,h);
<a name="l01376"></a>01376   phase.resize(w,h);
<a name="l01377"></a>01377 
<a name="l01378"></a>01378   <span class="comment">//extract magnitude and phase</span>
<a name="l01379"></a>01379   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;h; r++)
<a name="l01380"></a>01380     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c&lt;w; c++)
<a name="l01381"></a>01381     {
<a name="l01382"></a>01382       <span class="keywordtype">float</span> re = (float)fourier_matrix[r][c].real(), im = (float)fourier_matrix[r][c].imag();
<a name="l01383"></a>01383       mag(c,r) = vcl_sqrt(re*re + im*im);
<a name="l01384"></a>01384       phase(c,r) = vcl_atan2(im, re);
<a name="l01385"></a>01385     }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01388"></a>01388 }
<a name="l01389"></a>01389 
<a name="l01390"></a><a class="code" href="classbrip__vil1__float__ops.html#a1673f7dfd2c4acdd9b5646e63dbd9bcf">01390</a> <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#a1673f7dfd2c4acdd9b5646e63dbd9bcf" title="compute the inverse Fourier transform using the vnl FFT algorithm.">brip_vil1_float_ops::</a>
<a name="l01391"></a>01391 <a class="code" href="classbrip__vil1__float__ops.html#a1673f7dfd2c4acdd9b5646e63dbd9bcf" title="compute the inverse Fourier transform using the vnl FFT algorithm.">inverse_fourier_transform</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; mag,
<a name="l01392"></a>01392                           vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; phase,
<a name="l01393"></a>01393                           vil1_memory_image_of&lt;float&gt;&amp; output)
<a name="l01394"></a>01394 {
<a name="l01395"></a>01395   <span class="keyword">const</span> <span class="keywordtype">int</span> w = mag.width(), h = mag.height();
<a name="l01396"></a>01396   <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;vcl_complex&lt;double&gt;</a> &gt; fft_matrix(h, w), fourier_matrix(h, w);
<a name="l01397"></a>01397   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l01398"></a>01398     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x =0; x&lt;w; x++)
<a name="l01399"></a>01399     {
<a name="l01400"></a>01400       <span class="keywordtype">float</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a> = mag(x,y);
<a name="l01401"></a>01401       <span class="keywordtype">float</span> p = phase(x,y);
<a name="l01402"></a>01402       vcl_complex&lt;double&gt; cv(m*vcl_cos(p), m*vcl_sin(p));
<a name="l01403"></a>01403       fourier_matrix.<a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/classvnl__matrix.html#a45a132d7cafb7f0ceb414efd48802fb0">put</a>(y, x, cv);
<a name="l01404"></a>01404     }
<a name="l01405"></a>01405 
<a name="l01406"></a>01406   <a class="code" href="classbrip__vil1__float__ops.html#a29af65234efff96e5a3d78687bfb615e" title="Transform the fft coefficients from/to fft/frequency order(self inverse).">brip_vil1_float_ops::ftt_fourier_2d_reorder</a>(fourier_matrix, fft_matrix);
<a name="l01407"></a>01407   <a class="code" href="classbrip__vil1__float__ops.html#aa33839a37f709d4df78b8e5ccb62a7dc" title="Two-dimensional fft.">brip_vil1_float_ops::fft_2d</a>(fft_matrix, w, h, -1);
<a name="l01408"></a>01408 
<a name="l01409"></a>01409   output.resize(w,h);
<a name="l01410"></a>01410 
<a name="l01411"></a>01411   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;h; y++)
<a name="l01412"></a>01412     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;w; x++)
<a name="l01413"></a>01413       output(x,y) = (float)fft_matrix[y][x].real();
<a name="l01414"></a>01414   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01415"></a>01415 }
<a name="l01416"></a><a class="code" href="classbrip__vil1__float__ops.html#a19a1aa39eb7bf6cc1e6010121e0638dc">01416</a> 
<a name="l01417"></a>01417 <span class="keywordtype">void</span> <a class="code" href="classbrip__vil1__float__ops.html#a19a1aa39eb7bf6cc1e6010121e0638dc" title="resize to specified dimensions, fill with zeros if output is larger.">brip_vil1_float_ops::resize</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l01418"></a>01418                                  <span class="keyword">const</span> <span class="keywordtype">int</span> width, <span class="keyword">const</span> <span class="keywordtype">int</span> height,
<a name="l01419"></a>01419                                  vil1_memory_image_of&lt;float&gt;&amp; output)
<a name="l01420"></a>01420 {
<a name="l01421"></a>01421   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l01422"></a>01422   output.resize(width, height);
<a name="l01423"></a>01423   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;height; y++)
<a name="l01424"></a>01424     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;width; x++)
<a name="l01425"></a>01425       <span class="keywordflow">if</span> (x&lt;w &amp;&amp; y&lt;h)
<a name="l01426"></a>01426         output(x,y) = input(x,y);
<a name="l01427"></a>01427       <span class="keywordflow">else</span>
<a name="l01428"></a>01428         output(x,y) = 0;<span class="comment">//pad with zeroes</span>
<a name="l01429"></a>01429 }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431 <span class="comment">//: resize the input to the closest power of two image dimensions</span>
<a name="l01432"></a><a class="code" href="classbrip__vil1__float__ops.html#a50b5aea2998a8dc5ef3d2249f0c34b35">01432</a> <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#a50b5aea2998a8dc5ef3d2249f0c34b35" title="resize to closest power of two larger dimensions than the input.">brip_vil1_float_ops::</a>
<a name="l01433"></a>01433 <a class="code" href="classbrip__vil1__float__ops.html#a50b5aea2998a8dc5ef3d2249f0c34b35" title="resize to closest power of two larger dimensions than the input.">resize_to_power_of_two</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l01434"></a>01434                        vil1_memory_image_of&lt;float&gt;&amp; output)
<a name="l01435"></a>01435 {
<a name="l01436"></a>01436   <span class="keyword">const</span> <span class="keywordtype">int</span> max_exp = 13; <span class="comment">//we wouldn&#39;t want to have such large images in memory</span>
<a name="l01437"></a>01437   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l01438"></a>01438   <span class="keywordtype">int</span> prodw = 1, prodh = 1;
<a name="l01439"></a>01439   <span class="comment">//Find power of two width</span>
<a name="l01440"></a>01440   <span class="keywordtype">int</span> nw, nh;
<a name="l01441"></a>01441   <span class="keywordflow">for</span> (nw = 1; nw&lt;=max_exp; nw++)
<a name="l01442"></a>01442     <span class="keywordflow">if</span> (prodw&gt;w)
<a name="l01443"></a>01443       <span class="keywordflow">break</span>;
<a name="l01444"></a>01444     <span class="keywordflow">else</span>
<a name="l01445"></a>01445       prodw *= 2;
<a name="l01446"></a>01446   <span class="keywordflow">if</span> (nw==max_exp)
<a name="l01447"></a>01447     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01448"></a>01448   <span class="comment">//Find power of two height</span>
<a name="l01449"></a>01449   <span class="keywordflow">for</span> (nh = 1; nh&lt;=max_exp; nh++)
<a name="l01450"></a>01450     <span class="keywordflow">if</span> (prodh&gt;h)
<a name="l01451"></a>01451       <span class="keywordflow">break</span>;
<a name="l01452"></a>01452     <span class="keywordflow">else</span>
<a name="l01453"></a>01453       prodh *= 2;
<a name="l01454"></a>01454   <span class="keywordflow">if</span> (nh==max_exp)
<a name="l01455"></a>01455     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01456"></a>01456   <a class="code" href="classbrip__vil1__float__ops.html#a19a1aa39eb7bf6cc1e6010121e0638dc" title="resize to specified dimensions, fill with zeros if output is larger.">brip_vil1_float_ops::resize</a>(input, prodw, prodh, output);
<a name="l01457"></a>01457 
<a name="l01458"></a>01458   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01459"></a>01459 }
<a name="l01460"></a>01460 
<a name="l01461"></a>01461 <span class="comment">//</span>
<a name="l01462"></a>01462 <span class="comment">//: block a periodic signal by suppressing two Gaussian lobes in the frequency domain.</span>
<a name="l01463"></a>01463 <span class="comment">//  The lobes are on the line defined by dir_fx and dir_fy through the</span>
<a name="l01464"></a>01464 <span class="comment">//  dc origin, assumed (0, 0).  The center frequency, f0, is the distance along</span>
<a name="l01465"></a>01465 <span class="comment">//  the line to the center of each blocking lobe (+- f0). radius is the</span>
<a name="l01466"></a>01466 <span class="comment">//  standard deviation of each lobe. Later we can define a &quot;filter&quot; class.</span>
<a name="l01467"></a><a class="code" href="classbrip__vil1__float__ops.html#ae824911c3feeafa60379bebc0b47af1a">01467</a> <span class="comment">//</span>
<a name="l01468"></a>01468 <span class="keywordtype">float</span> <a class="code" href="classbrip__vil1__float__ops.html#ae824911c3feeafa60379bebc0b47af1a" title="Blocking filter function.">brip_vil1_float_ops::gaussian_blocking_filter</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> dir_fx,
<a name="l01469"></a>01469                                                     <span class="keyword">const</span> <span class="keywordtype">float</span> dir_fy,
<a name="l01470"></a>01470                                                     <span class="keyword">const</span> <span class="keywordtype">float</span> f0,
<a name="l01471"></a>01471                                                     <span class="keyword">const</span> <span class="keywordtype">float</span> radius,
<a name="l01472"></a>01472                                                     <span class="keyword">const</span> <span class="keywordtype">float</span> fx,
<a name="l01473"></a>01473                                                     <span class="keyword">const</span> <span class="keywordtype">float</span> fy)
<a name="l01474"></a>01474 {
<a name="l01475"></a>01475   <span class="comment">// normalize dir_fx and dir_fy</span>
<a name="l01476"></a>01476   <span class="keywordtype">float</span> mag = vcl_sqrt(dir_fx*dir_fx + dir_fy*dir_fy);
<a name="l01477"></a>01477   <span class="keywordflow">if</span> (!mag)
<a name="l01478"></a>01478     <span class="keywordflow">return</span> 0.f;
<a name="l01479"></a>01479   <span class="keywordtype">float</span> r2 = 2.f*radius*radius;
<a name="l01480"></a>01480   <span class="keywordtype">float</span> dx = dir_fx/mag, dy = dir_fy/mag;
<a name="l01481"></a>01481   <span class="comment">// compute the centers of each lobe</span>
<a name="l01482"></a>01482   <span class="keywordtype">float</span> fx0p = dx*f0, fy0p = dy*f0;
<a name="l01483"></a>01483   <span class="keywordtype">float</span> fx0m = -dx*f0, fy0m = -dy*f0;
<a name="l01484"></a>01484   <span class="comment">// the squared distance of fx, fy from each center</span>
<a name="l01485"></a>01485   <span class="keywordtype">float</span> d2p = (fx-fx0p)*(fx-fx0p) + (fy-fy0p)*(fy-fy0p);
<a name="l01486"></a>01486   <span class="keywordtype">float</span> d2m = (fx-fx0m)*(fx-fx0m) + (fy-fy0m)*(fy-fy0m);
<a name="l01487"></a>01487   <span class="comment">// use the closest lobe</span>
<a name="l01488"></a>01488   <span class="keywordtype">float</span> d = d2p;
<a name="l01489"></a>01489   <span class="keywordflow">if</span> (d2m&lt;d2p)
<a name="l01490"></a>01490     d = d2m;
<a name="l01491"></a>01491   <span class="comment">// the gaussian blocking function</span>
<a name="l01492"></a>01492   <span class="keywordtype">float</span> gb = 1.f-(float)vcl_exp(-d/r2);
<a name="l01493"></a>01493   <span class="keywordflow">return</span> gb;
<a name="l01494"></a>01494 }
<a name="l01495"></a>01495 
<a name="l01496"></a><a class="code" href="classbrip__vil1__float__ops.html#acaeb9ad6fd0fb79bf82a67d81494c067">01496</a> <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#acaeb9ad6fd0fb79bf82a67d81494c067" title="filter the input image with a Gaussian blocking filter.">brip_vil1_float_ops::</a>
<a name="l01497"></a>01497 <a class="code" href="classbrip__vil1__float__ops.html#acaeb9ad6fd0fb79bf82a67d81494c067" title="filter the input image with a Gaussian blocking filter.">spatial_frequency_filter</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l01498"></a>01498                          <span class="keyword">const</span> <span class="keywordtype">float</span> dir_fx, <span class="keyword">const</span> <span class="keywordtype">float</span> dir_fy,
<a name="l01499"></a>01499                          <span class="keyword">const</span> <span class="keywordtype">float</span> f0, <span class="keyword">const</span> <span class="keywordtype">float</span> radius,
<a name="l01500"></a>01500                          <span class="keyword">const</span> <span class="keywordtype">bool</span> output_fourier_mag,
<a name="l01501"></a>01501                          vil1_memory_image_of&lt;float&gt; &amp; output)
<a name="l01502"></a>01502 {
<a name="l01503"></a>01503   <span class="comment">//Compute the fourier transform of the image.</span>
<a name="l01504"></a>01504   vil1_memory_image_of&lt;float&gt; pow_two, mag, bmag, phase, pow_two_filt;
<a name="l01505"></a>01505   <a class="code" href="classbrip__vil1__float__ops.html#a50b5aea2998a8dc5ef3d2249f0c34b35" title="resize to closest power of two larger dimensions than the input.">brip_vil1_float_ops::resize_to_power_of_two</a>(input, pow_two);
<a name="l01506"></a>01506   <span class="keyword">const</span> <span class="keywordtype">int</span> Nfx = pow_two.width(), Nfy = pow_two.height();
<a name="l01507"></a>01507 
<a name="l01508"></a>01508   <span class="keywordflow">if</span> (!<a class="code" href="classbrip__vil1__float__ops.html#abe98c2ba039e15c2441cc5e7c2821faf" title="compute the Fourier transform using the vnl FFT algorithm.">brip_vil1_float_ops::fourier_transform</a>(pow_two, mag, phase))
<a name="l01509"></a>01509     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01510"></a>01510   bmag.resize(Nfx, Nfy);
<a name="l01511"></a>01511 
<a name="l01512"></a>01512   <span class="comment">//filter the magnitude function</span>
<a name="l01513"></a>01513   <span class="keywordtype">float</span> Ofx = Nfx*0.5f, Ofy = Nfy*0.5f;
<a name="l01514"></a>01514   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> fy =0; fy&lt;Nfy; fy++)
<a name="l01515"></a>01515     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> fx =0; fx&lt;Nfx; fx++)
<a name="l01516"></a>01516     {
<a name="l01517"></a>01517       <span class="keywordtype">float</span> gb = <a class="code" href="classbrip__vil1__float__ops.html#ae824911c3feeafa60379bebc0b47af1a" title="Blocking filter function.">gaussian_blocking_filter</a>(dir_fx, dir_fy, f0,
<a name="l01518"></a>01518                                           radius,
<a name="l01519"></a>01519                                           fx-Ofx, fy-Ofy);
<a name="l01520"></a>01520       bmag(fx,fy) = mag(fx,fy)*gb;
<a name="l01521"></a>01521     }
<a name="l01522"></a>01522   <span class="keywordflow">if</span> (output_fourier_mag)
<a name="l01523"></a>01523   {
<a name="l01524"></a>01524     output = bmag;
<a name="l01525"></a>01525     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01526"></a>01526   }
<a name="l01527"></a>01527   <span class="comment">//Transform back</span>
<a name="l01528"></a>01528   pow_two_filt.resize(Nfx, Nfy);
<a name="l01529"></a>01529   <a class="code" href="classbrip__vil1__float__ops.html#a1673f7dfd2c4acdd9b5646e63dbd9bcf" title="compute the inverse Fourier transform using the vnl FFT algorithm.">brip_vil1_float_ops::inverse_fourier_transform</a>(bmag, phase, pow_two_filt);
<a name="l01530"></a>01530 
<a name="l01531"></a>01531   <span class="comment">//Resize to original input size</span>
<a name="l01532"></a>01532   <a class="code" href="classbrip__vil1__float__ops.html#a19a1aa39eb7bf6cc1e6010121e0638dc" title="resize to specified dimensions, fill with zeros if output is larger.">brip_vil1_float_ops::resize</a>(pow_two_filt, input.width(), input.height(), output);
<a name="l01533"></a>01533   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01534"></a>01534 }
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 <span class="comment">//----------------------------------------------------------------------</span>
<a name="l01537"></a>01537 <span class="comment">//: Bi-linear interpolation on the neighborhood below.</span>
<a name="l01538"></a>01538 <span class="comment">//      xr</span>
<a name="l01539"></a>01539 <span class="comment">//   yr 0  x</span>
<a name="l01540"></a>01540 <span class="comment">//      x  x</span>
<a name="l01541"></a>01541 <span class="comment">//</span>
<a name="l01542"></a><a class="code" href="classbrip__vil1__float__ops.html#a4d992743001e0d246f66a812a79bad62">01542</a> <span class="keywordtype">float</span> <a class="code" href="classbrip__vil1__float__ops.html#a4d992743001e0d246f66a812a79bad62" title="2x2 bilinear interpolation of image at specified location.">brip_vil1_float_ops::</a>
<a name="l01543"></a>01543 <a class="code" href="classbrip__vil1__float__ops.html#a4d992743001e0d246f66a812a79bad62" title="2x2 bilinear interpolation of image at specified location.">bilinear_interpolation</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l01544"></a>01544                        <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)
<a name="l01545"></a>01545 {
<a name="l01546"></a>01546   <span class="comment">//check bounds</span>
<a name="l01547"></a>01547   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l01548"></a>01548   <span class="comment">//the pixel containing the interpolated point</span>
<a name="l01549"></a>01549   <span class="keywordtype">int</span> xr = (int)x, yr = (<span class="keywordtype">int</span>)y;
<a name="l01550"></a>01550   <span class="keywordtype">double</span> fx = x-xr, fy = y-yr;
<a name="l01551"></a>01551   <span class="keywordflow">if</span> (xr&lt;0||xr&gt;w-2)
<a name="l01552"></a>01552     <span class="keywordflow">return</span> 0.f;
<a name="l01553"></a>01553   <span class="keywordflow">if</span> (yr&lt;0||yr&gt;h-2)
<a name="l01554"></a>01554     <span class="keywordflow">return</span> 0.f;
<a name="l01555"></a>01555   <span class="keywordtype">double</span> int00 = input(xr, yr), int10 = input(xr+1,yr);
<a name="l01556"></a>01556   <span class="keywordtype">double</span> int01 = input(xr, yr+1), int11 = input(xr+1,yr+1);
<a name="l01557"></a>01557   <span class="keywordtype">double</span> int0 = int00 + fy * (int01 - int00);
<a name="l01558"></a>01558   <span class="keywordtype">double</span> int1 = int10 + fy * (int11 - int10);
<a name="l01559"></a>01559   <span class="keywordtype">float</span> val = (float) (int0 + fx * (int1 - int0));
<a name="l01560"></a>01560   <span class="keywordflow">return</span> val;
<a name="l01561"></a>01561 }
<a name="l01562"></a>01562 
<a name="l01563"></a>01563 <span class="comment">//: Transform the input to the output by a homography.</span>
<a name="l01564"></a>01564 <span class="comment">//  if the output size is fixed then only the corresponding</span>
<a name="l01565"></a><a class="code" href="classbrip__vil1__float__ops.html#ab6881089e3e1827923ed32003563f0ee">01565</a> <span class="comment">//  region of input image space is transformed.</span>
<a name="l01566"></a>01566 <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#ab6881089e3e1827923ed32003563f0ee" title="map the input to the output by a homography.">brip_vil1_float_ops::homography</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l01567"></a>01567                                      <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/classvgl__h__matrix__2d.html">vgl_h_matrix_2d&lt;double&gt;</a><span class="keyword">const</span>&amp; H,
<a name="l01568"></a>01568                                      vil1_memory_image_of&lt;float&gt;&amp; output,
<a name="l01569"></a>01569                                      <span class="keywordtype">bool</span> output_size_fixed,
<a name="l01570"></a>01570                                      <span class="keywordtype">float</span> output_fill_value)
<a name="l01571"></a>01571 {
<a name="l01572"></a>01572   <span class="keywordflow">if</span> (!input)
<a name="l01573"></a>01573     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01574"></a>01574 
<a name="l01575"></a>01575   <span class="comment">//First, there is some rather complex bookeeping to insure that</span>
<a name="l01576"></a>01576   <span class="comment">//the input and output image rois are consistent with the homography.</span>
<a name="l01577"></a>01577 
<a name="l01578"></a>01578   <span class="comment">// the bounding boxes corresponding to input and output rois</span>
<a name="l01579"></a>01579   <span class="comment">// We also construct polygons since homographies turn boxes into arbitrary</span>
<a name="l01580"></a>01580   <span class="comment">// quadrilaterals.</span>
<a name="l01581"></a>01581   <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> input_roi, output_roi;
<a name="l01582"></a>01582   <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_polygon_2d_sptr</a> input_poly, output_poly;
<a name="l01583"></a>01583   <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/classvgl__h__matrix__2d.html">vgl_h_matrix_2d&lt;double&gt;</a> Hinv;
<a name="l01584"></a>01584   <span class="comment">// set up the roi and poly for the input image</span>
<a name="l01585"></a>01585   <span class="keyword">const</span> <span class="keywordtype">int</span> win = input.width(), hin = input.height();
<a name="l01586"></a>01586   input_roi = <span class="keyword">new</span> <a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../../contrib/gel/vsol/html" href="../../../../../contrib/gel/vsol/html/classvsol__box__2d.html">vsol_box_2d</a>();
<a name="l01587"></a>01587   input_roi-&gt;add_point(0, 0);
<a name="l01588"></a>01588   input_roi-&gt;add_point(win, hin);
<a name="l01589"></a>01589   input_poly = <a class="codeRef" doxygen="contrib_brl_bbas_bsol.tag:../../../../../contrib/brl/bbas/bsol/html" href="../../../../../contrib/brl/bbas/bsol/html/classbsol__algs.html#a86bf45c002817d85e4cea675a6b631d6">bsol_algs::poly_from_box</a>(input_roi);
<a name="l01590"></a>01590   <span class="comment">//Case I</span>
<a name="l01591"></a>01591   <span class="comment">// the output image size and input transform can be adjusted</span>
<a name="l01592"></a>01592   <span class="comment">// to map the transformed image onto the full range</span>
<a name="l01593"></a>01593   <span class="keywordflow">if</span> (!output_size_fixed)
<a name="l01594"></a>01594   {
<a name="l01595"></a>01595     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="contrib_brl_bbas_bsol.tag:../../../../../contrib/brl/bbas/bsol/html" href="../../../../../contrib/brl/bbas/bsol/html/classbsol__algs.html#a45c1ae3acd32c0931018b707a5823ccf">bsol_algs::homography</a>(input_poly, H, output_poly))
<a name="l01596"></a>01596       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01597"></a>01597     <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> temp = output_poly-&gt;get_bounding_box();
<a name="l01598"></a>01598     output.resize((<span class="keywordtype">int</span>)temp-&gt;width(), (int)temp-&gt;height());
<a name="l01599"></a>01599     output.fill(output_fill_value);
<a name="l01600"></a>01600     <span class="comment">//offset the transform and transformed roi so that lower left is (0,0)</span>
<a name="l01601"></a>01601     output_roi = <span class="keyword">new</span> <a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../../contrib/gel/vsol/html" href="../../../../../contrib/gel/vsol/html/classvsol__box__2d.html">vsol_box_2d</a>();
<a name="l01602"></a>01602     output_roi-&gt;add_point(0, 0);
<a name="l01603"></a>01603     output_roi-&gt;add_point(temp-&gt;width(), temp-&gt;height());
<a name="l01604"></a>01604     vnl_matrix_fixed&lt;double,3, 3&gt; Mt = H.<a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/classvgl__h__matrix__2d.html#a933552b4244b0c82adbe4fc498ea8690">get_matrix</a>();
<a name="l01605"></a>01605     Mt[0][2] -= temp-&gt;get_min_x();  Mt[1][2] -= temp-&gt;get_min_y();
<a name="l01606"></a>01606     vnl_matrix_fixed&lt;double,3, 3&gt; Mtinv = <a class="codeRef" doxygen="core_vnl.tag:../../../../../core/vnl/html" href="../../../../../core/vnl/html/vnl__inverse_8h.html#ae861a19f1bfc63caa92078aa251900ac">vnl_inverse</a>(Mt);
<a name="l01607"></a>01607     Hinv = <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/classvgl__h__matrix__2d.html">vgl_h_matrix_2d&lt;double&gt;</a> (Mtinv);
<a name="l01608"></a>01608   }
<a name="l01609"></a>01609   <span class="keywordflow">else</span> <span class="comment">// Case II, the output image size is fixed so we have to find the</span>
<a name="l01610"></a>01610   {  <span class="comment">// inverse mapping of the output roi and intersect with the input roi</span>
<a name="l01611"></a>01611     <span class="comment">//  to determine the domain of the mapping</span>
<a name="l01612"></a>01612     <span class="keywordflow">if</span> (!output)
<a name="l01613"></a>01613       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01614"></a>01614     <span class="comment">//The output roi and poly</span>
<a name="l01615"></a>01615     <span class="keywordtype">int</span> wout = output.width(), hout = output.height();
<a name="l01616"></a>01616     output.fill(output_fill_value);
<a name="l01617"></a>01617     output_roi = <span class="keyword">new</span> <a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../../contrib/gel/vsol/html" href="../../../../../contrib/gel/vsol/html/classvsol__box__2d.html">vsol_box_2d</a>();
<a name="l01618"></a>01618     output_roi-&gt;add_point(0, 0);
<a name="l01619"></a>01619     output_roi-&gt;add_point(wout, hout);
<a name="l01620"></a>01620     output_poly = <a class="codeRef" doxygen="contrib_brl_bbas_bsol.tag:../../../../../contrib/brl/bbas/bsol/html" href="../../../../../contrib/brl/bbas/bsol/html/classbsol__algs.html#a86bf45c002817d85e4cea675a6b631d6">bsol_algs::poly_from_box</a>(output_roi);
<a name="l01621"></a>01621 
<a name="l01622"></a>01622     <span class="comment">//Construct the reverse mapping of the output bounds</span>
<a name="l01623"></a>01623     <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_polygon_2d_sptr</a> tpoly;
<a name="l01624"></a>01624     Hinv = H.<a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/classvgl__h__matrix__2d.html#a54ecf67a21fc3a3dc03d4760c8958ded">get_inverse</a>();
<a name="l01625"></a>01625     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="contrib_brl_bbas_bsol.tag:../../../../../contrib/brl/bbas/bsol/html" href="../../../../../contrib/brl/bbas/bsol/html/classbsol__algs.html#a45c1ae3acd32c0931018b707a5823ccf">bsol_algs::homography</a>(output_poly, Hinv, tpoly))
<a name="l01626"></a>01626       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01627"></a>01627 
<a name="l01628"></a>01628     <span class="comment">//form the roi corresponding to the inverse mapped output bounds</span>
<a name="l01629"></a>01629     <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> tbox = tpoly-&gt;get_bounding_box();
<a name="l01630"></a>01630 
<a name="l01631"></a>01631     <span class="comment">//intersect with the input image bounds to get the input roi</span>
<a name="l01632"></a>01632     <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> temp;
<a name="l01633"></a>01633     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="contrib_brl_bbas_bsol.tag:../../../../../contrib/brl/bbas/bsol/html" href="../../../../../contrib/brl/bbas/bsol/html/classbsol__algs.html#a0c7179ce4d78cbf73a99a29e173c5beb">bsol_algs::intersection</a>(tbox, input_roi, temp))
<a name="l01634"></a>01634       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01635"></a>01635     input_roi = temp;
<a name="l01636"></a>01636   }
<a name="l01637"></a>01637   <span class="comment">//At this point we have the correct bounds for the input and</span>
<a name="l01638"></a>01638   <span class="comment">//the output image</span>
<a name="l01639"></a>01639 
<a name="l01640"></a>01640   <span class="comment">//Iterate over the output image space and map the location of each</span>
<a name="l01641"></a>01641   <span class="comment">//pixel into the input image space. Then carry out interpolation to</span>
<a name="l01642"></a>01642   <span class="comment">//get the value of each output pixel</span>
<a name="l01643"></a>01643 
<a name="l01644"></a>01644   <span class="comment">// Dimensions of the input image</span>
<a name="l01645"></a>01645   <span class="keywordtype">int</span> ailow  = int(input_roi-&gt;get_min_x()+0.9999f); <span class="comment">// round up to nearest int</span>
<a name="l01646"></a>01646   <span class="keywordtype">int</span> aihigh = int(input_roi-&gt;get_max_x());      <span class="comment">// round down to nearest int</span>
<a name="l01647"></a>01647   <span class="keywordtype">int</span> ajlow  = int(input_roi-&gt;get_min_y()+0.9999f);
<a name="l01648"></a>01648   <span class="keywordtype">int</span> ajhigh = int(input_roi-&gt;get_max_y());
<a name="l01649"></a>01649 
<a name="l01650"></a>01650   <span class="comment">// Dimensions of the output image</span>
<a name="l01651"></a>01651   <span class="keywordtype">int</span> bilow  = int(output_roi-&gt;get_min_x()+0.9999f);
<a name="l01652"></a>01652   <span class="keywordtype">int</span> bihigh = int(output_roi-&gt;get_max_x());
<a name="l01653"></a>01653   <span class="keywordtype">int</span> bjlow  = int(output_roi-&gt;get_min_y()+0.9999f);
<a name="l01654"></a>01654   <span class="keywordtype">int</span> bjhigh = int(output_roi-&gt;get_max_y());
<a name="l01655"></a>01655 
<a name="l01656"></a>01656   <span class="comment">/* The inverse transform is used to map backwards from the output */</span>
<a name="l01657"></a>01657   <span class="keyword">const</span> vnl_matrix_fixed&lt;double,3,3&gt;&amp; Minv = Hinv.<a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/classvgl__h__matrix__2d.html#a933552b4244b0c82adbe4fc498ea8690">get_matrix</a>();
<a name="l01658"></a>01658 
<a name="l01659"></a>01659   <span class="comment">/* Now use Hinv to transform the image */</span>
<a name="l01660"></a>01660   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = bilow; i&lt;bihigh; i++)
<a name="l01661"></a>01661     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = bjlow; j&lt;bjhigh; j++)
<a name="l01662"></a>01662     {
<a name="l01663"></a>01663       <span class="comment">/* Transform the pixel */</span>
<a name="l01664"></a>01664       <span class="keywordtype">float</span> val;
<a name="l01665"></a>01665       <span class="keywordtype">double</span> u = Minv[0][0] * i + Minv[0][1] * j + Minv[0][2];
<a name="l01666"></a>01666       <span class="keywordtype">double</span> <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/vgl__vector__2d_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a> = Minv[1][0] * i + Minv[1][1] * j + Minv[1][2];
<a name="l01667"></a>01667       <span class="keywordtype">double</span> w = Minv[2][0] * i + Minv[2][1] * j + Minv[2][2];
<a name="l01668"></a>01668       u /= w;
<a name="l01669"></a>01669       v /= w;
<a name="l01670"></a>01670 
<a name="l01671"></a>01671       <span class="comment">/* Now do linear interpolation */</span>
<a name="l01672"></a>01672       {
<a name="l01673"></a>01673         <span class="keywordtype">int</span> iu = (int) u;
<a name="l01674"></a>01674         <span class="keywordtype">int</span> iv = (int) v;
<a name="l01675"></a>01675         <span class="keywordtype">double</span> fu = u - iu;
<a name="l01676"></a>01676         <span class="keywordtype">double</span> fv = v - iv;
<a name="l01677"></a>01677 
<a name="l01678"></a>01678         <span class="keywordflow">if</span> ((iu &lt; ailow || iu &gt;= aihigh-1) ||
<a name="l01679"></a>01679             (iv &lt; ajlow || iv &gt;= ajhigh-1))
<a name="l01680"></a>01680           <span class="keywordflow">continue</span>;
<a name="l01681"></a>01681         <span class="keywordflow">else</span>
<a name="l01682"></a>01682         {
<a name="l01683"></a>01683           <span class="comment">/* Get the neighbouring pixels */</span>
<a name="l01684"></a>01684           <span class="comment">/*      (u  v)    (u+1  v)     */</span>
<a name="l01685"></a>01685           <span class="comment">/*      (u v+1)   (u+1 v+1)    */</span>
<a name="l01686"></a>01686           <span class="comment">/*                             */</span>
<a name="l01687"></a>01687           <span class="keywordtype">double</span> v00 = input(iu, iv);
<a name="l01688"></a>01688           <span class="keywordtype">double</span> v01 = input(iu, iv+1);
<a name="l01689"></a>01689           <span class="keywordtype">double</span> v10 = input(iu+1,iv);
<a name="l01690"></a>01690           <span class="keywordtype">double</span> v11 = input(iu+1, iv+1);
<a name="l01691"></a>01691 
<a name="l01692"></a>01692           <span class="keywordtype">double</span> v0 = v00 + fv * (v01 - v00);
<a name="l01693"></a>01693           <span class="keywordtype">double</span> v1 = v10 + fv * (v11 - v10);
<a name="l01694"></a>01694           val = (float) (v0 + fu * (v1 - v0));
<a name="l01695"></a>01695         }
<a name="l01696"></a>01696         <span class="comment">/* Set the value */</span>
<a name="l01697"></a>01697         output(i,j) = val;
<a name="l01698"></a>01698       }
<a name="l01699"></a>01699     }
<a name="l01700"></a>01700   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01701"></a>01701 }
<a name="l01702"></a>01702 
<a name="l01703"></a>01703 <span class="comment">//: rotate the input image counter-clockwise about the image origin.</span>
<a name="l01704"></a>01704 <span class="comment">// demonstrates the use of image homography</span>
<a name="l01705"></a><a class="code" href="classbrip__vil1__float__ops.html#ab40f2f48d8a2d67d9d7b6d2a02fde58d">01705</a> vil1_memory_image_of&lt;float&gt;
<a name="l01706"></a>01706 <a class="code" href="classbrip__vil1__float__ops.html#ab40f2f48d8a2d67d9d7b6d2a02fde58d" title="rotate the input image counter-clockwise about the image origin.">brip_vil1_float_ops::rotate</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l01707"></a>01707                             <span class="keyword">const</span> <span class="keywordtype">double</span> theta_deg)
<a name="l01708"></a>01708 {
<a name="l01709"></a>01709   vil1_memory_image_of&lt;float&gt; out;
<a name="l01710"></a>01710   <span class="keywordflow">if</span> (!input)
<a name="l01711"></a>01711     <span class="keywordflow">return</span> out;
<a name="l01712"></a>01712   <span class="keywordtype">double</span> ang = theta_deg;
<a name="l01713"></a>01713   <span class="comment">//map theta_deg to [0 360]</span>
<a name="l01714"></a>01714   <span class="keywordflow">while</span> (ang&gt;360)
<a name="l01715"></a>01715     ang-=360;
<a name="l01716"></a>01716   <span class="keywordflow">while</span> (ang&lt;0)
<a name="l01717"></a>01717     ang+=360;
<a name="l01718"></a>01718   <span class="comment">//convert to radians</span>
<a name="l01719"></a>01719   <span class="keywordtype">double</span> deg_to_rad = vnl_math::pi_over_180;
<a name="l01720"></a>01720   <span class="keywordtype">double</span> rang = deg_to_rad*ang;
<a name="l01721"></a>01721   <span class="keywordtype">double</span> c = vcl_cos(rang), s = vcl_sin(rang);
<a name="l01722"></a>01722   vnl_matrix_fixed&lt;double,3, 3&gt; M;
<a name="l01723"></a>01723   <span class="comment">//counter clockwise rotation about the image origin (0, 0)</span>
<a name="l01724"></a>01724   M[0][0]= c;   M[0][1]= -s;  M[0][2]= 0;
<a name="l01725"></a>01725   M[1][0]= s;   M[1][1]= c;   M[1][2]= 0;
<a name="l01726"></a>01726   M[2][0]= 0;   M[2][1]= 0;   M[2][2]= 1;
<a name="l01727"></a>01727   <a class="codeRef" doxygen="core_vgl.tag:../../../../../core/vgl/html" href="../../../../../core/vgl/html/classvgl__h__matrix__2d.html">vgl_h_matrix_2d&lt;double&gt;</a> H(M);
<a name="l01728"></a>01728   vil1_memory_image_of&lt;float&gt; temp;
<a name="l01729"></a>01729   <span class="comment">//The transform is adjusted to map the full input domain onto</span>
<a name="l01730"></a>01730   <span class="comment">//the output image.</span>
<a name="l01731"></a>01731   <span class="keywordflow">if</span> (!<a class="code" href="classbrip__vil1__float__ops.html#ab6881089e3e1827923ed32003563f0ee" title="map the input to the output by a homography.">brip_vil1_float_ops::homography</a>(input, H, temp))
<a name="l01732"></a>01732     <span class="keywordflow">return</span> out;
<a name="l01733"></a>01733   <span class="keywordflow">return</span> temp;
<a name="l01734"></a>01734 }
<a name="l01735"></a><a class="code" href="classbrip__vil1__float__ops.html#ab3244c3751cbf2b0ab8f20522c6fec65">01735</a> 
<a name="l01736"></a>01736 <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#ab3244c3751cbf2b0ab8f20522c6fec65">brip_vil1_float_ops::chip</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; input,
<a name="l01737"></a>01737                                <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> <span class="keyword">const</span>&amp; roi,
<a name="l01738"></a>01738                                vil1_memory_image_of&lt;float&gt;&amp; chp)
<a name="l01739"></a>01739 {
<a name="l01740"></a>01740   <span class="keywordflow">if</span> (!input||!roi)
<a name="l01741"></a>01741     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01742"></a>01742 
<a name="l01743"></a>01743   <span class="keyword">const</span> <span class="keywordtype">int</span> w = input.width(), h = input.height();
<a name="l01744"></a>01744   <span class="keywordtype">int</span> x_min = (int)roi-&gt;get_min_x(), y_min = (int)roi-&gt;get_min_y();
<a name="l01745"></a>01745   <span class="keywordtype">int</span> x_max = (int)roi-&gt;get_max_x(), y_max = (int)roi-&gt;get_max_y();
<a name="l01746"></a>01746   <span class="keywordflow">if</span> (x_min&lt;0)
<a name="l01747"></a>01747     x_min = 0;
<a name="l01748"></a>01748   <span class="keywordflow">if</span> (y_min&lt;0)
<a name="l01749"></a>01749     y_min = 0;
<a name="l01750"></a>01750   <span class="keywordflow">if</span> (x_max&gt;w-1)
<a name="l01751"></a>01751     x_max=w-1;
<a name="l01752"></a>01752   <span class="keywordflow">if</span> (y_max&gt;h-1)
<a name="l01753"></a>01753     y_max=w-1;
<a name="l01754"></a>01754   <span class="keywordtype">int</span> rw = x_max-x_min, rh = y_max-y_min;
<a name="l01755"></a>01755   <span class="keywordflow">if</span> (rw&lt;=0||rh&lt;=0)
<a name="l01756"></a>01756     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01757"></a>01757   chp.resize(rw, rh);
<a name="l01758"></a>01758   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = y_min; y&lt;y_max; y++)
<a name="l01759"></a>01759     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x =x_min; x&lt;x_max; x++)
<a name="l01760"></a>01760       chp(x-x_min, y-y_min) = input(x, y);
<a name="l01761"></a>01761   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01762"></a>01762 }
<a name="l01763"></a>01763 
<a name="l01764"></a><a class="code" href="classbrip__vil1__float__ops.html#afb1b88e37773e9615b36b34add5aadc3">01764</a> <span class="comment">//: Chipping for a general image type</span>
<a name="l01765"></a>01765 <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#ab3244c3751cbf2b0ab8f20522c6fec65">brip_vil1_float_ops::chip</a>(vil1_image <span class="keyword">const</span> &amp; input,
<a name="l01766"></a>01766                                <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">brip_roi_sptr</a> <span class="keyword">const</span>&amp; roi,
<a name="l01767"></a>01767                                vil1_image&amp; chip)
<a name="l01768"></a>01768 {
<a name="l01769"></a>01769   <span class="keywordflow">if</span> (!input||!roi)
<a name="l01770"></a>01770     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01771"></a>01771   <span class="keyword">const</span> <span class="keywordtype">int</span> Nc = input.width(), Nr = input.height();
<a name="l01772"></a>01772   <span class="keywordtype">int</span> c_min = roi-&gt;cmin(0), r_min = roi-&gt;rmin(0);
<a name="l01773"></a>01773   <span class="keywordtype">int</span> c_max = roi-&gt;cmax(0), r_max = roi-&gt;rmax(0);
<a name="l01774"></a>01774   <span class="keywordflow">if</span> (c_min&lt;0)
<a name="l01775"></a>01775     c_min = 0;
<a name="l01776"></a>01776   <span class="keywordflow">if</span> (r_min&lt;0)
<a name="l01777"></a>01777     r_min = 0;
<a name="l01778"></a>01778   <span class="keywordflow">if</span> (c_max&gt;Nc-1)
<a name="l01779"></a>01779     c_max=Nc-1;
<a name="l01780"></a>01780   <span class="keywordflow">if</span> (r_max&gt;Nr-1)
<a name="l01781"></a>01781     r_max=Nc-1;
<a name="l01782"></a>01782   <span class="keywordtype">int</span> CNc = c_max-c_min, CNr = r_max-r_min;
<a name="l01783"></a>01783   <span class="keywordflow">if</span> (CNc&lt;=0||CNr&lt;=0)
<a name="l01784"></a>01784     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01785"></a>01785 
<a name="l01786"></a>01786   <span class="keywordflow">if</span> (input.components()==3)
<a name="l01787"></a>01787   {
<a name="l01788"></a>01788     vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; timage(input);
<a name="l01789"></a>01789     vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; tchip(CNc, CNr);
<a name="l01790"></a>01790     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = r_min; r&lt;r_max; r++)
<a name="l01791"></a>01791       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c =c_min; c&lt;c_max; c++)
<a name="l01792"></a>01792         tchip(c-c_min, r-r_min) = timage(c, r);
<a name="l01793"></a>01793     chip = tchip;
<a name="l01794"></a>01794     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01795"></a>01795   }
<a name="l01796"></a>01796 
<a name="l01797"></a>01797   <span class="keywordflow">if</span> (input.component_format()==VIL1_COMPONENT_FORMAT_IEEE_FLOAT)
<a name="l01798"></a>01798   {
<a name="l01799"></a>01799     vil1_memory_image_of&lt;float&gt; timage(input);
<a name="l01800"></a>01800     vil1_memory_image_of&lt;float&gt; tchip(CNc, CNr);
<a name="l01801"></a>01801     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = r_min; r&lt;r_max; r++)
<a name="l01802"></a>01802       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c =c_min; c&lt;c_max; c++)
<a name="l01803"></a>01803         tchip(c-c_min, r-r_min) = timage(c, r);
<a name="l01804"></a>01804     chip = tchip;
<a name="l01805"></a>01805     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01806"></a>01806   }
<a name="l01807"></a>01807 
<a name="l01808"></a>01808   <span class="keywordflow">if</span> (input.get_size_bytes() ==2)
<a name="l01809"></a>01809   {
<a name="l01810"></a>01810     vil1_memory_image_of&lt;unsigned short&gt; timage(input);
<a name="l01811"></a>01811     vil1_memory_image_of&lt;unsigned short&gt; tchip(CNc, CNr);
<a name="l01812"></a>01812     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = r_min; r&lt;r_max; r++)
<a name="l01813"></a>01813       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c =c_min; c&lt;c_max; c++)
<a name="l01814"></a>01814         tchip(c-c_min, r-r_min) = timage(c, r);
<a name="l01815"></a>01815     chip = tchip;
<a name="l01816"></a>01816     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01817"></a>01817   }
<a name="l01818"></a>01818   <span class="comment">//BAD but for now force to byte output regardless FIX FIX FIX!</span>
<a name="l01819"></a>01819   <span class="comment">//if (input.get_size_bytes() ==1)</span>
<a name="l01820"></a>01820   <span class="keywordflow">if</span> (<span class="keyword">true</span>)
<a name="l01821"></a>01821   {
<a name="l01822"></a>01822     vil1_memory_image_of&lt;unsigned char&gt; timage(input);
<a name="l01823"></a>01823     vil1_memory_image_of&lt;unsigned char&gt; tchip(CNc, CNr);
<a name="l01824"></a>01824     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = r_min; r&lt;r_max; r++)
<a name="l01825"></a>01825       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c =c_min; c&lt;c_max; c++)
<a name="l01826"></a>01826         tchip(c-c_min, r-r_min) = timage(c, r);
<a name="l01827"></a>01827     chip = tchip;
<a name="l01828"></a>01828     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01829"></a>01829   }
<a name="l01830"></a>01830 
<a name="l01831"></a>01831   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01832"></a>01832 }
<a name="l01833"></a>01833 
<a name="l01834"></a>01834 <span class="comment">//:assumes that the chip and image have the same pixel types.  Only works for</span>
<a name="l01835"></a><a class="code" href="classbrip__vil1__float__ops.html#a0c9e8e7e162c52587945791339fbb377">01835</a> <span class="comment">// color at present.</span>
<a name="l01836"></a>01836 vil1_image <a class="code" href="classbrip__vil1__float__ops.html#a0c9e8e7e162c52587945791339fbb377" title="assumes that the chip and image have the same pixel types. Only works for.">brip_vil1_float_ops::insert_chip_in_image</a>(vil1_image <span class="keyword">const</span> &amp; image,
<a name="l01837"></a>01837                                                      vil1_image <span class="keyword">const</span> &amp; chip,
<a name="l01838"></a>01838                                                      <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__smart__ptr.html">brip_roi_sptr</a> <span class="keyword">const</span>&amp; roi)
<a name="l01839"></a>01839 {
<a name="l01840"></a>01840   <span class="keywordflow">if</span> (!chip||!roi)
<a name="l01841"></a>01841     <span class="keywordflow">return</span> image;
<a name="l01842"></a>01842   <span class="comment">//copy the input</span>
<a name="l01843"></a>01843   vil1_image temp(image);
<a name="l01844"></a>01844   <span class="keyword">const</span> <span class="keywordtype">int</span> chip_cols = chip.width(), chip_rows = chip.height();
<a name="l01845"></a>01845   <span class="comment">//need to do cases</span>
<a name="l01846"></a>01846   <span class="comment">//but just color now</span>
<a name="l01847"></a>01847   <span class="keywordflow">if</span> (image.components()==3)
<a name="l01848"></a>01848   {
<a name="l01849"></a>01849     vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; timage(image);
<a name="l01850"></a>01850     vil1_memory_image_of&lt;vil1_rgb&lt;unsigned char&gt; &gt; tchip(chip);
<a name="l01851"></a>01851     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cr = 0; cr&lt;chip_rows; cr++)
<a name="l01852"></a>01852       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cc = 0; cc&lt;chip_cols; cc++)
<a name="l01853"></a>01853       {
<a name="l01854"></a>01854         <span class="keywordtype">int</span> imgc = roi-&gt;ic(cc), imgr = roi-&gt;ir(cr);
<a name="l01855"></a>01855         timage(imgc, imgr) = tchip(cc, cr);
<a name="l01856"></a>01856       }
<a name="l01857"></a>01857   <span class="keywordflow">return</span> timage;
<a name="l01858"></a>01858   }
<a name="l01859"></a>01859   <span class="keywordflow">return</span> image;<span class="comment">//no op</span>
<a name="l01860"></a>01860 }
<a name="l01861"></a>01861 
<a name="l01862"></a>01862 <span class="comment">//:compute normalized cross correlation from the intensity moment sums.</span>
<a name="l01863"></a>01863 <span class="keyword">static</span> <span class="keywordtype">float</span> cross_corr(<span class="keyword">const</span> <span class="keywordtype">double</span> area, <span class="keyword">const</span> <span class="keywordtype">double</span> si1, <span class="keyword">const</span> <span class="keywordtype">double</span> si2,
<a name="l01864"></a>01864                         <span class="keyword">const</span> <span class="keywordtype">double</span> si1i1,
<a name="l01865"></a>01865                         <span class="keyword">const</span> <span class="keywordtype">double</span> si2i2, <span class="keyword">const</span> <span class="keywordtype">double</span> si1i2,
<a name="l01866"></a>01866                         <span class="keyword">const</span> <span class="keywordtype">float</span> intensity_thresh)
<a name="l01867"></a>01867 {
<a name="l01868"></a>01868   <span class="keywordflow">if</span> (!area)
<a name="l01869"></a>01869     <span class="keywordflow">return</span> 0.f;
<a name="l01870"></a>01870   <span class="comment">//the mean values</span>
<a name="l01871"></a>01871   <span class="keywordtype">double</span> u1 = si1/area, u2 = si2/area;
<a name="l01872"></a>01872   <span class="keywordflow">if</span> (u1&lt;intensity_thresh||u2&lt;intensity_thresh)
<a name="l01873"></a>01873     <span class="keywordflow">return</span> -1.f;
<a name="l01874"></a>01874   <span class="keywordtype">double</span> neu = si1i2 - area*u1*u2;
<a name="l01875"></a>01875   <span class="keywordtype">double</span> sd1 = vcl_sqrt(si1i1-area*u1*u1), sd2 = vcl_sqrt(si2i2-area*u2*u2);
<a name="l01876"></a>01876   <span class="keywordflow">if</span> (!neu)
<a name="l01877"></a>01877     <span class="keywordflow">return</span> 0.f;
<a name="l01878"></a>01878   <span class="keywordflow">if</span> (!sd1||!sd2) {
<a name="l01879"></a>01879     <span class="keywordflow">if</span> (neu&gt;0)
<a name="l01880"></a>01880       <span class="keywordflow">return</span> 1.f;
<a name="l01881"></a>01881     <span class="keywordflow">else</span>
<a name="l01882"></a>01882       <span class="keywordflow">return</span> -1.f;
<a name="l01883"></a>01883   }
<a name="l01884"></a>01884   <span class="keywordtype">double</span> den = sd1*sd2;
<a name="l01885"></a>01885   <span class="keywordflow">return</span> float(neu/den);
<a name="l01886"></a>01886 }
<a name="l01887"></a>01887 
<a name="l01888"></a>01888 <span class="comment">//:perform normalized cross-correlation at a sub-pixel location</span>
<a name="l01889"></a>01889 <span class="comment">// thus all the pixel values are interpolated.</span>
<a name="l01890"></a><a class="code" href="classbrip__vil1__float__ops.html#a9cc711a4482a50c4eadb5043df1d8c94">01890</a> <span class="keywordtype">float</span> <a class="code" href="classbrip__vil1__float__ops.html#a9cc711a4482a50c4eadb5043df1d8c94" title="cross-correlate two images at a given sub-pixel location.">brip_vil1_float_ops::</a>
<a name="l01891"></a>01891 <a class="code" href="classbrip__vil1__float__ops.html#a9cc711a4482a50c4eadb5043df1d8c94" title="cross-correlate two images at a given sub-pixel location.">cross_correlate</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image1,
<a name="l01892"></a>01892                 vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image2,
<a name="l01893"></a>01893                 <span class="keyword">const</span> <span class="keywordtype">float</span> x, <span class="keyword">const</span> <span class="keywordtype">float</span> y,
<a name="l01894"></a>01894                 <span class="keyword">const</span> <span class="keywordtype">int</span> radius,
<a name="l01895"></a>01895                 <span class="keyword">const</span> <span class="keywordtype">float</span> intensity_thresh)
<a name="l01896"></a>01896 {
<a name="l01897"></a>01897   <span class="keyword">const</span> <span class="keywordtype">int</span> w1 = image1.width(), h1 = image1.height();
<a name="l01898"></a>01898   <span class="keyword">const</span> <span class="keywordtype">int</span> w2 = image1.width(), h2 = image1.height();
<a name="l01899"></a>01899   <span class="comment">//bounds checks</span>
<a name="l01900"></a>01900   <span class="keywordflow">if</span> (w1!=w2||h1!=h2)
<a name="l01901"></a>01901     <span class="keywordflow">return</span> -1;
<a name="l01902"></a>01902   <span class="keywordflow">if</span> (x&lt;radius||x&gt;w1-radius-1||y&lt;radius||y&gt;h1-radius-1)
<a name="l01903"></a>01903     <span class="keywordflow">return</span> -1;
<a name="l01904"></a>01904 
<a name="l01905"></a>01905   <span class="comment">//accumulate correlation sums,</span>
<a name="l01906"></a>01906   <span class="comment">//bi-linear interpolate the values</span>
<a name="l01907"></a>01907   <span class="keywordtype">double</span> sI1=0, sI2=0, sI1I1=0, sI2I2=0, sI1I2=0;
<a name="l01908"></a>01908   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y0 = -10*radius; y0&lt;=10*radius; ++y0)
<a name="l01909"></a>01909     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x0 = -10*radius; x0&lt;=10*radius; ++x0)
<a name="l01910"></a>01910     {
<a name="l01911"></a>01911       <span class="keywordtype">float</span> xp = x+0.1f*x0, yp = y+0.1f*y0;
<a name="l01912"></a>01912       <span class="keywordtype">double</span> v1 = <a class="code" href="classbrip__vil1__float__ops.html#a4d992743001e0d246f66a812a79bad62" title="2x2 bilinear interpolation of image at specified location.">brip_vil1_float_ops::bilinear_interpolation</a>(image1, xp, yp);
<a name="l01913"></a>01913       <span class="keywordtype">double</span> v2 = <a class="code" href="classbrip__vil1__float__ops.html#a4d992743001e0d246f66a812a79bad62" title="2x2 bilinear interpolation of image at specified location.">brip_vil1_float_ops::bilinear_interpolation</a>(image2, xp, yp);
<a name="l01914"></a>01914       sI1 += v1;
<a name="l01915"></a>01915       sI2 += v2;
<a name="l01916"></a>01916       sI1I1 += v1*v1;
<a name="l01917"></a>01917       sI2I2 += v2*v2;
<a name="l01918"></a>01918       sI1I2 += v1*v2;
<a name="l01919"></a>01919     }
<a name="l01920"></a>01920   <span class="comment">//:compute correlation.</span>
<a name="l01921"></a>01921   <span class="keywordtype">int</span> s = 2*radius+1;
<a name="l01922"></a>01922   <span class="keywordtype">double</span> area = s*s;
<a name="l01923"></a>01923   <span class="keywordflow">return</span> cross_corr(area, sI1, sI2, sI1I1, sI2I2, sI1I2, intensity_thresh);
<a name="l01924"></a>01924 }
<a name="l01925"></a>01925 
<a name="l01926"></a>01926 <span class="comment">//: r0 is the image from which to read the new intensity values</span>
<a name="l01927"></a>01927 <span class="comment">//  r is the summing array row in which the values are to be accumulated</span>
<a name="l01928"></a>01928 <span class="keyword">static</span> <span class="keywordtype">bool</span> update_row(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; image1,
<a name="l01929"></a>01929                        vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; image2,
<a name="l01930"></a>01930                        <span class="keyword">const</span> <span class="keywordtype">int</span> r0,
<a name="l01931"></a>01931                        <span class="keyword">const</span> <span class="keywordtype">int</span> r,
<a name="l01932"></a>01932                        <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI1,
<a name="l01933"></a>01933                        <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI2,
<a name="l01934"></a>01934                        <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI1I1,
<a name="l01935"></a>01935                        <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI2I2,
<a name="l01936"></a>01936                        <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI1I2)
<a name="l01937"></a>01937 {
<a name="l01938"></a>01938   <span class="keyword">const</span> <span class="keywordtype">int</span> w1 = image1.width(), h1 = image1.height();
<a name="l01939"></a>01939   <span class="keyword">const</span> <span class="keywordtype">int</span> w2 = image2.width(), h2 = image2.height();
<a name="l01940"></a>01940   <span class="keywordflow">if</span> (w1!=w2||h1!=h2||r&lt;0||r&gt;=h1)
<a name="l01941"></a>01941     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01942"></a>01942   <span class="keywordtype">double</span> i10 = image1(0,r0), i20 = image2(0,r0);
<a name="l01943"></a>01943   SI1[r][0] = i10; SI2[r][0] = i20; SI1I1[r][0]=i10*i10;
<a name="l01944"></a>01944   SI2I2[r][0]=i20*i20; SI1I2[r][0]=i10*i20;
<a name="l01945"></a>01945   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 1; c&lt;w1; c++)
<a name="l01946"></a>01946   {
<a name="l01947"></a>01947     <span class="keywordtype">double</span> i1c = image1(c,r0);
<a name="l01948"></a>01948     <span class="keywordtype">double</span> i2c = image2(c,r0);
<a name="l01949"></a>01949     SI1[r][c]    = SI1[r][c-1]+i1c;
<a name="l01950"></a>01950     SI2[r][c]    = SI2[r][c-1]+i2c;
<a name="l01951"></a>01951     SI1I1[r][c]  = SI1I1[r][c-1]+ i1c*i1c;
<a name="l01952"></a>01952     SI2I2[r][c]  = SI2I2[r][c-1]+ i2c*i2c;
<a name="l01953"></a>01953     SI1I2[r][c]  = SI1I2[r][c-1]+ i1c*i2c;
<a name="l01954"></a>01954   }
<a name="l01955"></a>01955   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01956"></a>01956 }
<a name="l01957"></a>01957 
<a name="l01958"></a>01958 <span class="keyword">static</span> <span class="keywordtype">bool</span> initialize_slice(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; image1,
<a name="l01959"></a>01959                              vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span>&amp; image2,
<a name="l01960"></a>01960                              <span class="keyword">const</span> <span class="keywordtype">int</span> radius,
<a name="l01961"></a>01961                              <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI1,
<a name="l01962"></a>01962                              <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI2,
<a name="l01963"></a>01963                              <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI1I1,
<a name="l01964"></a>01964                              <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI2I2,
<a name="l01965"></a>01965                              <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; SI1I2)
<a name="l01966"></a>01966 {
<a name="l01967"></a>01967   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;=2*radius; r++)
<a name="l01968"></a>01968     <span class="keywordflow">if</span> (!update_row(image1, image2, r, r, SI1, SI2, SI1I1, SI2I2, SI1I2))
<a name="l01969"></a>01969       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01970"></a>01970   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01971"></a>01971 }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973 <span class="keyword">static</span> <span class="keywordtype">bool</span> collapse_slice( <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a> <span class="keyword">const</span>&amp; SI1,
<a name="l01974"></a>01974                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a> <span class="keyword">const</span>&amp; SI2,
<a name="l01975"></a>01975                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a> <span class="keyword">const</span>&amp; SI1I1,
<a name="l01976"></a>01976                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a> <span class="keyword">const</span>&amp; SI2I2,
<a name="l01977"></a>01977                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a> <span class="keyword">const</span>&amp; SI1I2,
<a name="l01978"></a>01978                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI1,
<a name="l01979"></a>01979                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI2,
<a name="l01980"></a>01980                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI1I1,
<a name="l01981"></a>01981                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI2I2,
<a name="l01982"></a>01982                             <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI1I2)
<a name="l01983"></a>01983 {
<a name="l01984"></a>01984   <span class="comment">//sanity check</span>
<a name="l01985"></a>01985   <span class="keywordtype">int</span> w = SI1.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html#a5d1d6d4ecc26eff6b99e456078924be6">cols</a>(), h = SI1.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html#abe25ab10299a0b1c6a075895bfb85fe6">rows</a>();
<a name="l01986"></a>01986   <span class="keywordtype">int</span> dw = SI1.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html#a5d1d6d4ecc26eff6b99e456078924be6">cols</a>();
<a name="l01987"></a>01987   <span class="keywordflow">if</span> (dw!=w)
<a name="l01988"></a>01988     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01989"></a>01989 
<a name="l01990"></a>01990   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c&lt;w; c++)
<a name="l01991"></a>01991   {
<a name="l01992"></a>01992     dSI1[c]=0; dSI2[c]=0; dSI1I1[c]=0;
<a name="l01993"></a>01993     dSI2I2[c]=0; dSI1I2[c]=0;
<a name="l01994"></a>01994     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;h; r++)
<a name="l01995"></a>01995     {
<a name="l01996"></a>01996       dSI1[c] += SI1[r][c];
<a name="l01997"></a>01997       dSI2[c] += SI2[r][c];
<a name="l01998"></a>01998       dSI1I1[c] += SI1I1[r][c];
<a name="l01999"></a>01999       dSI2I2[c] += SI2I2[r][c];
<a name="l02000"></a>02000       dSI1I2[c] += SI1I2[r][c];
<a name="l02001"></a>02001     }
<a name="l02002"></a>02002   }
<a name="l02003"></a>02003   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02004"></a>02004 }
<a name="l02005"></a>02005 
<a name="l02006"></a>02006 <span class="keyword">static</span> <span class="keywordtype">bool</span> cross_correlate_row(<span class="keywordtype">int</span> radius,
<a name="l02007"></a>02007                                 <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI1,
<a name="l02008"></a>02008                                 <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI2,
<a name="l02009"></a>02009                                 <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI1I1,
<a name="l02010"></a>02010                                 <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI2I2,
<a name="l02011"></a>02011                                 <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a>&amp; dSI1I2,
<a name="l02012"></a>02012                                 <span class="keywordtype">float</span> intensity_thresh,
<a name="l02013"></a>02013                                 <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;float&gt;</a>&amp; cc
<a name="l02014"></a>02014                                )
<a name="l02015"></a>02015 {
<a name="l02016"></a>02016   <span class="comment">//sanity check</span>
<a name="l02017"></a>02017   <span class="keywordtype">int</span> w = dSI1.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html#ac11ed4641108cad5b64d5c6f432a421d">size</a>(), wc = cc.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html#ac11ed4641108cad5b64d5c6f432a421d">size</a>();
<a name="l02018"></a>02018   <span class="keywordflow">if</span> (!w||!wc||w!=wc)
<a name="l02019"></a>02019     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02020"></a>02020   <span class="keywordtype">int</span> s = 2*radius+1;
<a name="l02021"></a>02021   <span class="keywordtype">double</span> area = s*s;
<a name="l02022"></a>02022   <span class="comment">//the general case</span>
<a name="l02023"></a>02023   <span class="keywordtype">double</span> si1=dSI1[s-1], si2=dSI2[s-1], si1i1=dSI1I1[s-1],
<a name="l02024"></a>02024     si2i2=dSI2I2[s-1], si1i2=dSI1I2[s-1];
<a name="l02025"></a>02025   cc[radius]= cross_corr(area, si1, si2, si1i1, si2i2, si1i2, intensity_thresh);
<a name="l02026"></a>02026   <span class="comment">//the remaining columns</span>
<a name="l02027"></a>02027   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = radius+1; c+radius&lt;w; c++)
<a name="l02028"></a>02028   {
<a name="l02029"></a>02029     si1=dSI1[c+radius]-dSI1[c-radius-1];
<a name="l02030"></a>02030     si2=dSI2[c+radius]-dSI2[c-radius-1];
<a name="l02031"></a>02031     si1i1=dSI1I1[c+radius]-dSI1I1[c-radius-1];
<a name="l02032"></a>02032     si2i2=dSI2I2[c+radius]-dSI2I2[c-radius-1];
<a name="l02033"></a>02033     si1i2=dSI1I2[c+radius]-dSI1I2[c-radius-1];
<a name="l02034"></a>02034     cc[c] = cross_corr(area, si1, si2, si1i1, si2i2, si1i2, intensity_thresh);
<a name="l02035"></a>02035   }
<a name="l02036"></a>02036 
<a name="l02037"></a>02037   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02038"></a>02038 }
<a name="l02039"></a>02039 
<a name="l02040"></a>02040 <span class="keyword">static</span> <span class="keywordtype">void</span> advance_rows(<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a>&amp; S)
<a name="l02041"></a>02041 {
<a name="l02042"></a>02042   <span class="keywordtype">int</span> nr = S.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html#abe25ab10299a0b1c6a075895bfb85fe6">rows</a>(), nc = S.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html#a5d1d6d4ecc26eff6b99e456078924be6">cols</a>();
<a name="l02043"></a>02043   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r&lt;nr-1; r++)
<a name="l02044"></a>02044     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c =0; c&lt;nc; c++)
<a name="l02045"></a>02045       S[r][c]=S[r+1][c];
<a name="l02046"></a>02046 }
<a name="l02047"></a>02047 
<a name="l02048"></a>02048 
<a name="l02049"></a>02049 <span class="keyword">static</span> <span class="keywordtype">bool</span> output_cc_row(<span class="keyword">const</span> <span class="keywordtype">int</span> r0,  <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;float&gt;</a> <span class="keyword">const</span>&amp; cc,
<a name="l02050"></a>02050                           vil1_memory_image_of&lt;float&gt;&amp; out)
<a name="l02051"></a>02051 {
<a name="l02052"></a>02052   <span class="keyword">const</span> <span class="keywordtype">int</span> n = cc.<a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html#ac11ed4641108cad5b64d5c6f432a421d">size</a>(), w = out.width();
<a name="l02053"></a>02053   <span class="keywordflow">if</span> (n!=w)
<a name="l02054"></a>02054     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02055"></a>02055   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c&lt;w; c++)
<a name="l02056"></a>02056     out(c, r0) = cc[c];
<a name="l02057"></a>02057   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02058"></a>02058 }
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 
<a name="l02061"></a><a class="code" href="classbrip__vil1__float__ops.html#af41f195a94501214392872171820fdb8">02061</a> <span class="keywordtype">bool</span> <a class="code" href="classbrip__vil1__float__ops.html#a9cc711a4482a50c4eadb5043df1d8c94" title="cross-correlate two images at a given sub-pixel location.">brip_vil1_float_ops::</a>
<a name="l02062"></a>02062 <a class="code" href="classbrip__vil1__float__ops.html#a9cc711a4482a50c4eadb5043df1d8c94" title="cross-correlate two images at a given sub-pixel location.">cross_correlate</a>(vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image1,
<a name="l02063"></a>02063                 vil1_memory_image_of&lt;float&gt; <span class="keyword">const</span> &amp; image2,
<a name="l02064"></a>02064                 vil1_memory_image_of&lt;float&gt;&amp; out,
<a name="l02065"></a>02065                 <span class="keyword">const</span> <span class="keywordtype">int</span> radius,
<a name="l02066"></a>02066                 <span class="keyword">const</span> <span class="keywordtype">float</span> intensity_thresh)
<a name="l02067"></a>02067 {
<a name="l02068"></a>02068   <a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html">vul_timer</a> t;
<a name="l02069"></a>02069   <span class="keyword">const</span> <span class="keywordtype">int</span> w = image1.width(), h = image1.height();
<a name="l02070"></a>02070   <span class="keyword">const</span> <span class="keywordtype">int</span> w2 = image2.width(), h2 = image2.height();
<a name="l02071"></a>02071   <span class="comment">//sizes must match</span>
<a name="l02072"></a>02072   <span class="keywordflow">if</span> (w!=w2||h!=h2)
<a name="l02073"></a>02073   {
<a name="l02074"></a>02074     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In brip_vil1_float_ops::fast_cross_correlate(..) -&quot;</span>
<a name="l02075"></a>02075              &lt;&lt; <span class="stringliteral">&quot; image sizes don&#39;t match\n&quot;</span>;
<a name="l02076"></a>02076     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02077"></a>02077   }
<a name="l02078"></a>02078   out.resize(w, h);
<a name="l02079"></a>02079   out.fill(0.f);
<a name="l02080"></a>02080   <span class="keywordtype">int</span> s = 2*radius+1;
<a name="l02081"></a>02081   <span class="comment">//Create the running sum slices</span>
<a name="l02082"></a>02082   <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__2d.html">vbl_array_2d&lt;double&gt;</a> SI1(s,w), SI2(s,w),
<a name="l02083"></a>02083     SI1I1(s,w), SI2I2(s,w), SI1I2(s,w);
<a name="l02084"></a>02084   <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;float&gt;</a> cc(w, 0.f);
<a name="l02085"></a>02085   <a class="codeRef" doxygen="core_vbl.tag:../../../../../core/vbl/html" href="../../../../../core/vbl/html/classvbl__array__1d.html">vbl_array_1d&lt;double&gt;</a> dSI1(w, 0.0), dSI2(w, 0.0),
<a name="l02086"></a>02086     dSI1I1(w, 0.0), dSI2I2(w, 0.0), dSI1I2(w, 0.0);
<a name="l02087"></a>02087   initialize_slice(image1, image2, radius, SI1, SI2, SI1I1, SI2I2, SI1I2);
<a name="l02088"></a>02088   <span class="keywordflow">if</span> (!collapse_slice(SI1,  SI2,  SI1I1,  SI2I2,  SI1I2,
<a name="l02089"></a>02089                       dSI1, dSI2, dSI1I1, dSI2I2, dSI1I2))
<a name="l02090"></a>02090     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02091"></a>02091   <span class="keywordtype">int</span> r0 = radius;
<a name="l02092"></a>02092   <span class="keywordflow">for</span> (; r0+radius+1&lt;h; r0++)
<a name="l02093"></a>02093   {
<a name="l02094"></a>02094     <span class="keywordflow">if</span> (r0==5)
<a name="l02095"></a>02095       r0=5;
<a name="l02096"></a>02096 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l02097"></a>02097 <span class="preprocessor"></span>    vcl_cout &lt;&lt; <span class="stringliteral">&quot;r0 &quot;</span> &lt;&lt; r0 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l02098"></a>02098 <span class="preprocessor">#endif</span>
<a name="l02099"></a>02099 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!cross_correlate_row(radius, dSI1, dSI2, dSI1I1, dSI2I2, dSI1I2,
<a name="l02100"></a>02100                              intensity_thresh, cc))
<a name="l02101"></a>02101       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02102"></a>02102 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l02103"></a>02103 <span class="preprocessor"></span>    vcl_cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l02104"></a>02104 <span class="preprocessor">#endif</span>
<a name="l02105"></a>02105 <span class="preprocessor"></span>    advance_rows(SI1); advance_rows(SI2);  advance_rows(SI1I1);
<a name="l02106"></a>02106     advance_rows(SI2I2); advance_rows(SI1I2);
<a name="l02107"></a>02107     <span class="keywordflow">if</span> (!update_row(image1, image2, r0+radius+1, 2*radius,
<a name="l02108"></a>02108                     SI1, SI2, SI1I1, SI2I2, SI1I2))
<a name="l02109"></a>02109       <span class="keywordflow">return</span> out;
<a name="l02110"></a>02110     <span class="keywordflow">if</span> (!collapse_slice(SI1,  SI2,  SI1I1,  SI2I2,  SI1I2,
<a name="l02111"></a>02111                         dSI1, dSI2, dSI1I1, dSI2I2, dSI1I2))
<a name="l02112"></a>02112       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02113"></a>02113     <span class="keywordflow">if</span> (!output_cc_row(r0, cc, out))
<a name="l02114"></a>02114       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02115"></a>02115   }
<a name="l02116"></a>02116   <span class="comment">//handle the last row</span>
<a name="l02117"></a>02117 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l02118"></a>02118 <span class="preprocessor"></span>  vcl_cout &lt;&lt; <span class="stringliteral">&quot;r0 &quot;</span> &lt;&lt; r0 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l02119"></a>02119 <span class="preprocessor">#endif</span>
<a name="l02120"></a>02120 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!cross_correlate_row(radius, dSI1, dSI2, dSI1I1, dSI2I2, dSI1I2,
<a name="l02121"></a>02121                           intensity_thresh, cc))
<a name="l02122"></a>02122     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02123"></a>02123 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l02124"></a>02124 <span class="preprocessor"></span>  vcl_cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l02125"></a>02125 <span class="preprocessor">#endif</span>
<a name="l02126"></a>02126 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!output_cc_row(r0, cc, out))
<a name="l02127"></a>02127     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02128"></a>02128   vcl_cout &lt;&lt; <span class="stringliteral">&quot;RunningSumCrossCorrelation for &quot;</span> &lt;&lt; w*h/1000.0f &lt;&lt; <span class="stringliteral">&quot; k pixels in &quot;</span>
<a name="l02129"></a>02129            &lt;&lt; t.<a class="codeRef" doxygen="core_vul.tag:../../../../../core/vul/html" href="../../../../../core/vul/html/classvul__timer.html#a14c86b3c27f36c1946c184941e006370">real</a>() &lt;&lt; <span class="stringliteral">&quot; msecs\n&quot;</span>&lt;&lt; vcl_flush;
<a name="l02130"></a>02130   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02131"></a>02131 }
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 2 2013 08:53:09 for contrib/brl/bseg/brip by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
