<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>contrib/mul/mbl/mbl_stl.h File Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">contrib/mul/mbl/mbl_stl.h File Reference</div>  </div>
</div>
<div class="contents">

<p>Useful things missing from vcl_algorithm, etc.  
<a href="#details">More...</a></p>

<p><a href="mbl__stl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Cont &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mbl_stl_output_t1&lt; Cont &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="mbl__stl_8h.html#a20f3d59a5c20345b8a5f9e69f1a92226">mbl_stl_output</a> (const Cont &amp;c, const char *sep=&quot; &quot;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class IT1 , class IT2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vcl_pair&lt; IT1, IT2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="mbl__stl_8h.html#a8f7ebd32c90cb90f37290d00c01ef0b1">mbl_stl_find_common_value</a> (IT1 start1, IT1 finish1, IT2 start2, IT2 finish2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first instance of common value in two sorted sequences.  <a href="#a8f7ebd32c90cb90f37290d00c01ef0b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class IT1 , class IT2 , class CMP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vcl_pair&lt; IT1, IT2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="mbl__stl_8h.html#a521574f39d90c3aea51f6c471b83de6b">mbl_stl_find_common_value</a> (IT1 start1, IT1 finish1, IT2 start2, IT2 finish2, CMP comp=CMP())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first instance of common value in two sequences sorted by specified comparator.  <a href="#a521574f39d90c3aea51f6c471b83de6b"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Useful things missing from vcl_algorithm, etc. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>iscott </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>Dec 2001 Actually, this is mostly an opportunity to mess around in STL to produce code which would be much simpler in ordinary C++. Stroustrup assures us that this approach is faster in general - which I don't really believe.</dd></dl>
<div class="fragment"><pre class="fragment">
    Modifications
     30 April 2004 - Martin Roberts -
      Added quite a few little functors mainly to do with iterating through maps
      for example a version of the non-standard select1st and select2nd
*/
#include &lt;vcl_functional.h&gt;
#include &lt;vcl_vector.h&gt;
#include &lt;vcl_ostream.h&gt;
#include &lt;vcl_utility.h&gt;

/** Fill an output sequence with incrementing values.
   A bit like vcl_fill, but after each assignment, the value is incremented.
   \return the next value in the sequence.
*/template&lt;class Out, class T&gt;
inline T mbl_stl_increments(Out first, Out last, T init)
{
  for (; first != last; ++first, ++init) *first = init;
  return init;
}

/** Fill the first n values of an output sequence with incrementing values.
   A bit like vcl_fill_n, but after each assignment,
   the value is incremented.
   \return the next value in the sequence.
*/template&lt;class Out, class Size, class T&gt;
inline T mbl_stl_increments_n(Out first, Size n, T init)
{
  for (; 0 &lt; n; ++first, --n, ++init) *first = init;
  return init;
}

/** Produces a first order sequence from the supplied unary function.
   The value produced at a given step is a function of the previous value.
   E.g. the following is equivalent to using mbl_stl_increments
   \code
   mbl_stl_sequence(A.begin(), A.end(), vcl_bind1st(vcl_plus&lt;unsigned&gt;(), 1u), 0u);
   \endcode
   \return the next value in the sequence.
*/template&lt;class Out, class T, class UnOp&gt;
inline T mbl_stl_sequence(Out first, Out last, UnOp op, T init)
{
  for (;first != last; ++first, init = op(init)) *first = init;
  return init;
}

/** Produces a first order sequence of size n from the supplied function.
   The value produced at a given step is a function of the previous value.
   E.g. the following is equivalent to using mbl_stl_increments
   \return the next value in the sequence.
*/template&lt;class Out, class Size, class T, class UnOp&gt;
inline T mbl_stl_sequence_n(Out first, Size n, UnOp op, T init)
{
  for (; 0 &lt; n; ++first, --n, init = op(init)) *first = init;
  return init;
}

/** Clean out a range of pointers.
   NB the dereferenced iterator must be a pointer
*/template&lt;class iterType&gt;
inline void mbl_stl_clean(iterType first, iterType last)
{
  for (; first != last; ++first)
  {
    delete *first;
    *first=0;
  }
}

/** Copy elements in input range for which the supplied predicate is true.
  Note bizarely although the STL provides remove_copy if etc etc
  the simple copy_if was dropped from the C++ standard
*/template&lt;typename InputIterator,
         typename OutputIterator,
         typename Predicate&gt;
    inline  OutputIterator mbl_stl_copy_if(InputIterator begin, InputIterator end,
                                           OutputIterator destBegin,
                                           Predicate pred)
{
  while (begin != end)
  {
    if (pred(*begin))
    {
      *destBegin++ = *begin;
    }
    ++begin;
  }
  return destBegin;
}

//----------------------------------------------------------------------------------------------
//Now some map related functors
//
/** select 1st element of a pair (e.g.\ for map iterators).
  NB something like this is in the SGI extension to the STL but is not included in the standard VCL
  However this is very useful with map iterators so include it here
*/template &lt;class Pair&gt;
struct mbl_stl_select1st : public vcl_unary_function&lt;Pair, typename Pair::first_type&gt;
{
  inline typename Pair::first_type const &amp; operator()(Pair const &amp; pair) const
  {
    return pair.first;
  }
};

/** select 2nd element of a pair (e.g.\ for map iterators).
  NB something like this is in the SGI extension to the STL but is not included in the standard VCL
  However this is very useful with map iterators so include it here
*/template &lt;class Pair&gt;
struct mbl_stl_select2nd : public vcl_unary_function&lt;Pair, typename Pair::second_type&gt;
{
  inline typename Pair::second_type const &amp; operator()(Pair const &amp; pair) const
  {
    return pair.second;
  }
};

//Accumulate the second elements of a pair (e.g. for accumulating values through a map)
template &lt;class Pair&gt;
struct mbl_stl_add2nd : public vcl_binary_function&lt;typename Pair::second_type, Pair, typename Pair::second_type&gt;
{
  inline typename Pair::second_type  operator()(typename Pair::second_type partSum, Pair const &amp; x2 ) const
  {
    return partSum + x2.second;
  }
};


// End of map/pair related functors
//------------------------------------------------------------------------------------
/** Given a vector of things, select an indexed element.
  For use in eg STL transform algorithm to extract out required subset of (indexed) objects into a working vector
  e.g. given vector of indices and vector of values, copy out the required subset thus
   \code
   vcl_vector&lt;T&gt; subset
   subset.reserve(indices.size());
   vcl_transform(indices.begin(),indices.end(),
                 vcl_back_inserter(subset),
                 mbl_stl_index_functor(values));
   \endcode
*/template &lt;class T&gt;
class mbl_stl_index_functor
{
  //This functor copies out  element vec[index]
  //For use in eg STL transform algorithm to extract out required subset of (indexed) points into a working vector
  //No bounds checking is done
 private:
/**const reference to vector used to store the objects indexed.
*/  const vcl_vector&lt;T &gt;&amp; vec_;

 public:
  mbl_stl_index_functor(const vcl_vector&lt;T &gt;&amp; vec): vec_(vec) {}
  inline const T&amp; operator()(unsigned index) const { return vec_[index]; }
};


//------------------------------------------------------------------------------------
/** implementation class for use with mbl_stl_output.
*/template &lt;class Cont&gt;
class mbl_stl_output_t1
{
 public:
  const Cont &amp;c;
  const char *sep;
  mbl_stl_output_t1(const Cont&amp; c, const char * sep): c(c), sep(sep) {}
};

/** implementation function for use with mbl_stl_output.
*/template &lt;class Cont&gt; inline
vcl_ostream&amp; operator&lt;&lt;(vcl_ostream&amp; s, const mbl_stl_output_t1&lt;Cont&gt;&amp; t)
{
  if (t.c.empty()) return s;
  VCL_DISAPPEARING_TYPENAME Cont::const_iterator it=t.c.begin(), end=t.c.end();
  s &lt;&lt; *it;
  ++it;
  for (; it!=end; ++it)
    s &lt;&lt; t.sep &lt;&lt; *it;
  return s;
}

/** Allow easy stream output of STL container contents.
   \verbatim
   vcl_vector&lt;int&gt; c;
   ...
   vcl_cout &lt;&lt; "The contents of c using normal &lt;&lt; notation" &lt;&lt;
     mbl_stl_output(c) &lt;&lt; vcl_endl;
   </pre></div> 
<p>Definition in file <a class="el" href="mbl__stl_8h_source.html">mbl_stl.h</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8f7ebd32c90cb90f37290d00c01ef0b1"></a><!-- doxytag: member="mbl_stl.h::mbl_stl_find_common_value" ref="a8f7ebd32c90cb90f37290d00c01ef0b1" args="(IT1 start1, IT1 finish1, IT2 start2, IT2 finish2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IT1 , class IT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vcl_pair&lt;IT1, IT2&gt; mbl_stl_find_common_value </td>
          <td>(</td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>finish1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>finish2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find first instance of common value in two sorted sequences. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pair. Either *pair.first == *pair.second, or pair.first == finish1 &amp;&amp; pair.second == finish2 if no matches are found. </dd></dl>

<p>Definition at line <a class="el" href="mbl__stl_8h_source.html#l00212">212</a> of file <a class="el" href="mbl__stl_8h_source.html">mbl_stl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a521574f39d90c3aea51f6c471b83de6b"></a><!-- doxytag: member="mbl_stl.h::mbl_stl_find_common_value" ref="a521574f39d90c3aea51f6c471b83de6b" args="(IT1 start1, IT1 finish1, IT2 start2, IT2 finish2, CMP comp=CMP())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IT1 , class IT2 , class CMP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vcl_pair&lt;IT1, IT2&gt; mbl_stl_find_common_value </td>
          <td>(</td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>finish1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>finish2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CMP&#160;</td>
          <td class="paramname"><em>comp</em> = <code>CMP()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find first instance of common value in two sequences sorted by specified comparator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pair. Either *pair.first == *pair.second, or pair.first == finish1 &amp;&amp; pair.second == finish2 if no matches are found. </dd></dl>

<p>Definition at line <a class="el" href="mbl__stl_8h_source.html#l00233">233</a> of file <a class="el" href="mbl__stl_8h_source.html">mbl_stl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a20f3d59a5c20345b8a5f9e69f1a92226"></a><!-- doxytag: member="mbl_stl.h::mbl_stl_output" ref="a20f3d59a5c20345b8a5f9e69f1a92226" args="(const Cont &amp;c, const char *sep=&quot; &quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cont &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbl_stl_output_t1&lt;Cont&gt; mbl_stl_output </td>
          <td>(</td>
          <td class="paramtype">const Cont &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="mbl__stl_8h_source.html#l00201">201</a> of file <a class="el" href="mbl__stl_8h_source.html">mbl_stl.h</a>.</p>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:33:13 for contrib/mul/mbl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
