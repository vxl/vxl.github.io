<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>contrib/mul/mbl/mbl_stl_pred.h Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">contrib/mul/mbl/mbl_stl_pred.h</div>  </div>
</div>
<div class="contents">
<a href="mbl__stl__pred_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This is mul/mbl/mbl_stl_pred.h</span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef mbl_stl_pred_h_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#define mbl_stl_pred_h_</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="comment">//:</span>
<a name="l00005"></a>00005 <span class="comment">// \file</span>
<a name="l00006"></a>00006 <span class="comment">// \brief Useful predicate functors for use in stl find_if,partition etc.</span>
<a name="l00007"></a>00007 <span class="comment">// \author martin roberts</span>
<a name="l00008"></a>00008 <span class="comment">// \date  July 2004</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;vcl_functional.h&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;vcl_vector.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;vcl_string.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;vcl_utility.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;vcl_cmath.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__vector_8h.html">vnl/vnl_vector.h</a>&gt;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="comment">//: Return true if a string contains a substring</span>
<a name="l00019"></a>00019 <span class="comment">// Note without this you&#39;d need bind2nd mem_fun which can cause reference to reference compile errors</span>
<a name="l00020"></a><a class="code" href="classmbl__stl__pred__str__contains.html">00020</a> <span class="keyword">class </span><a class="code" href="classmbl__stl__pred__str__contains.html" title="Return true if a string contains a substring.">mbl_stl_pred_str_contains</a> : <span class="keyword">public</span> vcl_unary_function&lt;vcl_string, bool&gt;
<a name="l00021"></a>00021 {
<a name="l00022"></a>00022   <span class="comment">//: The sought substring</span>
<a name="l00023"></a><a class="code" href="classmbl__stl__pred__str__contains.html#a73e194c8d77cf11a780b9f0917aec2c2">00023</a>   <span class="keyword">const</span> vcl_string&amp; <a class="code" href="classmbl__stl__pred__str__contains.html#a73e194c8d77cf11a780b9f0917aec2c2" title="The sought substring.">substr_</a>;
<a name="l00024"></a>00024  <span class="keyword">public</span>:
<a name="l00025"></a><a class="code" href="classmbl__stl__pred__str__contains.html#a224bdcc3a0e7d6c965bb9e11e3174ab6">00025</a>   <a class="code" href="classmbl__stl__pred__str__contains.html#a224bdcc3a0e7d6c965bb9e11e3174ab6">mbl_stl_pred_str_contains</a>(<span class="keyword">const</span> vcl_string&amp; substr): <a class="code" href="classmbl__stl__pred__str__contains.html#a73e194c8d77cf11a780b9f0917aec2c2" title="The sought substring.">substr_</a>(substr){}
<a name="l00026"></a>00026 
<a name="l00027"></a><a class="code" href="classmbl__stl__pred__str__contains.html#ae8924b0e978a42c3f57245bd492a654e">00027</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classmbl__stl__pred__str__contains.html#ae8924b0e978a42c3f57245bd492a654e">operator()</a>(<span class="keyword">const</span> vcl_string&amp; str)<span class="keyword"> const</span>
<a name="l00028"></a>00028 <span class="keyword">  </span>{
<a name="l00029"></a>00029     <span class="keywordflow">return</span> ( (str.find(<a class="code" href="classmbl__stl__pred__str__contains.html#a73e194c8d77cf11a780b9f0917aec2c2" title="The sought substring.">substr_</a>) != str.npos) ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l00030"></a>00030   }
<a name="l00031"></a>00031 };
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="comment">//: Adapt a predicate over a vector to the operation specified on an index into that vector</span>
<a name="l00034"></a>00034 <span class="comment">// T is type of the vector, and Pred the boolean predicate to really be applied</span>
<a name="l00035"></a>00035 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred&gt;
<a name="l00036"></a><a class="code" href="classmbl__stl__pred__index__adapter.html">00036</a> <span class="keyword">class </span><a class="code" href="classmbl__stl__pred__index__adapter.html" title="Adapt a predicate over a vector to the operation specified on an index into that vector.">mbl_stl_pred_index_adapter</a> : <span class="keyword">public</span> vcl_unary_function&lt;unsigned, bool&gt;
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038   <span class="comment">//:const reference to vector used to store the objects indexed</span>
<a name="l00039"></a><a class="code" href="classmbl__stl__pred__index__adapter.html#a15830941a22a4bff0b42446c03e0fc45">00039</a>   <span class="keyword">const</span> vcl_vector&lt;T &gt;&amp; <a class="code" href="classmbl__stl__pred__index__adapter.html#a15830941a22a4bff0b42446c03e0fc45" title="const reference to vector used to store the objects indexed.">vec_</a>;
<a name="l00040"></a>00040   <span class="comment">//: The predicate to really be applied</span>
<a name="l00041"></a><a class="code" href="classmbl__stl__pred__index__adapter.html#a6e2b881ce622e05e40d6a785ef60d157">00041</a>   Pred <a class="code" href="classmbl__stl__pred__index__adapter.html#a6e2b881ce622e05e40d6a785ef60d157" title="The predicate to really be applied.">Op_</a>;
<a name="l00042"></a>00042  <span class="keyword">public</span>:
<a name="l00043"></a><a class="code" href="classmbl__stl__pred__index__adapter.html#a51ddc5007b16f5fa02b98ee28db97731">00043</a>   <a class="code" href="classmbl__stl__pred__index__adapter.html#a51ddc5007b16f5fa02b98ee28db97731">mbl_stl_pred_index_adapter</a>(vcl_vector&lt;T&gt; <span class="keyword">const</span>&amp; v, Pred Op):<a class="code" href="classmbl__stl__pred__index__adapter.html#a15830941a22a4bff0b42446c03e0fc45" title="const reference to vector used to store the objects indexed.">vec_</a>(v),<a class="code" href="classmbl__stl__pred__index__adapter.html#a6e2b881ce622e05e40d6a785ef60d157" title="The predicate to really be applied.">Op_</a>(Op){}
<a name="l00044"></a>00044 
<a name="l00045"></a><a class="code" href="classmbl__stl__pred__index__adapter.html#ae08380ee41a4849b71a8bc5eb0d99795">00045</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classmbl__stl__pred__index__adapter.html#ae08380ee41a4849b71a8bc5eb0d99795">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; i)<span class="keyword"> const</span>
<a name="l00046"></a>00046 <span class="keyword">  </span>{
<a name="l00047"></a>00047     <span class="keywordflow">return</span> <a class="code" href="classmbl__stl__pred__index__adapter.html#a6e2b881ce622e05e40d6a785ef60d157" title="The predicate to really be applied.">Op_</a>(<a class="code" href="classmbl__stl__pred__index__adapter.html#a15830941a22a4bff0b42446c03e0fc45" title="const reference to vector used to store the objects indexed.">vec_</a>[i]);
<a name="l00048"></a>00048   }
<a name="l00049"></a>00049 };
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred&gt;
<a name="l00052"></a><a class="code" href="classmbl__stl__pred__index__adapter__n.html">00052</a> <span class="keyword">class </span><a class="code" href="classmbl__stl__pred__index__adapter__n.html">mbl_stl_pred_index_adapter_n</a> : <span class="keyword">public</span> vcl_unary_function&lt;unsigned, bool&gt;
<a name="l00053"></a>00053 {
<a name="l00054"></a>00054   <span class="comment">//:const reference to vector used to store the objects indexed</span>
<a name="l00055"></a><a class="code" href="classmbl__stl__pred__index__adapter__n.html#aa8541fe1028c90b757ce0c573eb0ff07">00055</a>   <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;T &gt;</a>&amp; <a class="code" href="classmbl__stl__pred__index__adapter__n.html#aa8541fe1028c90b757ce0c573eb0ff07" title="const reference to vector used to store the objects indexed.">vec_</a>;
<a name="l00056"></a>00056   <span class="comment">//: The predicate to really be applied</span>
<a name="l00057"></a><a class="code" href="classmbl__stl__pred__index__adapter__n.html#a40608f1f0fef3c05173fcd614b53c466">00057</a>   Pred <a class="code" href="classmbl__stl__pred__index__adapter__n.html#a40608f1f0fef3c05173fcd614b53c466" title="The predicate to really be applied.">Op_</a>;
<a name="l00058"></a>00058  <span class="keyword">public</span>:
<a name="l00059"></a><a class="code" href="classmbl__stl__pred__index__adapter__n.html#a5531a18c72050e6461d7d57428acd6e2">00059</a>   <a class="code" href="classmbl__stl__pred__index__adapter__n.html#a5531a18c72050e6461d7d57428acd6e2">mbl_stl_pred_index_adapter_n</a>(<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;T&gt;</a> <span class="keyword">const</span>&amp; v, Pred Op):<a class="code" href="classmbl__stl__pred__index__adapter__n.html#aa8541fe1028c90b757ce0c573eb0ff07" title="const reference to vector used to store the objects indexed.">vec_</a>(v),<a class="code" href="classmbl__stl__pred__index__adapter__n.html#a40608f1f0fef3c05173fcd614b53c466" title="The predicate to really be applied.">Op_</a>(Op){}
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="classmbl__stl__pred__index__adapter__n.html#abbff1dcc7027adc3c6c751f67a048c06">00061</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classmbl__stl__pred__index__adapter__n.html#abbff1dcc7027adc3c6c751f67a048c06">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; i)<span class="keyword"> const</span>
<a name="l00062"></a>00062 <span class="keyword">  </span>{
<a name="l00063"></a>00063     <span class="keywordflow">return</span> <a class="code" href="classmbl__stl__pred__index__adapter__n.html#a40608f1f0fef3c05173fcd614b53c466" title="The predicate to really be applied.">Op_</a>(<a class="code" href="classmbl__stl__pred__index__adapter__n.html#aa8541fe1028c90b757ce0c573eb0ff07" title="const reference to vector used to store the objects indexed.">vec_</a>[i]);
<a name="l00064"></a>00064   }
<a name="l00065"></a>00065 };
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="comment">//: Helper function to create an index adapter of the appropriate type</span>
<a name="l00068"></a>00068 <span class="comment">// As this is a function not a class, it saves some template gobbledegook in the class name</span>
<a name="l00069"></a>00069 <span class="comment">// Vec is assumed vector&lt;T&gt; where T is the type associated with the constructed adapter</span>
<a name="l00070"></a>00070 <span class="comment">//However note that using this means an extra copy of the predicate functor will occur</span>
<a name="l00071"></a>00071 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred&gt;
<a name="l00072"></a><a class="code" href="mbl__stl__pred_8h.html#a6b99c12980d990f81930debfdb78dcb1">00072</a> <span class="keyword">inline</span> <a class="code" href="classmbl__stl__pred__index__adapter.html" title="Adapt a predicate over a vector to the operation specified on an index into that vector.">mbl_stl_pred_index_adapter&lt;T,Pred&gt;</a> <a class="code" href="mbl__stl__pred_8h.html#a6b99c12980d990f81930debfdb78dcb1" title="Helper function to create an index adapter of the appropriate type.">mbl_stl_pred_create_index_adapter</a>(<span class="keyword">const</span> vcl_vector&lt;T&gt;&amp; v, Pred Op)
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074   <span class="keywordflow">return</span>  <a class="code" href="classmbl__stl__pred__index__adapter.html" title="Adapt a predicate over a vector to the operation specified on an index into that vector.">mbl_stl_pred_index_adapter&lt;T,Pred&gt;</a>(v,Op);
<a name="l00075"></a>00075 };
<a name="l00076"></a>00076 <span class="comment">//: Helper function to create an index adapter of the appropriate type</span>
<a name="l00077"></a>00077 <span class="comment">// As this is a function not a class, it saves some template gobbledegook in the class name</span>
<a name="l00078"></a>00078 <span class="comment">// Vec is assumed vector&lt;T&gt; where T is the type associated with the constructed adapter</span>
<a name="l00079"></a>00079 <span class="comment">//However note that using this means an extra copy of the predicate functor will occur</span>
<a name="l00080"></a>00080 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred&gt;
<a name="l00081"></a><a class="code" href="mbl__stl__pred_8h.html#a5a8d308eba3bd5583c34d3d9c475f913">00081</a> <span class="keyword">inline</span> <a class="code" href="classmbl__stl__pred__index__adapter__n.html">mbl_stl_pred_index_adapter_n&lt;T,Pred&gt;</a> <a class="code" href="mbl__stl__pred_8h.html#a6b99c12980d990f81930debfdb78dcb1" title="Helper function to create an index adapter of the appropriate type.">mbl_stl_pred_create_index_adapter</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;T&gt;</a>&amp; v, Pred Op)
<a name="l00082"></a>00082 {
<a name="l00083"></a>00083   <span class="keywordflow">return</span>  <a class="code" href="classmbl__stl__pred__index__adapter__n.html">mbl_stl_pred_index_adapter_n&lt;T,Pred&gt;</a>(v,Op);
<a name="l00084"></a>00084 };
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="comment">//: Adapt a predicate over a vector to the operation specified on an index into that vector</span>
<a name="l00087"></a>00087 <span class="comment">// T is type of the vector, and Pred the boolean predicate to really be applied</span>
<a name="l00088"></a>00088 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred&gt;
<a name="l00089"></a><a class="code" href="classmbl__stl__pred__binary__index__adapter.html">00089</a> <span class="keyword">class </span><a class="code" href="classmbl__stl__pred__binary__index__adapter.html" title="Adapt a predicate over a vector to the operation specified on an index into that vector.">mbl_stl_pred_binary_index_adapter</a> : <span class="keyword">public</span> vcl_binary_function&lt;unsigned, unsigned, bool&gt;
<a name="l00090"></a>00090 {
<a name="l00091"></a>00091   <span class="comment">//:const reference to vector used to store the objects indexed</span>
<a name="l00092"></a><a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a79ab3db583ccd55e2684dfcd3f137d54">00092</a>   <span class="keyword">const</span> vcl_vector&lt;T &gt;&amp; <a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a79ab3db583ccd55e2684dfcd3f137d54" title="const reference to vector used to store the objects indexed.">vec_</a>;
<a name="l00093"></a>00093   <span class="comment">//: The predicate to really be applied</span>
<a name="l00094"></a><a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a5b3e21bcee9d07b6d77c65e53a749f3c">00094</a>   Pred <a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a5b3e21bcee9d07b6d77c65e53a749f3c" title="The predicate to really be applied.">Op_</a>;
<a name="l00095"></a>00095  <span class="keyword">public</span>:
<a name="l00096"></a><a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a296fc0be23cb01e329b57d71bb987ac0">00096</a>   <a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a296fc0be23cb01e329b57d71bb987ac0">mbl_stl_pred_binary_index_adapter</a>(vcl_vector&lt;T&gt; <span class="keyword">const</span>&amp; v, Pred Op):<a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a79ab3db583ccd55e2684dfcd3f137d54" title="const reference to vector used to store the objects indexed.">vec_</a>(v),<a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a5b3e21bcee9d07b6d77c65e53a749f3c" title="The predicate to really be applied.">Op_</a>(Op){}
<a name="l00097"></a>00097 
<a name="l00098"></a><a class="code" href="classmbl__stl__pred__binary__index__adapter.html#aa40c5a524ef146e7c95fc67442dd036b">00098</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classmbl__stl__pred__binary__index__adapter.html#aa40c5a524ef146e7c95fc67442dd036b">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; i, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; j)<span class="keyword"> const</span>
<a name="l00099"></a>00099 <span class="keyword">  </span>{
<a name="l00100"></a>00100     <span class="keywordflow">return</span> <a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a5b3e21bcee9d07b6d77c65e53a749f3c" title="The predicate to really be applied.">Op_</a>(<a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a79ab3db583ccd55e2684dfcd3f137d54" title="const reference to vector used to store the objects indexed.">vec_</a>[i],<a class="code" href="classmbl__stl__pred__binary__index__adapter.html#a79ab3db583ccd55e2684dfcd3f137d54" title="const reference to vector used to store the objects indexed.">vec_</a>[j]);
<a name="l00101"></a>00101   }
<a name="l00102"></a>00102 };
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment">//: Helper function to create an index adapter of the appropriate type</span>
<a name="l00105"></a>00105 <span class="comment">// As this is a function not a class, it saves some template gobbledegook in the class name</span>
<a name="l00106"></a>00106 <span class="comment">// Vec is assumed vector&lt;T&gt; where T is the type associated with the constructed adapter</span>
<a name="l00107"></a>00107 <span class="comment">//However note that using this means an extra copy of the predicate functor will occur</span>
<a name="l00108"></a>00108 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred&gt;
<a name="l00109"></a><a class="code" href="mbl__stl__pred_8h.html#a95c2abba10cae7e65c4bf01672fab655">00109</a> <span class="keyword">inline</span> <a class="code" href="classmbl__stl__pred__binary__index__adapter.html" title="Adapt a predicate over a vector to the operation specified on an index into that vector.">mbl_stl_pred_binary_index_adapter&lt;T,Pred&gt;</a> <a class="code" href="mbl__stl__pred_8h.html#a95c2abba10cae7e65c4bf01672fab655" title="Helper function to create an index adapter of the appropriate type.">mbl_stl_pred_create_binary_index_adapter</a>(<span class="keyword">const</span> vcl_vector&lt;T&gt;&amp; v, Pred Op)
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111   <span class="keywordflow">return</span>  <a class="code" href="classmbl__stl__pred__binary__index__adapter.html" title="Adapt a predicate over a vector to the operation specified on an index into that vector.">mbl_stl_pred_binary_index_adapter&lt;T,Pred&gt;</a>(v,Op);
<a name="l00112"></a>00112 };
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="comment">//Order a collection of iterators according to their dereferenced values</span>
<a name="l00116"></a>00116 <span class="comment">//NB assumes the value type supports operator&lt;</span>
<a name="l00117"></a>00117 <span class="comment">//Can also be used for collections of pointers or objects supporting</span>
<a name="l00118"></a>00118 <span class="comment">//dereferencing operator like *p.</span>
<a name="l00119"></a>00119 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iter&gt;
<a name="l00120"></a><a class="code" href="structmbl__stl__pred__iter__deref__order.html">00120</a> <span class="keyword">struct </span><a class="code" href="structmbl__stl__pred__iter__deref__order.html">mbl_stl_pred_iter_deref_order</a> : <span class="keyword">public</span> vcl_binary_function&lt;Iter,Iter, bool&gt;
<a name="l00121"></a>00121 {
<a name="l00122"></a><a class="code" href="structmbl__stl__pred__iter__deref__order.html#acb4c6fb6cea9e17650d7a9423480389d">00122</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span>  <a class="code" href="structmbl__stl__pred__iter__deref__order.html#acb4c6fb6cea9e17650d7a9423480389d">operator()</a>(<span class="keyword">const</span> Iter&amp; iter1, <span class="keyword">const</span> Iter&amp; iter2 )<span class="keyword"> const</span>
<a name="l00123"></a>00123 <span class="keyword">  </span>{
<a name="l00124"></a>00124     <span class="keywordflow">return</span> (*iter1 &lt; *iter2) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00125"></a>00125   }
<a name="l00126"></a>00126 };
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="comment">//Order a collection of pair iterators according to their dereferenced keys</span>
<a name="l00130"></a>00130 <span class="comment">//NB assumes the key type supports operator&lt;</span>
<a name="l00131"></a>00131 <span class="keyword">template</span> &lt;<span class="keyword">class</span> PairIter&gt;
<a name="l00132"></a><a class="code" href="structmbl__stl__pred__pair__iter__key__order.html">00132</a> <span class="keyword">struct </span><a class="code" href="structmbl__stl__pred__pair__iter__key__order.html">mbl_stl_pred_pair_iter_key_order</a> : <span class="keyword">public</span> vcl_binary_function&lt;PairIter,PairIter, bool&gt;
<a name="l00133"></a>00133 {
<a name="l00134"></a><a class="code" href="structmbl__stl__pred__pair__iter__key__order.html#a32d71f3db21012edbb6b97ce6fc3fc6e">00134</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span>  <a class="code" href="structmbl__stl__pred__pair__iter__key__order.html#a32d71f3db21012edbb6b97ce6fc3fc6e">operator()</a>(<span class="keyword">const</span> PairIter&amp; iter1, <span class="keyword">const</span> PairIter&amp; iter2 )<span class="keyword"> const</span>
<a name="l00135"></a>00135 <span class="keyword">  </span>{
<a name="l00136"></a>00136     <span class="keywordflow">return</span> (iter1-&gt;first &lt; iter2-&gt;first) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00137"></a>00137   }
<a name="l00138"></a>00138 };
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="comment">//Order a collection of pair iterators according to their dereferenced values</span>
<a name="l00141"></a>00141 <span class="comment">//NB assumes the key type supports operator&lt;</span>
<a name="l00142"></a>00142 <span class="keyword">template</span> &lt;<span class="keyword">class</span> PairIter&gt;
<a name="l00143"></a><a class="code" href="structmbl__stl__pred__pair__iter__value__order.html">00143</a> <span class="keyword">struct </span><a class="code" href="structmbl__stl__pred__pair__iter__value__order.html">mbl_stl_pred_pair_iter_value_order</a> : <span class="keyword">public</span> vcl_binary_function&lt;PairIter,PairIter, bool&gt;
<a name="l00144"></a>00144 {
<a name="l00145"></a><a class="code" href="structmbl__stl__pred__pair__iter__value__order.html#a36022d616ead4fb324d601a66d8cf09b">00145</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span>  <a class="code" href="structmbl__stl__pred__pair__iter__value__order.html#a36022d616ead4fb324d601a66d8cf09b">operator()</a>(<span class="keyword">const</span> PairIter&amp; iter1, <span class="keyword">const</span> PairIter&amp; iter2 )<span class="keyword"> const</span>
<a name="l00146"></a>00146 <span class="keyword">  </span>{
<a name="l00147"></a>00147     <span class="keywordflow">return</span> (iter1-&gt;second &lt; iter2-&gt;second) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00148"></a>00148   }
<a name="l00149"></a>00149 };
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="comment">//Order a collection of pairs according to their first elements</span>
<a name="l00153"></a>00153 <span class="comment">//NB assumes the key type supports operator&lt;</span>
<a name="l00154"></a>00154 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Pair&gt;
<a name="l00155"></a><a class="code" href="structmbl__stl__pred__pair__key__order.html">00155</a> <span class="keyword">struct </span><a class="code" href="structmbl__stl__pred__pair__key__order.html">mbl_stl_pred_pair_key_order</a> : <span class="keyword">public</span> vcl_binary_function&lt;Pair,Pair, bool&gt;
<a name="l00156"></a>00156 {
<a name="l00157"></a><a class="code" href="structmbl__stl__pred__pair__key__order.html#abe7b8cd6f3763a293c0499193073f555">00157</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span>  <a class="code" href="structmbl__stl__pred__pair__key__order.html#abe7b8cd6f3763a293c0499193073f555">operator()</a>(<span class="keyword">const</span> Pair&amp; pair1, <span class="keyword">const</span> Pair&amp; pair2 )<span class="keyword"> const</span>
<a name="l00158"></a>00158 <span class="keyword">  </span>{
<a name="l00159"></a>00159     <span class="keywordflow">return</span> (pair1.first &lt; pair2.first) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00160"></a>00160   }
<a name="l00161"></a>00161 };
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">//Order a collection of pairs according to their second elements</span>
<a name="l00164"></a>00164 <span class="comment">//NB assumes the key type supports operator&lt;</span>
<a name="l00165"></a>00165 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Pair&gt;
<a name="l00166"></a><a class="code" href="structmbl__stl__pred__pair__value__order.html">00166</a> <span class="keyword">struct </span><a class="code" href="structmbl__stl__pred__pair__value__order.html">mbl_stl_pred_pair_value_order</a> : <span class="keyword">public</span> vcl_binary_function&lt;Pair,Pair, bool&gt;
<a name="l00167"></a>00167 {
<a name="l00168"></a><a class="code" href="structmbl__stl__pred__pair__value__order.html#ad6ad9ea1e69e43a41655695239fc2c9c">00168</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span>  <a class="code" href="structmbl__stl__pred__pair__value__order.html#ad6ad9ea1e69e43a41655695239fc2c9c">operator()</a>(<span class="keyword">const</span> Pair&amp; pair1, <span class="keyword">const</span> Pair&amp; pair2 )<span class="keyword"> const</span>
<a name="l00169"></a>00169 <span class="keyword">  </span>{
<a name="l00170"></a>00170     <span class="keywordflow">return</span> (pair1.second &lt; pair2.second) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00171"></a>00171   }
<a name="l00172"></a>00172 };
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">//</span><span class="comment"></span>
<a name="l00176"></a>00176 <span class="comment">//////////////////////////////////////////////////////////////////////////</span>
<a name="l00177"></a>00177 <span class="comment"></span><span class="comment">//Order a collection of pairs</span>
<a name="l00178"></a>00178 <span class="comment">//First is the primary key, second is the secondary key</span>
<a name="l00179"></a>00179 <span class="comment">//NB assumes both the pair types supports operator&lt;</span>
<a name="l00180"></a>00180 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l00181"></a><a class="code" href="structmbl__stl__pred__pair__order.html">00181</a> <span class="keyword">struct </span><a class="code" href="structmbl__stl__pred__pair__order.html">mbl_stl_pred_pair_order</a> : <span class="keyword">public</span> vcl_binary_function&lt;vcl_pair&lt;T1,T2&gt;,vcl_pair&lt;T1,T2&gt;, bool&gt;
<a name="l00182"></a>00182 {
<a name="l00183"></a><a class="code" href="structmbl__stl__pred__pair__order.html#a0e668c188c5753600f6b87767ff9a3e5">00183</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span>  <a class="code" href="structmbl__stl__pred__pair__order.html#a0e668c188c5753600f6b87767ff9a3e5">operator()</a>(<span class="keyword">const</span> vcl_pair&lt;T1,T2&gt;&amp; pair1, <span class="keyword">const</span> vcl_pair&lt;T1,T2&gt;&amp; pair2 )<span class="keyword"> const</span>
<a name="l00184"></a>00184 <span class="keyword">  </span>{
<a name="l00185"></a>00185     <span class="keywordflow">if</span> (pair1.first &lt; pair2.first)
<a name="l00186"></a>00186       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00187"></a>00187     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pair1.first &gt; pair2.first)
<a name="l00188"></a>00188       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00189"></a>00189     <span class="keywordflow">else</span>
<a name="l00190"></a>00190       <span class="keywordflow">return</span> pair1.second &lt; pair2.second; <span class="comment">//Primaries are equal so order on secondary</span>
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192 };
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="comment">//See if a test pointer is the class type required</span>
<a name="l00195"></a>00195 <span class="comment">//Note the template type T would normally be of pointer type but might also be</span>
<a name="l00196"></a>00196 <span class="comment">//something supporting operator-&gt;() in a pointer like way</span>
<a name="l00197"></a>00197 <span class="comment">//(e.g. auto_ptr mbl_cloneable_ptr etc)</span>
<a name="l00198"></a>00198 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00199"></a>00199 <span class="comment">//NB assumes templated class provides is_a to return its typename</span>
<a name="l00200"></a><a class="code" href="classmbl__stl__pred__is__a.html">00200</a> <span class="keyword">class </span><a class="code" href="classmbl__stl__pred__is__a.html">mbl_stl_pred_is_a</a> : <span class="keyword">public</span> vcl_unary_function&lt;T, bool&gt;
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202   <span class="comment">//:const reference to name of required class type</span>
<a name="l00203"></a><a class="code" href="classmbl__stl__pred__is__a.html#a5a493de4c2fbd488346d617a0635b964">00203</a>   <span class="keyword">const</span> vcl_string&amp; <a class="code" href="classmbl__stl__pred__is__a.html#a5a493de4c2fbd488346d617a0635b964" title="const reference to name of required class type.">ctype_</a>;
<a name="l00204"></a>00204  <span class="keyword">public</span>:
<a name="l00205"></a><a class="code" href="classmbl__stl__pred__is__a.html#a6d7f1345549c187cb0e809e899c69893">00205</a>   <a class="code" href="classmbl__stl__pred__is__a.html#a6d7f1345549c187cb0e809e899c69893">mbl_stl_pred_is_a</a>(vcl_string <span class="keyword">const</span>&amp; ctype):<a class="code" href="classmbl__stl__pred__is__a.html#a5a493de4c2fbd488346d617a0635b964" title="const reference to name of required class type.">ctype_</a>(ctype){}
<a name="l00206"></a>00206 
<a name="l00207"></a><a class="code" href="classmbl__stl__pred__is__a.html#a74764e9a5a2b4e39493b4df0c89e25ff">00207</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classmbl__stl__pred__is__a.html#a74764e9a5a2b4e39493b4df0c89e25ff">operator()</a>(<span class="keyword">const</span> T&amp; p)<span class="keyword"> const</span>
<a name="l00208"></a>00208 <span class="keyword">  </span>{
<a name="l00209"></a>00209       <span class="keywordflow">return</span> (p-&gt;is_a()==<a class="code" href="classmbl__stl__pred__is__a.html#a5a493de4c2fbd488346d617a0635b964" title="const reference to name of required class type.">ctype_</a>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00210"></a>00210   }
<a name="l00211"></a>00211 };
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="classmbl__stl__pred__is__near.html">00213</a> <span class="keyword">class </span><a class="code" href="classmbl__stl__pred__is__near.html">mbl_stl_pred_is_near</a> : <span class="keyword">public</span> vcl_unary_function&lt;double, bool&gt;
<a name="l00214"></a>00214 {
<a name="l00215"></a><a class="code" href="classmbl__stl__pred__is__near.html#a7a727a86af3a104643d15cc09ddfe8e9">00215</a>   <span class="keywordtype">double</span> <a class="code" href="classmbl__stl__pred__is__near.html#a7a727a86af3a104643d15cc09ddfe8e9">epsilon_</a>;
<a name="l00216"></a><a class="code" href="classmbl__stl__pred__is__near.html#ade5d7f82632bea64ae819ac34f96fb11">00216</a>   <span class="keywordtype">double</span> <a class="code" href="classmbl__stl__pred__is__near.html#ade5d7f82632bea64ae819ac34f96fb11">xtarget_</a>;
<a name="l00217"></a>00217  <span class="keyword">public</span>:
<a name="l00218"></a><a class="code" href="classmbl__stl__pred__is__near.html#a32b4322d57b9e3a7892130bcccd4c3d6">00218</a>   <a class="code" href="classmbl__stl__pred__is__near.html#a32b4322d57b9e3a7892130bcccd4c3d6">mbl_stl_pred_is_near</a>(<span class="keywordtype">double</span> xtarget,<span class="keywordtype">double</span> epsilon=1.0E-12)
<a name="l00219"></a>00219   : <a class="code" href="classmbl__stl__pred__is__near.html#a7a727a86af3a104643d15cc09ddfe8e9">epsilon_</a>(epsilon), <a class="code" href="classmbl__stl__pred__is__near.html#ade5d7f82632bea64ae819ac34f96fb11">xtarget_</a>(xtarget)
<a name="l00220"></a>00220   {}
<a name="l00221"></a><a class="code" href="classmbl__stl__pred__is__near.html#ac9c0ed76c864d099b594aae899fbb4b5">00221</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classmbl__stl__pred__is__near.html#ac9c0ed76c864d099b594aae899fbb4b5">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; x)<span class="keyword"> const</span>
<a name="l00222"></a>00222 <span class="keyword">  </span>{
<a name="l00223"></a>00223     <span class="keywordflow">return</span> vcl_fabs(x-<a class="code" href="classmbl__stl__pred__is__near.html#ade5d7f82632bea64ae819ac34f96fb11">xtarget_</a>)&lt;<a class="code" href="classmbl__stl__pred__is__near.html#a7a727a86af3a104643d15cc09ddfe8e9">epsilon_</a>;
<a name="l00224"></a>00224   }
<a name="l00225"></a>00225 };
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="preprocessor">#endif</span>
<a name="l00228"></a>00228 <span class="preprocessor"></span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:33:13 for contrib/mul/mbl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
