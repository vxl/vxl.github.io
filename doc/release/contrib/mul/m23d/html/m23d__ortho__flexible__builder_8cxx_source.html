<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>contrib/mul/m23d/m23d_ortho_flexible_builder.cxx Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">contrib/mul/m23d/m23d_ortho_flexible_builder.cxx</div>  </div>
</div>
<div class="contents">
<a href="m23d__ortho__flexible__builder_8cxx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="m23d__ortho__flexible__builder_8h.html" title="Algorithm to estimate 3D shape basis from multiple 2D views.">m23d_ortho_flexible_builder.h</a>&quot;</span>
<a name="l00002"></a>00002 <span class="comment">//:</span>
<a name="l00003"></a>00003 <span class="comment">// \file</span>
<a name="l00004"></a>00004 <span class="comment">// \author Tim Cootes</span>
<a name="l00005"></a>00005 <span class="comment">// \brief Implementation of the Tomasi &amp; Kanade reconstruction algorithm</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;<a class="code" href="m23d__rotation__from__ortho__projection_8h.html" title="Generate pure 3 x 3 rotation matrix from 2 x 3 projection matrix.">m23d/m23d_rotation_from_ortho_projection.h</a>&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;<a class="code" href="m23d__scaled__ortho__projection_8h.html" title="Extracts scaled rotation/projection component of 2x3 projection matrix P.">m23d/m23d_scaled_ortho_projection.h</a>&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;<a class="code" href="m23d__set__q__constraint_8h.html" title="Functions to construct linear constraints as rows in a matrix.">m23d/m23d_set_q_constraint.h</a>&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;<a class="code" href="m23d__correction__matrix__error_8h.html" title="Error term for calculation of correction to projective matrix.">m23d/m23d_correction_matrix_error.h</a>&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;<a class="code" href="m23d__select__basis__views_8h.html" title="Select a subset most suitable for use as a basis set.">m23d/m23d_select_basis_views.h</a>&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;<a class="code" href="m23d__pure__ortho__projection_8h.html" title="Extracts pure rotation/projection component of 2x3 projection matrix P.">m23d/m23d_pure_ortho_projection.h</a>&gt;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__svd_8h.html">vnl/algo/vnl_svd.h</a>&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__symmetric__eigensystem_8h.html">vnl/algo/vnl_symmetric_eigensystem.h</a>&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__levenberg__marquardt_8h.html">vnl/algo/vnl_levenberg_marquardt.h</a>&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/vgl__vector__3d_8h.html">vgl/vgl_vector_3d.h</a>&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;vcl_iostream.h&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;vcl_algorithm.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;vcl_cstdlib.h&gt;</span>  <span class="comment">// abort()</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;vcl_cassert.h&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">//: Reconstruct structure of 3D points given multiple 2D views</span>
<a name="l00026"></a>00026 <span class="comment">//  Data assumed to be scaled orthographic projections</span>
<a name="l00027"></a>00027 <span class="comment">//  The result is stored in the shape_3d() matrix.</span>
<a name="l00028"></a>00028 <span class="comment">//  The estimated projection matrices are stored in the projections() matrix</span>
<a name="l00029"></a>00029 <span class="comment">//  \param P2D 2ns x np matrix. Rows contain alternating x&#39;s and y&#39;s from 2D shapes</span>
<a name="l00030"></a><a class="code" href="classm23d__ortho__flexible__builder.html#abd1c7b7641cad7626628b3d36016b677">00030</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#abd1c7b7641cad7626628b3d36016b677" title="Reconstruct structure of 3D points given multiple 2D views.">m23d_ortho_flexible_builder::reconstruct_with_first_as_basis</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; P2D,
<a name="l00031"></a>00031                                                                   <span class="keywordtype">unsigned</span> n_modes)
<a name="l00032"></a>00032 {
<a name="l00033"></a>00033   <a class="code" href="classm23d__ortho__flexible__builder.html#a067e851c88572f4b84fa0070de5a9908" title="Reconstruct approximate structure of 3D points given multiple 2D views.">partial_reconstruct</a>(P2D,n_modes);
<a name="l00034"></a>00034   <a class="code" href="classm23d__ortho__flexible__builder.html#a970d5dcd0a6881d0e777214b7717aabc" title="Refine estimates of projection and structure.">refine</a>();
<a name="l00035"></a>00035 }
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">//: Swap the n rows beginning at i with those at j</span>
<a name="l00038"></a><a class="code" href="m23d__ortho__flexible__builder_8cxx.html#a2f8f827f292f571a4ab43b8c5dd5baa6">00038</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="m23d__ortho__flexible__builder_8cxx.html#a2f8f827f292f571a4ab43b8c5dd5baa6" title="Swap the n rows beginning at i with those at j.">m23d_swap_rows</a>(<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; M,
<a name="l00039"></a>00039                            <span class="keywordtype">unsigned</span> i, <span class="keywordtype">unsigned</span> j, <span class="keywordtype">unsigned</span> n)
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Mi = M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(n,M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>(),i,0);
<a name="l00042"></a>00042   M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(n,M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>(),j,0),i,0);  <span class="comment">// Copy rows at j to i</span>
<a name="l00043"></a>00043   M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(Mi,j,0);                         <span class="comment">// Copy rows from i to j</span>
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">//: Reconstruct structure from set of 2d pts</span>
<a name="l00048"></a>00048 <span class="comment">// Formulates measurement matrix P2D then calls reconstruct() function</span>
<a name="l00049"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a0b7e4dd1254a435e0e99c0d91ccc75a6">00049</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a0b7e4dd1254a435e0e99c0d91ccc75a6" title="Reconstruct structure from set of 2d pts.">m23d_ortho_flexible_builder::reconstruct</a>(
<a name="l00050"></a>00050    <span class="keyword">const</span> vcl_vector&lt; vcl_vector&lt; <a class="codeRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/classvgl__point__2d.html">vgl_point_2d&lt;double&gt;</a> &gt; &gt;&amp; pt_vec_list,
<a name="l00051"></a>00051                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_modes )
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053   <span class="comment">// convert pts into a matrix</span>
<a name="l00054"></a>00054   <span class="keywordtype">int</span> nf= pt_vec_list.size();
<a name="l00055"></a>00055   <span class="keywordtype">int</span> n0= pt_vec_list[0].size();
<a name="l00056"></a>00056   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> D(2*nf,n0);
<a name="l00057"></a>00057   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nf; ++i)
<a name="l00058"></a>00058   {
<a name="l00059"></a>00059     <span class="keywordflow">if</span> ( (<span class="keywordtype">unsigned</span>)n0!= pt_vec_list[i].size() )
<a name="l00060"></a>00060     {
<a name="l00061"></a>00061       vcl_cerr&lt;&lt; <span class="stringliteral">&quot;ERROR m23d_ortho_rigid_builder::reconstruct()\n&quot;</span>
<a name="l00062"></a>00062               &lt;&lt; <span class="stringliteral">&quot;problem with different numbers of pts\n&quot;</span>
<a name="l00063"></a>00063               &lt;&lt; <span class="stringliteral">&quot;pt_vec_list[0].size()= &quot;</span> &lt;&lt; pt_vec_list[0].size() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>
<a name="l00064"></a>00064               &lt;&lt; <span class="stringliteral">&quot;pt_vec_list[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;].size()= &quot;</span> &lt;&lt; pt_vec_list[i].size()
<a name="l00065"></a>00065               &lt;&lt; vcl_endl;
<a name="l00066"></a>00066       vcl_abort();
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p=0; p&lt;n0; ++p)
<a name="l00070"></a>00070     {
<a name="l00071"></a>00071       D(2*i,p)= pt_vec_list[i][p].x();
<a name="l00072"></a>00072       D(2*i+1,p)= pt_vec_list[i][p].y();
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074   }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <a class="code" href="classm23d__ortho__flexible__builder.html#a0b7e4dd1254a435e0e99c0d91ccc75a6" title="Reconstruct structure from set of 2d pts.">reconstruct</a>(D, n_modes);
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="comment">//: Reconstruct structure of 3D points given multiple 2D views</span>
<a name="l00081"></a>00081 <span class="comment">//  Data assumed to be scaled orthographic projections</span>
<a name="l00082"></a>00082 <span class="comment">//  The result is stored in the shape_3d() matrix.</span>
<a name="l00083"></a>00083 <span class="comment">//  The estimated projection matrices are stored in the projections() matrix</span>
<a name="l00084"></a>00084 <span class="comment">//  Automatically select views which form a good basis.</span>
<a name="l00085"></a>00085 <span class="comment">//  \param P2D 2ns x np matrix. Rows contain alternating x&#39;s and y&#39;s from 2D shapes</span>
<a name="l00086"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a806b45b2b87fbff3ac8ace3087163da8">00086</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a0b7e4dd1254a435e0e99c0d91ccc75a6" title="Reconstruct structure from set of 2d pts.">m23d_ortho_flexible_builder::reconstruct</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; P2D, <span class="keywordtype">unsigned</span> n_modes)
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088   assert(P2D.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()%2==0);
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <a class="code" href="classm23d__ortho__flexible__builder.html#aec47fc24aa364ace9c7ea6283ef87dfd" title="Take copy of 2D points and remove CoG from each.">set_view_data</a>(P2D);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   vcl_vector&lt;unsigned&gt; basis = <a class="code" href="m23d__select__basis__views_8cxx.html#a941f15b82b67615503d2469a558ed27f" title="Select a subset most suitable for use as a basis set.">m23d_select_basis_views</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>,n_modes,1000);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="comment">// Swap in basis here</span>
<a name="l00095"></a>00095   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;=n_modes;++i)
<a name="l00096"></a>00096     <a class="code" href="m23d__ortho__flexible__builder_8cxx.html#a2f8f827f292f571a4ab43b8c5dd5baa6" title="Swap the n rows beginning at i with those at j.">m23d_swap_rows</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>,2*i,2*basis[i],2);
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   <a class="code" href="classm23d__ortho__flexible__builder.html#a41193172ee1af51872433fedc1b5f25f" title="Decompose centred view data to get initial estimate of shape/projection.">initial_decomposition</a>(n_modes);
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> G;
<a name="l00101"></a>00101   <a class="code" href="classm23d__ortho__flexible__builder.html#ab8a9d739d11c949eb15c524aa04a8bd1" title="Compute correction matrix so that M1.G has suitable projection properties.">compute_correction</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>,G);
<a name="l00102"></a>00102 
<a name="l00103"></a>00103   <span class="comment">// Apply the correction matrix</span>
<a name="l00104"></a>00104   <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>=<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>*G;
<a name="l00105"></a>00105   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html">vnl_svd&lt;double&gt;</a> G_svd(G);
<a name="l00106"></a>00106   <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>=G_svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#aca07308f7241e6a981813dddb8a8d3cb">inverse</a>() * <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <a class="code" href="classm23d__ortho__flexible__builder.html#a3ef36aacad1a214af36196a78dcc8897" title="Disambiguate the ambiguity in the sign of the z ordinates.">disambiguate_z</a>();
<a name="l00109"></a>00109   <a class="code" href="classm23d__ortho__flexible__builder.html#a1d4e2931c544dcccdca06f792f06ab94" title="Apply rotation matrices to each 3 columns of P (and inverse to rows of B).">correct_coord_frame</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>,<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>);
<a name="l00110"></a>00110   <a class="code" href="classm23d__ortho__flexible__builder.html#a970d5dcd0a6881d0e777214b7717aabc" title="Refine estimates of projection and structure.">refine</a>();
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="comment">// Swap out basis here, and re-order derived matrices</span>
<a name="l00113"></a>00113   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=n_modes;i&gt;=0;--i)
<a name="l00114"></a>00114   {
<a name="l00115"></a>00115     <a class="code" href="m23d__ortho__flexible__builder_8cxx.html#a2f8f827f292f571a4ab43b8c5dd5baa6" title="Swap the n rows beginning at i with those at j.">m23d_swap_rows</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>,2*i,2*basis[i],2);
<a name="l00116"></a>00116     <a class="code" href="m23d__ortho__flexible__builder_8cxx.html#a2f8f827f292f571a4ab43b8c5dd5baa6" title="Swap the n rows beginning at i with those at j.">m23d_swap_rows</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>,2*i,2*basis[i],2);
<a name="l00117"></a>00117     <a class="code" href="m23d__ortho__flexible__builder_8cxx.html#a2f8f827f292f571a4ab43b8c5dd5baa6" title="Swap the n rows beginning at i with those at j.">m23d_swap_rows</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#aa79c6157e9d22fb7e3da3eb11c71c43b" title="The 2ns x 3 matrix. Each 2x3 block is the projection for a given view.">pure_P_</a>,2*i,2*basis[i],2);
<a name="l00118"></a>00118     <a class="code" href="m23d__ortho__flexible__builder_8cxx.html#a2f8f827f292f571a4ab43b8c5dd5baa6" title="Swap the n rows beginning at i with those at j.">m23d_swap_rows</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>,i,basis[i],1);
<a name="l00119"></a>00119   }
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="comment">//: Take copy of 2D points and remove CoG from each</span>
<a name="l00123"></a><a class="code" href="classm23d__ortho__flexible__builder.html#aec47fc24aa364ace9c7ea6283ef87dfd">00123</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#aec47fc24aa364ace9c7ea6283ef87dfd" title="Take copy of 2D points and remove CoG from each.">m23d_ortho_flexible_builder::set_view_data</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; P2D)
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125   assert(P2D.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()%2==0);
<a name="l00126"></a>00126   <span class="keywordtype">unsigned</span> ns = P2D.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()/2;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   <span class="comment">// Take copy of 2D points and remove CoG from each</span>
<a name="l00129"></a>00129   <a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>=P2D;
<a name="l00130"></a>00130   <a class="code" href="classm23d__ortho__flexible__builder.html#a939fa037294396a3fdebaa05d50423b8" title="The CoG of each shape supplied to reconstruct().">cog_</a>.resize(ns);
<a name="l00131"></a>00131   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;ns;++i)
<a name="l00132"></a>00132   {
<a name="l00133"></a>00133     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> row_x=P2D.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#aa798b087903b1528197357cd4c6f2e95">get_row</a>(2*i);
<a name="l00134"></a>00134     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> row_y=P2D.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#aa798b087903b1528197357cd4c6f2e95">get_row</a>(2*i+1);
<a name="l00135"></a>00135     <span class="keywordtype">double</span> cog_x = row_x.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a974bfe429368ed871e6a98c52af5752d">mean</a>();
<a name="l00136"></a>00136     <span class="keywordtype">double</span> cog_y = row_y.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a974bfe429368ed871e6a98c52af5752d">mean</a>();
<a name="l00137"></a>00137     row_x-=cog_x;
<a name="l00138"></a>00138     row_y-=cog_y;
<a name="l00139"></a>00139     <a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#adc196bd7f503952815ae16297e9bffd5">set_row</a>(2*i,row_x);
<a name="l00140"></a>00140     <a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#adc196bd7f503952815ae16297e9bffd5">set_row</a>(2*i+1,row_y);
<a name="l00141"></a>00141     <a class="code" href="classm23d__ortho__flexible__builder.html#a939fa037294396a3fdebaa05d50423b8" title="The CoG of each shape supplied to reconstruct().">cog_</a>[i]=<a class="codeRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/classvgl__point__2d.html">vgl_point_2d&lt;double&gt;</a>(cog_x,cog_y);
<a name="l00142"></a>00142   }
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="comment">//: Decompose centred view data to get initial estimate of shape/projection</span>
<a name="l00146"></a>00146 <span class="comment">//  Uncertain up to an affine transformation</span>
<a name="l00147"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a41193172ee1af51872433fedc1b5f25f">00147</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a41193172ee1af51872433fedc1b5f25f" title="Decompose centred view data to get initial estimate of shape/projection.">m23d_ortho_flexible_builder::initial_decomposition</a>(<span class="keywordtype">unsigned</span> n_modes)
<a name="l00148"></a>00148 {
<a name="l00149"></a>00149   <span class="keywordtype">unsigned</span> ns = <a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()/2;
<a name="l00150"></a>00150   <span class="keywordtype">unsigned</span> np = <a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00151"></a>00151 
<a name="l00152"></a>00152   <span class="comment">// Use SVD to get first estimate of the projection/shape matrices</span>
<a name="l00153"></a>00153   <span class="comment">// These are ambiguous up to a txt affine transformation.</span>
<a name="l00154"></a>00154   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html">vnl_svd&lt;double&gt;</a> svd(<a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>);
<a name="l00155"></a>00155   <span class="keywordtype">unsigned</span> t=3*(1+n_modes);
<a name="l00156"></a>00156   <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a1fa1949e6219d0db6e3ad50a32d7e1e0">set_size</a>(2*ns,t);
<a name="l00157"></a>00157   <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a1fa1949e6219d0db6e3ad50a32d7e1e0">set_size</a>(t,np);
<a name="l00158"></a>00158   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;t;++i)
<a name="l00159"></a>00159   {
<a name="l00160"></a>00160     <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#abe844803572d5640c760689ccbbbc1a7">set_column</a>(i,svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#a3b3197be0858ae3315117e6d49cfa4ff">W</a>(i)*svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#ab90d87b0dd53bb3afe92e7c4e6a1d090">U</a>().<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a381354e34437c46e90bc636d246d86ce">get_column</a>(i));
<a name="l00161"></a>00161     <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#adc196bd7f503952815ae16297e9bffd5">set_row</a>(i,svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#ac5495ca5d9689cbcbb147b5e63e8ee6a">V</a>().<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a381354e34437c46e90bc636d246d86ce">get_column</a>(i));
<a name="l00162"></a>00162   }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164   vcl_cout&lt;&lt;<span class="stringliteral">&quot;Initial reconstruction error: &quot;</span>&lt;&lt;(<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>*<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>-<a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>).rms()&lt;&lt;vcl_endl;
<a name="l00165"></a>00165 }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment">//: Disambiguate the ambiguity in the sign of the z ordinates</span>
<a name="l00168"></a>00168 <span class="comment">// First non-zero element should be negative.</span>
<a name="l00169"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a3ef36aacad1a214af36196a78dcc8897">00169</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a3ef36aacad1a214af36196a78dcc8897" title="Disambiguate the ambiguity in the sign of the z ordinates.">m23d_ortho_flexible_builder::disambiguate_z</a>()
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171   <span class="keywordtype">unsigned</span> ns = <a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()/2;
<a name="l00172"></a>00172   <span class="keywordtype">unsigned</span> np = <a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;np;++i)
<a name="l00175"></a>00175   {
<a name="l00176"></a>00176     <span class="keywordflow">if</span> (<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>(2,i)&lt;0) <span class="keywordflow">break</span>;
<a name="l00177"></a>00177     <span class="keywordflow">if</span> (<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>(2,i)&gt;0)
<a name="l00178"></a>00178     {
<a name="l00179"></a>00179       <span class="comment">// Flip sign of z elements</span>
<a name="l00180"></a>00180       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;np;++j) <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>(2,j)*=-1;
<a name="l00181"></a>00181       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;2*ns;++j) <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>(j,2)*=-1;
<a name="l00182"></a>00182       <span class="keywordflow">break</span>;
<a name="l00183"></a>00183     }
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185 }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="comment">//: Reconstruct structure of 3D points given multiple 2D views</span>
<a name="l00189"></a>00189 <span class="comment">//  Data assumed to be scaled orthographic projections</span>
<a name="l00190"></a>00190 <span class="comment">//  The result is stored in the shape_3d() matrix.</span>
<a name="l00191"></a>00191 <span class="comment">//  The estimated projection matrices are stored in the projections() matrix</span>
<a name="l00192"></a>00192 <span class="comment">//  \param P2D 2ns x np matrix. Rows contain alternating x&#39;s and y&#39;s from 2D shapes</span>
<a name="l00193"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a067e851c88572f4b84fa0070de5a9908">00193</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a067e851c88572f4b84fa0070de5a9908" title="Reconstruct approximate structure of 3D points given multiple 2D views.">m23d_ortho_flexible_builder::partial_reconstruct</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; P2D,
<a name="l00194"></a>00194                                                       <span class="keywordtype">unsigned</span> n_modes)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196   assert(P2D.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()%2==0);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <a class="code" href="classm23d__ortho__flexible__builder.html#aec47fc24aa364ace9c7ea6283ef87dfd" title="Take copy of 2D points and remove CoG from each.">set_view_data</a>(P2D);
<a name="l00199"></a>00199   <a class="code" href="classm23d__ortho__flexible__builder.html#a41193172ee1af51872433fedc1b5f25f" title="Decompose centred view data to get initial estimate of shape/projection.">initial_decomposition</a>(n_modes);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> G;
<a name="l00202"></a>00202   <a class="code" href="classm23d__ortho__flexible__builder.html#ab8a9d739d11c949eb15c524aa04a8bd1" title="Compute correction matrix so that M1.G has suitable projection properties.">compute_correction</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>,G);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204   <span class="comment">// Apply the correction matrix</span>
<a name="l00205"></a>00205   <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>=<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>*G;
<a name="l00206"></a>00206   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html">vnl_svd&lt;double&gt;</a> G_svd(G);
<a name="l00207"></a>00207   <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>=G_svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#aca07308f7241e6a981813dddb8a8d3cb">inverse</a>() * <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209   <a class="code" href="classm23d__ortho__flexible__builder.html#a3ef36aacad1a214af36196a78dcc8897" title="Disambiguate the ambiguity in the sign of the z ordinates.">disambiguate_z</a>();
<a name="l00210"></a>00210   <a class="code" href="classm23d__ortho__flexible__builder.html#a1d4e2931c544dcccdca06f792f06ab94" title="Apply rotation matrices to each 3 columns of P (and inverse to rows of B).">correct_coord_frame</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>,<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>);
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="comment">//: Fill a symmetric matrix with elements from v</span>
<a name="l00214"></a>00214 <span class="keyword">static</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> sym_matrix_from_vec(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; v, <span class="keywordtype">unsigned</span> n)
<a name="l00215"></a>00215 {
<a name="l00216"></a>00216   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> S(n,n);
<a name="l00217"></a>00217   <span class="keywordtype">unsigned</span> k=0;
<a name="l00218"></a>00218    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;++i)
<a name="l00219"></a>00219      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;=i;++j,++k)
<a name="l00220"></a>00220        S(i,j)=S(j,i)=v[k];
<a name="l00221"></a>00221   <span class="keywordflow">return</span> S;
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">//: Solve for correction matrix for zero mode case</span>
<a name="l00225"></a>00225 <span class="keyword">static</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> am_solve_for_G0(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; A,
<a name="l00226"></a>00226                                           <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; rhs)
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228   <span class="keywordtype">unsigned</span> n=3;
<a name="l00229"></a>00229   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html">vnl_svd&lt;double&gt;</a> svd(A);
<a name="l00230"></a>00230   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> q0 = svd.solve(rhs);
<a name="l00231"></a>00231   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Q0=sym_matrix_from_vec(q0,n);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   <span class="comment">// If Gk is the t x 3 matrix, the k-th triplet of columns of G,</span>
<a name="l00234"></a>00234   <span class="comment">// then Gk.Gk&#39;=Q0</span>
<a name="l00235"></a>00235   <span class="comment">// Use eigen decomposition to compute Gk</span>
<a name="l00236"></a>00236   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__symmetric__eigensystem.html">vnl_symmetric_eigensystem&lt;double&gt;</a> eig(Q0);
<a name="l00237"></a>00237   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Gk(n,3);
<a name="l00238"></a>00238   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;3;++i)
<a name="l00239"></a>00239   {
<a name="l00240"></a>00240     <span class="comment">//Gk.set_column(i,vcl_sqrt(eig.get_eigenvalue(n-1-i))</span>
<a name="l00241"></a>00241     <span class="comment">//                        *eig.get_eigenvector(n-1-i));</span>
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 
<a name="l00244"></a>00244     <span class="comment">// nb critical bit making sure Gk is pos def</span>
<a name="l00245"></a>00245     <span class="keywordtype">double</span> s= vcl_sqrt(  vcl_fabs(eig.get_eigenvalue(n-1-i)) );
<a name="l00246"></a>00246     Gk.set_column(i, s*eig.get_eigenvector(n-1-i) );
<a name="l00247"></a>00247   }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keywordflow">return</span> Gk;
<a name="l00250"></a>00250 }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="keyword">static</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> am_solve_for_Gk(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; A,
<a name="l00253"></a>00253                                           <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; rhs,
<a name="l00254"></a>00254                                           <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> k)
<a name="l00255"></a>00255 {
<a name="l00256"></a>00256   <a class="code" href="classm23d__correction__matrix__error.html" title="Computes error on constraints when computing correction matrix.">m23d_correction_matrix_error</a> err_fn(A,rhs,m,k);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__levenberg__marquardt.html">vnl_levenberg_marquardt</a> LM(err_fn);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260   <span class="comment">// Generate g for identity for k-th column.</span>
<a name="l00261"></a>00261   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> g(9*(m+1),0.0);
<a name="l00262"></a>00262   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;3;++i) g[9*k+4*i]=1.0;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264   <span class="keywordflow">if</span> (!LM.minimize_using_gradient(g))
<a name="l00265"></a>00265   {
<a name="l00266"></a>00266     vcl_cout&lt;&lt;<span class="stringliteral">&quot;LM failed!!&quot;</span> &lt;&lt; vcl_endl;
<a name="l00267"></a>00267     vcl_abort();
<a name="l00268"></a>00268   }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   vcl_cout&lt;&lt;<span class="stringliteral">&quot;am_solve_for_Gk (k=&quot;</span>&lt;&lt;k&lt;&lt;<span class="stringliteral">&quot;) RMS=&quot;</span>&lt;&lt;err_fn.rms(g)&lt;&lt;vcl_endl;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="comment">// Reshape g into 3(m+1) x 3 matrix</span>
<a name="l00273"></a>00273   <span class="keywordflow">return</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>(g.data_block(),3*(m+1),3);
<a name="l00274"></a>00274 }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="preprocessor">#if 0 // refinement of am_solve_for_Gk()</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span>
<a name="l00278"></a>00278 <span class="keyword">static</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> vec_from_sym_matrix(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; S)
<a name="l00279"></a>00279 {
<a name="l00280"></a>00280   <span class="keywordtype">unsigned</span> n = S.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>();
<a name="l00281"></a>00281   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> v((n*(n+1))/2);
<a name="l00282"></a>00282   <span class="keywordtype">unsigned</span> k=0;
<a name="l00283"></a>00283    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;++i)
<a name="l00284"></a>00284      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;=i;++j,++k)
<a name="l00285"></a>00285        v[k]=S(i,j);
<a name="l00286"></a>00286   <span class="keywordflow">return</span> v;
<a name="l00287"></a>00287 }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="keyword">static</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> am_solve_for_Gk(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; A,
<a name="l00290"></a>00290                                           <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; rhs,
<a name="l00291"></a>00291                                           <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> k)
<a name="l00292"></a>00292 {
<a name="l00293"></a>00293   <span class="comment">// Now refine the solution   *** Not sure that this helps ***</span>
<a name="l00294"></a>00294   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__diag__matrix.html">vnl_diag_matrix&lt;double&gt;</a> W(nq);
<a name="l00295"></a>00295   <span class="keywordtype">double</span> w0=0.01*svd.W(0);
<a name="l00296"></a>00296   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;nq;++i)
<a name="l00297"></a>00297   {
<a name="l00298"></a>00298     <span class="keywordflow">if</span> (svd.W(i)&gt;w0) W[i]=0.0;
<a name="l00299"></a>00299     <span class="keywordflow">else</span>             W[i]=1.0; <span class="comment">//w0*w0/(w0*w0+svd.W(i)*svd.W(i));</span>
<a name="l00300"></a>00300   }
<a name="l00301"></a>00301   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> K=svd.V()*W*svd.V().<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>();
<a name="l00302"></a>00302   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;3;++k)
<a name="l00303"></a>00303   {
<a name="l00304"></a>00304     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Q1=Gk*Gk.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>();
<a name="l00305"></a>00305     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> q1=vec_from_sym_matrix(Q1);
<a name="l00306"></a>00306     vcl_cout&lt;&lt;<span class="stringliteral">&quot;Error for q1 = &quot;</span>&lt;&lt;(A*q1-rhs).rms()&lt;&lt;vcl_endl;
<a name="l00307"></a>00307     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> q2=q0+K*(q1-q0);
<a name="l00308"></a>00308 
<a name="l00309"></a>00309     Q0=sym_matrix_from_vec(q2,n);
<a name="l00310"></a>00310     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__symmetric__eigensystem.html">vnl_symmetric_eigensystem&lt;double&gt;</a> eig2(Q0);
<a name="l00311"></a>00311     vcl_cout&lt;&lt;<span class="stringliteral">&quot;Eigenvalues: &quot;</span>&lt;&lt;eig2.D.diagonal()&lt;&lt;vcl_endl;
<a name="l00312"></a>00312     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;3;++i)
<a name="l00313"></a>00313     {
<a name="l00314"></a>00314       Gk.set_column(i,vcl_sqrt(eig2.get_eigenvalue(n-1-i))
<a name="l00315"></a>00315                               *eig2.get_eigenvector(n-1-i));
<a name="l00316"></a>00316     }
<a name="l00317"></a>00317   }
<a name="l00318"></a>00318   vcl_cout&lt;&lt;<span class="stringliteral">&quot;Gk*Gk&#39;=&quot;</span>&lt;&lt;Gk*Gk.transpose()&lt;&lt;vcl_endl;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="keywordflow">return</span> Gk;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 <span class="preprocessor">#endif // 0</span>
<a name="l00323"></a>00323 <span class="preprocessor"></span>
<a name="l00324"></a>00324 <span class="keyword">static</span> <span class="keywordtype">void</span> compute_Gk(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> &amp; M, <span class="keywordtype">unsigned</span> k,
<a name="l00325"></a>00325                        <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; Gk)
<a name="l00326"></a>00326 {
<a name="l00327"></a>00327   assert(M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>()&gt;=3);
<a name="l00328"></a>00328   <span class="keywordtype">unsigned</span> m = M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>()/3 -1;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> A;
<a name="l00331"></a>00331   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> rhs;
<a name="l00332"></a>00332   <a class="code" href="m23d__set__q__constraint_8cxx.html#a85c6df94679d7c6ca38fe40ff421674f" title="Generate matrix of all constraints on elements of Q.">m23d_set_q_constraints</a>(M,k,A,rhs);
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   <span class="keywordflow">if</span> (m==0)
<a name="l00335"></a>00335     Gk=am_solve_for_G0(A,rhs);
<a name="l00336"></a>00336   <span class="keywordflow">else</span>
<a name="l00337"></a>00337   {
<a name="l00338"></a>00338     Gk=am_solve_for_Gk(A,rhs,m,k);
<a name="l00339"></a>00339   }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341   <span class="keywordflow">if</span> (k==0)
<a name="l00342"></a>00342   {
<a name="l00343"></a>00343     <span class="comment">// Compute extra rotation so that the projection matrix for the</span>
<a name="l00344"></a>00344     <span class="comment">// first shape is a scaled identity projection.</span>
<a name="l00345"></a>00345     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> M0=M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(2,3*(1+m))*Gk;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347     <span class="comment">// Compute a rotation matrix for this</span>
<a name="l00348"></a>00348     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> R=<a class="code" href="m23d__rotation__from__ortho__projection_8cxx.html#a2cf97e887c93319dc4eb4066fc25b7b6" title="Generate pure 3 x 3 rotation matrix from 2 x 3 projection matrix.">m23d_rotation_from_ortho_projection</a>(M0);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     <span class="comment">// Apply inverse so that P.G gives unit projection</span>
<a name="l00351"></a>00351     Gk=Gk*R.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>();
<a name="l00352"></a>00352   }
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="comment">// Compute correction matrix G (t x t) s.t.  M=M1.G and B=(inv(G)).B1</span>
<a name="l00356"></a><a class="code" href="classm23d__ortho__flexible__builder.html#ab8a9d739d11c949eb15c524aa04a8bd1">00356</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#ab8a9d739d11c949eb15c524aa04a8bd1" title="Compute correction matrix so that M1.G has suitable projection properties.">m23d_ortho_flexible_builder::compute_correction</a>(
<a name="l00357"></a>00357                            <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; M1,
<a name="l00358"></a>00358                            <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; G)
<a name="l00359"></a>00359 {
<a name="l00360"></a>00360   <span class="keywordtype">unsigned</span> t = M1.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00361"></a>00361   <span class="keywordtype">unsigned</span> n_modes=t/3-1;
<a name="l00362"></a>00362   G.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a1fa1949e6219d0db6e3ad50a32d7e1e0">set_size</a>(t,t);
<a name="l00363"></a>00363   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;=n_modes;++k)
<a name="l00364"></a>00364   {
<a name="l00365"></a>00365     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Gk;
<a name="l00366"></a>00366     compute_Gk(M1,k,Gk);
<a name="l00367"></a>00367     G.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(Gk,0,k*3);
<a name="l00368"></a>00368   }
<a name="l00369"></a>00369 }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="preprocessor">#if 0 // unused static function</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">double</span> min_row_scale(<span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; M)
<a name="l00373"></a>00373 {
<a name="l00374"></a>00374   <span class="keywordtype">double</span> r1=0,r2=0;
<a name="l00375"></a>00375   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;3;++j)
<a name="l00376"></a>00376   {
<a name="l00377"></a>00377     r1+=M(0,j)*M(0,j);
<a name="l00378"></a>00378     r2+=M(1,j)*M(1,j);
<a name="l00379"></a>00379   }
<a name="l00380"></a>00380   <span class="keywordflow">return</span> vcl_sqrt(vcl_min(r1,r2));
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 <span class="preprocessor">#endif // 0</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>
<a name="l00384"></a>00384 <span class="comment">// Apply rotation matrices to each 3 columns of M (and inverse to rows of B)</span>
<a name="l00385"></a>00385 <span class="comment">// Matrix selected so that projection matrices in each 3 cols have same</span>
<a name="l00386"></a>00386 <span class="comment">// effective rotation.</span>
<a name="l00387"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a1d4e2931c544dcccdca06f792f06ab94">00387</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a1d4e2931c544dcccdca06f792f06ab94" title="Apply rotation matrices to each 3 columns of P (and inverse to rows of B).">m23d_ortho_flexible_builder::correct_coord_frame</a>(<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; M,
<a name="l00388"></a>00388                                                       <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; B)
<a name="l00389"></a>00389 {
<a name="l00390"></a>00390   <span class="keywordtype">unsigned</span> m = M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>()/3-1;
<a name="l00391"></a>00391   <span class="keywordtype">unsigned</span> ns = M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()/2;
<a name="l00392"></a>00392   <span class="keywordtype">unsigned</span> np = B.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00393"></a>00393   <span class="comment">// Compute rotation matrix required to arrange that first 2x3 is unit projection</span>
<a name="l00394"></a>00394   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> U0 = <a class="code" href="m23d__rotation__from__ortho__projection_8cxx.html#a2cf97e887c93319dc4eb4066fc25b7b6" title="Generate pure 3 x 3 rotation matrix from 2 x 3 projection matrix.">m23d_rotation_from_ortho_projection</a>(M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(2,3));
<a name="l00395"></a>00395   M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(2*ns,3) * U0.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>());
<a name="l00396"></a>00396   B.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(U0*B.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(3,np));
<a name="l00397"></a>00397 
<a name="l00398"></a>00398   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=1;j&lt;=m;++j)
<a name="l00399"></a>00399   {
<a name="l00400"></a>00400     <span class="comment">// Due to the ambiguity in the 3rd row of the rotation</span>
<a name="l00401"></a>00401     <span class="comment">// matrix returned by m23d_rotation_from_ortho_projection,</span>
<a name="l00402"></a>00402     <span class="comment">// and the inherent sign ambiguity of the whole matrix,</span>
<a name="l00403"></a>00403     <span class="comment">// there are four possible rotations for each row.</span>
<a name="l00404"></a>00404     <span class="comment">// Compute all rotations, then select the consistent ones.</span>
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     vcl_vector&lt;vnl_matrix&lt;double&gt; &gt; U;
<a name="l00407"></a>00407     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;ns;++i)
<a name="l00408"></a>00408     {
<a name="l00409"></a>00409       <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Mi0=M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(2,3,2*i,0);
<a name="l00410"></a>00410       <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Mij=M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(2,3,2*i,3*j);
<a name="l00411"></a>00411 <span class="preprocessor">#if 0  // **** TEST</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (Mij(0,0)/Mi0(0,0)&lt;0) Mij*=-1;
<a name="l00413"></a>00413 <span class="preprocessor">#endif</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span>      <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Ui0 = <a class="code" href="m23d__rotation__from__ortho__projection_8cxx.html#a2cf97e887c93319dc4eb4066fc25b7b6" title="Generate pure 3 x 3 rotation matrix from 2 x 3 projection matrix.">m23d_rotation_from_ortho_projection</a>(Mi0);
<a name="l00415"></a>00415       <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Uij = <a class="code" href="m23d__rotation__from__ortho__projection_8cxx.html#a2cf97e887c93319dc4eb4066fc25b7b6" title="Generate pure 3 x 3 rotation matrix from 2 x 3 projection matrix.">m23d_rotation_from_ortho_projection</a>(Mij);
<a name="l00416"></a>00416 <span class="preprocessor">#if 0 // DEBUG</span>
<a name="l00417"></a>00417 <span class="preprocessor"></span>      vcl_cout&lt;&lt;Mij*Uij.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>()&lt;&lt;vcl_endl;
<a name="l00418"></a>00418 <span class="preprocessor">#endif</span>
<a name="l00419"></a>00419 <span class="preprocessor"></span>      U.push_back(Uij.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>()*Ui0);
<a name="l00420"></a>00420 <span class="preprocessor">#if 0 // DEBUG</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>      vcl_cout&lt;&lt;<span class="stringliteral">&quot;j=&quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot; i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;) C1:&quot;</span>&lt;&lt;vcl_endl
<a name="l00422"></a>00422               &lt;&lt;Uij.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>()*Ui0&lt;&lt;vcl_endl;
<a name="l00423"></a>00423 <span class="preprocessor">#endif</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span>      <span class="comment">// Swap sign of 3rd row of Uij</span>
<a name="l00425"></a>00425       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;3;++k) Uij(2,k)*=-1;
<a name="l00426"></a>00426       U.push_back(Uij.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>()*Ui0);
<a name="l00427"></a>00427 <span class="preprocessor">#if 0 // DEBUG</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>      vcl_cout&lt;&lt;<span class="stringliteral">&quot;j=&quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot; i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;) C2:&quot;</span>&lt;&lt;vcl_endl
<a name="l00429"></a>00429               &lt;&lt;Uij.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>()*Ui0&lt;&lt;vcl_endl
<a name="l00430"></a>00430               &lt;&lt;<span class="stringliteral">&quot;Rel wts: &quot;</span>&lt;&lt;Mij(0,0)/Mi0(0,0)&lt;&lt;vcl_endl;
<a name="l00431"></a>00431 <span class="preprocessor">#endif</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span>    }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     <span class="comment">// Now find the mean and variance for a variety of possible</span>
<a name="l00435"></a>00435     <span class="comment">// rotation options.</span>
<a name="l00436"></a>00436     <span class="comment">// For each one, select the closest of the four possible matrices</span>
<a name="l00437"></a>00437     <span class="comment">// for each shape</span>
<a name="l00438"></a>00438     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> best_meanU;
<a name="l00439"></a>00439     <span class="keywordtype">double</span> best_rms = 1e99;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;vcl_min(2*ns,40u);++i)
<a name="l00442"></a>00442     {
<a name="l00443"></a>00443       <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> baseR = U[i];
<a name="l00444"></a>00444       <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> sumU(3,3,0.0), bestU;
<a name="l00445"></a>00445       <span class="keywordtype">double</span> sum_rms=0.0;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;ns;++k)
<a name="l00448"></a>00448       {
<a name="l00449"></a>00449         <span class="keywordtype">double</span> d_min=(U[2*k]-baseR).rms();
<a name="l00450"></a>00450         bestU = U[2*k];
<a name="l00451"></a>00451         <span class="keywordtype">double</span> d1=(U[2*k]+baseR).rms();
<a name="l00452"></a>00452         <span class="keywordflow">if</span> (d1&lt;d_min) { d_min=d1; bestU=-U[2*k]; }
<a name="l00453"></a>00453         <span class="keywordtype">double</span> d2=(U[2*k+1]-baseR).rms();
<a name="l00454"></a>00454         <span class="keywordflow">if</span> (d2&lt;d_min) { d_min=d2; bestU=U[2*k+1]; }
<a name="l00455"></a>00455         <span class="keywordtype">double</span> d3=(U[2*k+1]+baseR).rms();
<a name="l00456"></a>00456         <span class="keywordflow">if</span> (d3&lt;d_min) { d_min=d3; bestU=-U[2*k+1]; }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458         sumU+=bestU;
<a name="l00459"></a>00459         sum_rms+=d_min;
<a name="l00460"></a>00460       }
<a name="l00461"></a>00461       sumU/=ns;
<a name="l00462"></a>00462       sum_rms/=ns;
<a name="l00463"></a>00463       <span class="keywordflow">if</span> (i==0 || sum_rms&lt;best_rms)
<a name="l00464"></a>00464       {
<a name="l00465"></a>00465         best_meanU=sumU;
<a name="l00466"></a>00466         best_rms=sum_rms;
<a name="l00467"></a>00467       }
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469     <span class="comment">// Remove scaling effects introduced by averaging</span>
<a name="l00470"></a>00470     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html">vnl_svd&lt;double&gt;</a> Usvd(best_meanU);
<a name="l00471"></a>00471     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Uj = Usvd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#ab90d87b0dd53bb3afe92e7c4e6a1d090">U</a>()*Usvd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#ac5495ca5d9689cbcbb147b5e63e8ee6a">V</a>().<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>();
<a name="l00472"></a>00472     M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(2*ns,3,0,3*j) * Uj,0,3*j);
<a name="l00473"></a>00473     B.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(Uj.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>()*B.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(3,np,3*j,0),3*j,0);
<a name="l00474"></a>00474   }
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="comment">//: Modify projection matrices so they are scaled orthographic projections</span>
<a name="l00478"></a>00478 <span class="comment">//  P = s(I|0)*R</span>
<a name="l00479"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a70075be5c878f2fce75035b4fe9e3ad5">00479</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a70075be5c878f2fce75035b4fe9e3ad5" title="Modify projection matrices so they are scaled orthographic projections.">m23d_ortho_flexible_builder::make_pure_projections</a>()
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481   <span class="keywordtype">unsigned</span> ns = <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()/2;
<a name="l00482"></a>00482   <span class="keywordtype">unsigned</span> m = <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>()/3-1;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484   <a class="code" href="classm23d__ortho__flexible__builder.html#aa79c6157e9d22fb7e3da3eb11c71c43b" title="The 2ns x 3 matrix. Each 2x3 block is the projection for a given view.">pure_P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a1fa1949e6219d0db6e3ad50a32d7e1e0">set_size</a>(2*ns,3);
<a name="l00485"></a>00485   <a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a1fa1949e6219d0db6e3ad50a32d7e1e0">set_size</a>(ns,m+1);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487   <span class="comment">// Generate identity projection</span>
<a name="l00488"></a>00488   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> PI(2,3),Pzero(2,3,0.0);
<a name="l00489"></a>00489   PI(0,0)=1; PI(0,1)=0; PI(0,2)=0;
<a name="l00490"></a>00490   PI(1,0)=0; PI(1,1)=1; PI(1,2)=0;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="comment">// Force first row to be the identity</span>
<a name="l00493"></a>00493   <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(PI,0,0);
<a name="l00494"></a>00494   <a class="code" href="classm23d__ortho__flexible__builder.html#aa79c6157e9d22fb7e3da3eb11c71c43b" title="The 2ns x 3 matrix. Each 2x3 block is the projection for a given view.">pure_P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(PI,0,0);
<a name="l00495"></a>00495   <a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>(0,0)=1.0;
<a name="l00496"></a>00496   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=1;i&lt;=m;++i)
<a name="l00497"></a>00497   {
<a name="l00498"></a>00498     <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(Pzero,0,3*i);
<a name="l00499"></a>00499     <a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>(0,i)=0.0;
<a name="l00500"></a>00500   }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   <span class="comment">// Force next m rows to only contain one non-zero pure projection</span>
<a name="l00503"></a>00503   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=1;i&lt;=m;++i)
<a name="l00504"></a>00504     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;=m;++j)
<a name="l00505"></a>00505     {
<a name="l00506"></a>00506       <span class="keywordflow">if</span> (i==j)
<a name="l00507"></a>00507       {
<a name="l00508"></a>00508         <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> P0=<a class="code" href="m23d__pure__ortho__projection_8cxx.html#a37d25c2cb1f8096eba1123cf06432560" title="Extracts pure rotation/projection component of 2x3 projection matrix P.">m23d_pure_ortho_projection</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(2,3,2*i,3*j));
<a name="l00509"></a>00509         <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(P0,2*i,3*j);
<a name="l00510"></a>00510         <a class="code" href="classm23d__ortho__flexible__builder.html#aa79c6157e9d22fb7e3da3eb11c71c43b" title="The 2ns x 3 matrix. Each 2x3 block is the projection for a given view.">pure_P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(P0,2*i,0);
<a name="l00511"></a>00511         <a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>(i,j)=1.0;
<a name="l00512"></a>00512       }
<a name="l00513"></a>00513       <span class="keywordflow">else</span>
<a name="l00514"></a>00514       {
<a name="l00515"></a>00515         <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(Pzero,2*i,3*j);
<a name="l00516"></a>00516         <a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>(i,j)=0.0;
<a name="l00517"></a>00517       }
<a name="l00518"></a>00518     }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="comment">// Replace each subsequent 2x3 projection with the</span>
<a name="l00521"></a>00521   <span class="comment">// closest pure scaled orthogonal projection.</span>
<a name="l00522"></a>00522   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=m+1;i&lt;ns;++i)
<a name="l00523"></a>00523   {
<a name="l00524"></a>00524     <span class="comment">// Generate a (m+1) x 6 matrix, each row containing one projection matrix</span>
<a name="l00525"></a>00525     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Mi(m+1,6);
<a name="l00526"></a>00526     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;=m;++j)
<a name="l00527"></a>00527     {
<a name="l00528"></a>00528       Mi(j,0)=<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>(2*i,3*j);   Mi(j,1)=<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>(2*i,3*j+1);   Mi(j,2)=<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>(2*i,3*j+2);
<a name="l00529"></a>00529       Mi(j,3)=<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>(2*i+1,3*j); Mi(j,4)=<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>(2*i+1,3*j+1); Mi(j,5)=<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>(2*i+1,3*j+2);
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531     <span class="comment">// Mi should be a&#39;p where a are coeffs and p is mean projection</span>
<a name="l00532"></a>00532     <span class="comment">// |p| should be sqrt(2) for a pure projection (no scaling)</span>
<a name="l00533"></a>00533     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html">vnl_svd&lt;double&gt;</a> Mi_svd(Mi);
<a name="l00534"></a>00534     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> p=Mi_svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#ac5495ca5d9689cbcbb147b5e63e8ee6a">V</a>().<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a381354e34437c46e90bc636d246d86ce">get_column</a>(0)*vcl_sqrt(2.0);
<a name="l00535"></a>00535 
<a name="l00536"></a>00536     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Pi0 = <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>(p.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a672822d3a059ac09909cb32a7be004a9">data_block</a>(),2,3);
<a name="l00537"></a>00537     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> Pi = <a class="code" href="m23d__pure__ortho__projection_8cxx.html#a37d25c2cb1f8096eba1123cf06432560" title="Extracts pure rotation/projection component of 2x3 projection matrix P.">m23d_pure_ortho_projection</a>(Pi0);
<a name="l00538"></a>00538     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> pi(Pi.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#ab1fd1abcbe7fc909d57ca83b1e4a1713">data_block</a>(),6);
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="comment">// Estimate weight for each basis vector</span>
<a name="l00541"></a>00541     <span class="comment">// Each row of Mi should be a[j]*pi&#39;</span>
<a name="l00542"></a>00542     <span class="comment">// Since pi.pi = 2  (each 3 elements is a unit vector)</span>
<a name="l00543"></a>00543     <span class="comment">// a = 0.5*Mi*pi</span>
<a name="l00544"></a>00544     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> a = Mi*pi*0.5;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;=m;++j)
<a name="l00547"></a>00547       <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(Pi*a[j],2*i,3*j);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549     <a class="code" href="classm23d__ortho__flexible__builder.html#aa79c6157e9d22fb7e3da3eb11c71c43b" title="The 2ns x 3 matrix. Each 2x3 block is the projection for a given view.">pure_P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a8a46918b792658fd2032ebf9c2294deb">update</a>(Pi,2*i,0);
<a name="l00550"></a>00550     <a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#adc196bd7f503952815ae16297e9bffd5">set_row</a>(i,a);
<a name="l00551"></a>00551   }
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">//: Refine estimates of projection and structure</span>
<a name="l00555"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a970d5dcd0a6881d0e777214b7717aabc">00555</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a970d5dcd0a6881d0e777214b7717aabc" title="Refine estimates of projection and structure.">m23d_ortho_flexible_builder::refine</a>()
<a name="l00556"></a>00556 {
<a name="l00557"></a>00557   vcl_cout&lt;&lt;<span class="stringliteral">&quot;RMS Reconstruction error before refine = &quot;</span>
<a name="l00558"></a>00558           &lt;&lt;(<a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>-<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>*<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>).rms()&lt;&lt;vcl_endl;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   <a class="code" href="classm23d__ortho__flexible__builder.html#a70075be5c878f2fce75035b4fe9e3ad5" title="Modify projection matrices so they are scaled orthographic projections.">make_pure_projections</a>();
<a name="l00561"></a>00561   <span class="comment">// Re-estimate the 3D shape by solving the linear equation</span>
<a name="l00562"></a>00562   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html">vnl_svd&lt;double&gt;</a> svd(<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>);
<a name="l00563"></a>00563   <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a> = svd.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__svd.html#aece6a02ceb1a134d9791302bd1d373a1">pinverse</a>() * <a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>;
<a name="l00564"></a>00564        <span class="comment">// Slightly less stable than backsub, but what the heck.</span>
<a name="l00565"></a>00565 
<a name="l00566"></a>00566   vcl_cout&lt;&lt;<span class="stringliteral">&quot;RMS Reconstruction error after refine = &quot;</span>
<a name="l00567"></a>00567           &lt;&lt;(<a class="code" href="classm23d__ortho__flexible__builder.html#acae9744d5c8246124b01bdf668758fbc" title="Centred version of the 2D views supplied to reconstruct().">P2Dc_</a>-<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>*<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>).rms()&lt;&lt;vcl_endl;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569   <a class="code" href="classm23d__ortho__flexible__builder.html#adeb4871fbc10b6c483f13f72362eaf15" title="Compute the mean 3D shape.">compute_mean</a>(<a class="code" href="classm23d__ortho__flexible__builder.html#a94eac51c4978aa78b503b2f7c13b29a5" title="Mean 3D shape as a 3 x np matrix.">mean_shape_</a>,<a class="code" href="classm23d__ortho__flexible__builder.html#a4ac7b202c206912b5b121423543fd9db" title="Mean coefficients.">mean_coeffs_</a>);
<a name="l00570"></a>00570 }
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 <span class="comment">//: Compute the mean 3D shape using the current co-effs</span>
<a name="l00573"></a><a class="code" href="classm23d__ortho__flexible__builder.html#adeb4871fbc10b6c483f13f72362eaf15">00573</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#adeb4871fbc10b6c483f13f72362eaf15" title="Compute the mean 3D shape.">m23d_ortho_flexible_builder::compute_mean</a>(<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; mean_shape,
<a name="l00574"></a>00574                                                <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; mean_coeffs)
<a name="l00575"></a>00575 {
<a name="l00576"></a>00576   <span class="comment">// Compute average for each coefficient</span>
<a name="l00577"></a>00577   <span class="keywordtype">unsigned</span> ns=<a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>();
<a name="l00578"></a>00578   <span class="keywordtype">unsigned</span> nm=<a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00579"></a>00579   <span class="keywordtype">unsigned</span> np=<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00580"></a>00580   mean_coeffs.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#ae34b3cfb08e104f2ac81a74dc91537cc">set_size</a>(nm);
<a name="l00581"></a>00581   mean_coeffs.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a9939177982a578e13b05cc5e80f96a14">fill</a>(0.0);
<a name="l00582"></a>00582   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;ns;++i) mean_coeffs+=<a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#aa798b087903b1528197357cd4c6f2e95">get_row</a>(i);
<a name="l00583"></a>00583   mean_coeffs/=ns;
<a name="l00584"></a>00584   mean_shape.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a1fa1949e6219d0db6e3ad50a32d7e1e0">set_size</a>(3,np);
<a name="l00585"></a>00585   mean_shape.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a98da5b87fa05cdab4b7b844ddf8a9074">fill</a>(0.0);
<a name="l00586"></a>00586   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;nm;++j)
<a name="l00587"></a>00587     mean_shape += <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(3,np,3*j,0) * mean_coeffs[j];
<a name="l00588"></a>00588 }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 <span class="comment">//: Return 3D shape i as a 3 x np matrix</span>
<a name="l00591"></a><a class="code" href="classm23d__ortho__flexible__builder.html#afdd34789b83683f3b0ce085d546284b8">00591</a> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> <a class="code" href="classm23d__ortho__flexible__builder.html#afdd34789b83683f3b0ce085d546284b8" title="Return 3D shape i as a 3 x np matrix.">m23d_ortho_flexible_builder::shape</a>(<span class="keywordtype">unsigned</span> i)<span class="keyword"> const</span>
<a name="l00592"></a>00592 <span class="keyword"></span>{
<a name="l00593"></a>00593   <span class="keywordtype">unsigned</span> np=<a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00594"></a>00594   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> S(3,np,0.0);
<a name="l00595"></a>00595   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;<a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();++j)
<a name="l00596"></a>00596     S += <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(3,np,3*j,0) * <a class="code" href="classm23d__ortho__flexible__builder.html#ac5fe5e82c1c46644991559a80f34c23d" title="ns x (m+1) matrix, each row of which contains the weights for a shape.">coeffs_</a>(i,j);
<a name="l00597"></a>00597   <span class="keywordflow">return</span> S;
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="comment">//: Get back 3d pts rotated and shifted for each frame</span>
<a name="l00602"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a89ebb9ddcab519e7679c4dbf87c13644">00602</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a89ebb9ddcab519e7679c4dbf87c13644" title="Return 3d pts given 3*np matrix.">m23d_ortho_flexible_builder::get_shape_3d_pts</a>( vcl_vector&lt; <a class="codeRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/classvgl__point__3d.html">vgl_point_3d&lt;double&gt;</a> &gt;&amp; pts )<span class="keyword"> const</span>
<a name="l00603"></a>00603 <span class="keyword"></span>{
<a name="l00604"></a>00604 <span class="preprocessor">#if 0</span>
<a name="l00605"></a>00605 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>() &lt; 2 || <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>() != 3 )
<a name="l00606"></a>00606   {
<a name="l00607"></a>00607     vcl_cerr&lt;&lt;<span class="stringliteral">&quot;ERROR m23d_ortho_flexible_builder::get_shape_3d_pts()\n&quot;</span>
<a name="l00608"></a>00608             &lt;&lt;<span class="stringliteral">&quot;problem with size of P_\n&quot;</span>
<a name="l00609"></a>00609             &lt;&lt;<span class="stringliteral">&quot;P_.rows()= &quot;</span>&lt;&lt;<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()&lt;&lt;<span class="charliteral">&#39;\n&#39;</span>
<a name="l00610"></a>00610             &lt;&lt;<span class="stringliteral">&quot;P_.cols()= &quot;</span>&lt;&lt;<a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>()&lt;&lt;vcl_endl;
<a name="l00611"></a>00611     vcl_abort();
<a name="l00612"></a>00612   }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="comment">//vnl_matrix&lt;double&gt; newPi = m23d_scaled_ortho_projection(P_.extract(2,3,2*i,0));</span>
<a name="l00616"></a>00616   <span class="comment">//P_.update(newPi,2*i,0);</span>
<a name="l00617"></a>00617   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> P0= <a class="code" href="classm23d__ortho__flexible__builder.html#a3e73d18745867740e4d9b37ba65901a1" title="The 2ns x 3(1+m) projection matrix.">P_</a>.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a6978f66bc36f8936ccbab4716aa40a48">extract</a>(2,3);
<a name="l00618"></a>00618 <span class="preprocessor">#endif // 0</span>
<a name="l00619"></a>00619 <span class="preprocessor"></span>
<a name="l00620"></a>00620   <span class="comment">// get projection matrix for first shape</span>
<a name="l00621"></a>00621   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> P0=<a class="code" href="classm23d__ortho__flexible__builder.html#afdd34789b83683f3b0ce085d546284b8" title="Return 3D shape i as a 3 x np matrix.">shape</a>(0);
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <span class="comment">// Compute a rotation matrix for this projection</span>
<a name="l00624"></a>00624   <span class="comment">// then update shape and</span>
<a name="l00625"></a>00625   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> R0=<a class="code" href="m23d__rotation__from__ortho__projection_8cxx.html#a2cf97e887c93319dc4eb4066fc25b7b6" title="Generate pure 3 x 3 rotation matrix from 2 x 3 projection matrix.">m23d_rotation_from_ortho_projection</a>(P0);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   <span class="comment">// apply rotation to base shape</span>
<a name="l00628"></a>00628   <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> rot_pts_mat=R0* <a class="code" href="classm23d__ortho__flexible__builder.html#a101954e3dfc51cb04e0b810636216a07" title="3(1+m) x np matrix, each column containing one 3D point.">P3D_</a>;
<a name="l00629"></a>00629   <a class="code" href="classm23d__ortho__flexible__builder.html#a05fb408bd7e71f32ca0e5913ef249290" title="Return 3d pts given 3*np matrix.">mat_to_3d_pts</a>( pts, rot_pts_mat );
<a name="l00630"></a>00630 
<a name="l00631"></a>00631 
<a name="l00632"></a>00632   <span class="keywordtype">int</span> np= pts.size();
<a name="l00633"></a>00633   <a class="codeRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/classvgl__vector__3d.html">vgl_vector_3d&lt;double&gt;</a> tran_vec( <a class="code" href="classm23d__ortho__flexible__builder.html#a939fa037294396a3fdebaa05d50423b8" title="The CoG of each shape supplied to reconstruct().">cog_</a>[0].x(), <a class="code" href="classm23d__ortho__flexible__builder.html#a939fa037294396a3fdebaa05d50423b8" title="The CoG of each shape supplied to reconstruct().">cog_</a>[0].y(), 0 );
<a name="l00634"></a>00634   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p=0; p&lt;np; ++p)
<a name="l00635"></a>00635   {
<a name="l00636"></a>00636     pts[p]= pts[p] + tran_vec;
<a name="l00637"></a>00637   }
<a name="l00638"></a>00638 }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 <span class="comment">//: Return 3d rigid pts, i.e., aligned with first frame</span>
<a name="l00642"></a><a class="code" href="classm23d__ortho__flexible__builder.html#a05fb408bd7e71f32ca0e5913ef249290">00642</a> <span class="keywordtype">void</span> <a class="code" href="classm23d__ortho__flexible__builder.html#a05fb408bd7e71f32ca0e5913ef249290" title="Return 3d pts given 3*np matrix.">m23d_ortho_flexible_builder::mat_to_3d_pts</a>(vcl_vector&lt; <a class="codeRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/classvgl__point__3d.html">vgl_point_3d&lt;double&gt;</a> &gt;&amp; pt_vec,
<a name="l00643"></a>00643                                                 <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; M)<span class="keyword"> const</span>
<a name="l00644"></a>00644 <span class="keyword"></span>{
<a name="l00645"></a>00645 <span class="preprocessor">#if 0</span>
<a name="l00646"></a>00646 <span class="preprocessor"></span>  <span class="comment">// get pts out of P3D_ matrix</span>
<a name="l00647"></a>00647   <span class="keywordflow">if</span> ( M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>() != 3 )
<a name="l00648"></a>00648   {
<a name="l00649"></a>00649     vcl_cerr&lt;&lt;<span class="stringliteral">&quot;ERROR m23d_ortho_flexible_builder::mat_to_3d_pts()\n&quot;</span>
<a name="l00650"></a>00650             &lt;&lt;<span class="stringliteral">&quot;problem with size of matrix\n&quot;</span>
<a name="l00651"></a>00651             &lt;&lt;<span class="stringliteral">&quot;M.rows()= &quot;</span>&lt;&lt;M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>()&lt;&lt;<span class="charliteral">&#39;\n&#39;</span>
<a name="l00652"></a>00652             &lt;&lt;<span class="stringliteral">&quot;M.cols()= &quot;</span>&lt;&lt;M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>()&lt;&lt;vcl_endl;
<a name="l00653"></a>00653     vcl_abort();
<a name="l00654"></a>00654   }
<a name="l00655"></a>00655 <span class="preprocessor">#endif // 0</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span>
<a name="l00657"></a>00657   <span class="keywordtype">int</span> np= M.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00658"></a>00658   pt_vec.resize(np);
<a name="l00659"></a>00659   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;np; ++i)
<a name="l00660"></a>00660   {
<a name="l00661"></a>00661     pt_vec[i].set( M(0,i), M(1,i), M(2,i) );
<a name="l00662"></a>00662   }
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:34:31 for contrib/mul/m23d by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
