<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>contrib/mul/mmn/mmn_lbp_solver.cxx Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">contrib/mul/mmn/mmn_lbp_solver.cxx</div>  </div>
</div>
<div class="contents">
<a href="mmn__lbp__solver_8cxx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="mmn__lbp__solver_8h.html" title="Run loopy belief propagation over the graph.">mmn_lbp_solver.h</a>&quot;</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include &lt;vcl_algorithm.h&gt;</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;vcl_functional.h&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;vcl_iterator.h&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;vcl_sstream.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/mbl__exception_8h.html">mbl/mbl_exception.h</a>&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/mbl__stl_8h.html">mbl/mbl_stl.h</a>&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/mbl__parse__block_8h.html">mbl/mbl_parse_block.h</a>&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/mbl__read__props_8h.html">mbl/mbl_read_props.h</a>&gt;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">//:</span>
<a name="l00012"></a>00012 <span class="comment">// \file</span>
<a name="l00013"></a>00013 <span class="comment">// \brief Run loopy belief propagation to estimate maximum marginal probabilities of all node states</span>
<a name="l00014"></a>00014 <span class="comment">// \author Martin Roberts</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="classmmn__lbp__solver.html#a9c03c76e6033bc5d2665dff1c120f220" title="Magic numbers for cycle detection.">mmn_lbp_solver::NHISTORY_</a>=5;
<a name="l00017"></a>00017 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="classmmn__lbp__solver.html#a2e170c938a0514ffcd9843b7b95adddc">mmn_lbp_solver::NCYCLE_DETECT_</a>=7;
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">//: Default constructor</span>
<a name="l00020"></a><a class="code" href="classmmn__lbp__solver.html#af1a47bc70af4d548026fb693873a4d65">00020</a> <a class="code" href="classmmn__lbp__solver.html#af1a47bc70af4d548026fb693873a4d65" title="Default constructor.">mmn_lbp_solver::mmn_lbp_solver</a>()
<a name="l00021"></a>00021     : nnodes_(0), max_iterations_(100), min_simple_iterations_(25),
<a name="l00022"></a>00022       epsilon_(1E-6), alpha_(0.6), smooth_on_cycling_(true),
<a name="l00023"></a>00023       max_cycle_detection_count_(3), verbose_(false),
<a name="l00024"></a>00024       msg_upd_mode_(<a class="code" href="classmmn__lbp__solver.html" title="Run loopy belief to estimate overall marginal probabilities of all node states.">mmn_lbp_solver</a>::eRANDOM_SERIAL)
<a name="l00025"></a>00025 {
<a name="l00026"></a>00026     <a class="code" href="classmmn__lbp__solver.html#aa15e557f471ae905abbcaa74833a03dc" title="Reset iteration counters.">init</a>();
<a name="l00027"></a>00027 }
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">//: Construct with arcs</span>
<a name="l00030"></a><a class="code" href="classmmn__lbp__solver.html#a81b017621fb980eba519e62ab3dc77a0">00030</a> <a class="code" href="classmmn__lbp__solver.html#af1a47bc70af4d548026fb693873a4d65" title="Default constructor.">mmn_lbp_solver::mmn_lbp_solver</a>(<span class="keywordtype">unsigned</span> num_nodes,<span class="keyword">const</span> vcl_vector&lt;mmn_arc&gt;&amp; arcs)
<a name="l00031"></a>00031     : max_iterations_(100), min_simple_iterations_(25),
<a name="l00032"></a>00032       epsilon_(1E-6), alpha_(0.6), smooth_on_cycling_(true),
<a name="l00033"></a>00033       max_cycle_detection_count_(3), verbose_(false),
<a name="l00034"></a>00034       msg_upd_mode_(<a class="code" href="classmmn__lbp__solver.html" title="Run loopy belief to estimate overall marginal probabilities of all node states.">mmn_lbp_solver</a>::eRANDOM_SERIAL)
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036     <a class="code" href="classmmn__lbp__solver.html#aa15e557f471ae905abbcaa74833a03dc" title="Reset iteration counters.">init</a>();
<a name="l00037"></a>00037     <a class="code" href="classmmn__lbp__solver.html#a1bf1f5ed5c4c59caf2de04db7192b952" title="Input the arcs that define the graph.">set_arcs</a>(num_nodes,arcs);
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="classmmn__lbp__solver.html#aa15e557f471ae905abbcaa74833a03dc">00040</a> <span class="keywordtype">void</span> <a class="code" href="classmmn__lbp__solver.html#aa15e557f471ae905abbcaa74833a03dc" title="Reset iteration counters.">mmn_lbp_solver::init</a>()
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042     <a class="code" href="classmmn__lbp__solver.html#a16e101a532ab14a828ac581c661b4db3" title="Current iteration count.">count_</a>=0;
<a name="l00043"></a>00043     <a class="code" href="classmmn__lbp__solver.html#acdae1d562af4c68ac0967da0d05c274c" title="Max change in any message value over this iteration.">max_delta_</a>=-1.0;
<a name="l00044"></a>00044     <a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.clear();
<a name="l00045"></a>00045     <a class="code" href="classmmn__lbp__solver.html#a62ccc1763e88d8bd018e2f1e592f0165" title="previous max_delta values(used to check still descending).">max_delta_history_</a>.clear();
<a name="l00046"></a>00046     <a class="code" href="classmmn__lbp__solver.html#abd4a639e50968ce7a896d722056ff530" title="cycle condition detected.">isCycling_</a> = <span class="keyword">false</span>;
<a name="l00047"></a>00047     <a class="code" href="classmmn__lbp__solver.html#a65630a8f96ec17a81ce520d661ea4da4" title="count of number of times a solution in history is revisited.">nrevisits_</a>=0;
<a name="l00048"></a>00048     <a class="code" href="classmmn__lbp__solver.html#a4a483e4a5a285b2d1458b6a704e7c4e4" title="Number of times cycling has been detected.">cycle_detection_count_</a>=0;
<a name="l00049"></a>00049     <a class="code" href="classmmn__lbp__solver.html#a1dfecc7152018d98a8d45b4c4e541657" title="solution value when cycling first detected.">zbest_on_cycle_detection_</a>=0.0;
<a name="l00050"></a>00050 }
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">//: Pass in the arcs, which are then used to build the graph object</span>
<a name="l00053"></a><a class="code" href="classmmn__lbp__solver.html#a1bf1f5ed5c4c59caf2de04db7192b952">00053</a> <span class="keywordtype">void</span> <a class="code" href="classmmn__lbp__solver.html#a1bf1f5ed5c4c59caf2de04db7192b952" title="Input the arcs that define the graph.">mmn_lbp_solver::set_arcs</a>(<span class="keywordtype">unsigned</span> num_nodes,<span class="keyword">const</span> vcl_vector&lt;mmn_arc&gt;&amp; arcs)
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055     <a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>=num_nodes;
<a name="l00056"></a>00056     <a class="code" href="classmmn__lbp__solver.html#ae03fc6cc1e174098337aaddc8f1cce05" title="The arcs from which the graph was generated.">arcs_</a> = arcs;
<a name="l00057"></a>00057     <span class="comment">//Verify consistency</span>
<a name="l00058"></a>00058     <span class="keywordtype">unsigned</span> max_node=0;
<a name="l00059"></a>00059     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;arcs.size();++i)
<a name="l00060"></a>00060     {
<a name="l00061"></a>00061         max_node=vcl_max(max_node,arcs[i].max_v());
<a name="l00062"></a>00062     }
<a name="l00063"></a>00063     <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a> != max_node+1)
<a name="l00064"></a>00064     {
<a name="l00065"></a>00065         vcl_cerr&lt;&lt;<span class="stringliteral">&quot;Arcs appear to be inconsistent with number of nodes in mmn_lbp_solver::set_arcs\n&quot;</span>
<a name="l00066"></a>00066                 &lt;&lt;<span class="stringliteral">&quot;Max mode in Arcs is: &quot;</span>&lt;&lt;max_node&lt;&lt;<span class="stringliteral">&quot; but number of nodes= &quot;</span>&lt;&lt;<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>&lt;&lt;<span class="charliteral">&#39;\n&#39;</span>;
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     <a class="code" href="classmmn__lbp__solver.html#a4eb1e601f967738137e9c1618516a65e" title="Store in graph form (so each node&#39;s neighbours are conveniently to hand).">graph_</a>.<a class="code" href="classmmn__graph__rep1.html#ab374b5d1f99ed6c59d826c1df2edff37" title="Build from list of arcs.">build</a>(<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>,<a class="code" href="classmmn__lbp__solver.html#ae03fc6cc1e174098337aaddc8f1cce05" title="The arcs from which the graph was generated.">arcs_</a>);
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>.resize(<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>);
<a name="l00072"></a>00072     <a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>=<a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>;
<a name="l00073"></a>00073     <a class="code" href="classmmn__lbp__solver.html#acc3175dbf136174243a9fecf316f86c6" title="Workspace for costs of each arc.">arc_costs_</a>.resize(<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>);
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     <span class="comment">//Set max iterations, somewhat arbitrarily, increasing with nodes and arcs</span>
<a name="l00076"></a>00076     <a class="code" href="classmmn__lbp__solver.html#a9c5627ab3c4bacb6a3a4ded7e9db9e42" title="max number of iterations allowed.">max_iterations_</a> = <a class="code" href="classmmn__lbp__solver.html#af03c2da9ba17fda31fc1fde642714482" title="min number of iterations before checking for solution looping (cycling).">min_simple_iterations_</a> + <a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a> + <a class="code" href="classmmn__lbp__solver.html#ae03fc6cc1e174098337aaddc8f1cce05" title="The arcs from which the graph was generated.">arcs_</a>.size();
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="classmmn__lbp__solver.html#a2616adf6ebf9a4617ad1870a216c4674">00079</a> <span class="keywordtype">double</span> <a class="code" href="classmmn__lbp__solver.html#a2616adf6ebf9a4617ad1870a216c4674" title="return the beliefs, i.e. the marginal probabilities of each node&#39;s states.">mmn_lbp_solver::solve</a>(
<a name="l00080"></a>00080                  <span class="keyword">const</span> vcl_vector&lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> &gt;&amp; node_cost,
<a name="l00081"></a>00081                  <span class="keyword">const</span> vcl_vector&lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> &gt;&amp; pair_cost,
<a name="l00082"></a>00082                  vcl_vector&lt;unsigned&gt;&amp; x)
<a name="l00083"></a>00083 {
<a name="l00084"></a>00084     <span class="keywordflow">return</span> (*<span class="keyword">this</span>)(node_cost,pair_cost,x);
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">//: Run the algorithm</span>
<a name="l00088"></a><a class="code" href="classmmn__lbp__solver.html#ad0b2db58bbdd45780bdebfbe65612687">00088</a> <span class="keywordtype">double</span> <a class="code" href="classmmn__lbp__solver.html#ad0b2db58bbdd45780bdebfbe65612687" title="Find values for each node with minimise the total cost.">mmn_lbp_solver::operator()</a>(<span class="keyword">const</span> vcl_vector&lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a> &gt;&amp; node_costs,
<a name="l00089"></a>00089                                   <span class="keyword">const</span> vcl_vector&lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> &gt;&amp; pair_costs,
<a name="l00090"></a>00090                                   vcl_vector&lt;unsigned&gt;&amp; x)
<a name="l00091"></a>00091 {
<a name="l00092"></a>00092     <a class="code" href="classmmn__lbp__solver.html#aa15e557f471ae905abbcaa74833a03dc" title="Reset iteration counters.">init</a>();
<a name="l00093"></a>00093 
<a name="l00094"></a>00094     x.resize(<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>);
<a name="l00095"></a>00095     vcl_fill(x.begin(),x.end(),0);
<a name="l00096"></a>00096     <a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>.resize(<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>);
<a name="l00097"></a>00097 
<a name="l00098"></a>00098     <a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>.resize(<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>);
<a name="l00099"></a>00099     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>;++i)
<a name="l00100"></a>00100     {
<a name="l00101"></a>00101         <span class="comment">//: Negate costs to convert to log prob (i.e. internally we do maximisation)</span>
<a name="l00102"></a>00102         <a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>[i] = - node_costs[i];
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105     <span class="comment">//Initialise message structure and neighbourhood cost representation</span>
<a name="l00106"></a>00106     <span class="keyword">const</span> vcl_vector&lt;vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt; &gt;&amp; neighbourhoods=<a class="code" href="classmmn__lbp__solver.html#a4eb1e601f967738137e9c1618516a65e" title="Store in graph form (so each node&#39;s neighbours are conveniently to hand).">graph_</a>.<a class="code" href="classmmn__graph__rep1.html#a71d5385678301dd93d41432ea53d47c6" title="Indicates arcs connected to each node.">node_data</a>();
<a name="l00107"></a>00107     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inode=0; inode&lt;neighbourhoods.size();++inode)
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109         <span class="keywordtype">unsigned</span> nbstates=<a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>[inode].size();
<a name="l00110"></a>00110         <a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>[inode].set_size(nbstates);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         <span class="keywordtype">double</span> priorb=vcl_log(1.0/<span class="keywordtype">double</span>(nbstates));
<a name="l00113"></a>00113         <a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>[inode].fill(priorb);
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="keyword">const</span> vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;&amp; neighbours=neighbourhoods[inode];
<a name="l00116"></a>00116         vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;::const_iterator neighIter=neighbours.begin();
<a name="l00117"></a>00117         vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;::const_iterator neighIterEnd=neighbours.end();
<a name="l00118"></a>00118         <span class="keywordflow">while</span> (neighIter != neighIterEnd)
<a name="l00119"></a>00119         {
<a name="l00120"></a>00120             <span class="keywordtype">unsigned</span> arcId=neighIter-&gt;second;
<a name="l00121"></a>00121             <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; linkCosts = <a class="code" href="classmmn__lbp__solver.html#acc3175dbf136174243a9fecf316f86c6" title="Workspace for costs of each arc.">arc_costs_</a>[inode][neighIter-&gt;first];
<a name="l00122"></a>00122             <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double &gt;</a>&amp; srcArcCosts=pair_costs[arcId];
<a name="l00123"></a>00123             <a class="code" href="classmmn__arc.html" title="Representation of topological arc joining two vertices.">mmn_arc</a>&amp; arc=<a class="code" href="classmmn__lbp__solver.html#ae03fc6cc1e174098337aaddc8f1cce05" title="The arcs from which the graph was generated.">arcs_</a>[arcId];
<a name="l00124"></a>00124             <span class="keywordtype">unsigned</span> v1=arc.<a class="code" href="classmmn__arc.html#a0696d6132d088994365e79d440c2652a">v1</a>;
<a name="l00125"></a>00125             <span class="keywordtype">unsigned</span> v2=arc.<a class="code" href="classmmn__arc.html#a22e45bbf400749be1eedc4c8c702cd52">v2</a>;
<a name="l00126"></a>00126             <span class="keywordtype">unsigned</span> minv=arc.<a class="code" href="classmmn__arc.html#a6110a96727c110cbf808af27240fb3b6" title="Return smallest node index.">min_v</a>();
<a name="l00127"></a>00127             <span class="keywordflow">if</span> (inode!=v1 &amp;&amp; inode!=v2)
<a name="l00128"></a>00128             {
<a name="l00129"></a>00129                 vcl_string msg(<span class="stringliteral">&quot;Graph inconsistency in mmn_lbp_solver::operator()\n&quot;</span>);
<a name="l00130"></a>00130                 vcl_ostringstream os;
<a name="l00131"></a>00131                 os &lt;&lt;<span class="stringliteral">&quot;Source node is &quot;</span>&lt;&lt;inode&lt;&lt;<span class="stringliteral">&quot; but arc to alleged neighbour joins nodes &quot;</span>&lt;&lt;v1&lt;&lt;<span class="stringliteral">&quot;\t to &quot;</span>&lt;&lt;v2&lt;&lt;<span class="charliteral">&#39;\n&#39;</span>;
<a name="l00132"></a>00132                 msg+= os.str();
<a name="l00133"></a>00133                 vcl_cerr&lt;&lt;msg&lt;&lt;vcl_endl;
<a name="l00134"></a>00134                 <span class="keywordflow">throw</span> <a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/classmbl__exception__abort.html">mbl_exception_abort</a>(msg);
<a name="l00135"></a>00135             }
<a name="l00136"></a>00136 
<a name="l00137"></a>00137             <span class="keywordflow">if</span> (inode==minv)
<a name="l00138"></a>00138             {
<a name="l00139"></a>00139                 linkCosts=srcArcCosts;
<a name="l00140"></a>00140             }
<a name="l00141"></a>00141             <span class="keywordflow">else</span> <span class="comment">//transpose arc costs as this node is the 2nd element in the pair_costs matrix</span>
<a name="l00142"></a>00142             {
<a name="l00143"></a>00143                 linkCosts=srcArcCosts.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4ecdc9960874f4c3c4f01dd194305a5f">transpose</a>();
<a name="l00144"></a>00144             }
<a name="l00145"></a>00145             linkCosts*= -1.0; <span class="comment">//convert to maximising log prob (not min -log prob)</span>
<a name="l00146"></a>00146             <span class="keywordtype">unsigned</span> nstates=linkCosts.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867">cols</a>();
<a name="l00147"></a>00147             <span class="keywordtype">double</span> dnstates=double(nstates);
<a name="l00148"></a>00148             <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[inode][neighIter-&gt;first].set_size(nstates);
<a name="l00149"></a>00149             <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[inode][neighIter-&gt;first].fill(vcl_log(1.0/dnstates)); <span class="comment">//set all initial messages to uniform prob</span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151             ++neighIter; <span class="comment">//next neighbour of this node</span>
<a name="l00152"></a>00152         }
<a name="l00153"></a>00153     } <span class="comment">//next node</span>
<a name="l00154"></a>00154 
<a name="l00155"></a>00155     <a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a> = <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     <span class="comment">//Now keep repeating message passing</span>
<a name="l00158"></a>00158     vcl_vector&lt;unsigned &gt; random_indices(nnodes_,0);
<a name="l00159"></a>00159     mbl_stl_increments(random_indices.begin(),random_indices.end(),0);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161     <span class="keywordflow">do</span>
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163         <a class="code" href="classmmn__lbp__solver.html#acdae1d562af4c68ac0967da0d05c274c" title="Max change in any message value over this iteration.">max_delta_</a>=-1.0;
<a name="l00164"></a>00164         <span class="keywordflow">switch</span> (<a class="code" href="classmmn__lbp__solver.html#a1d58b0eeb3055b4834f21f6749e5d056">msg_upd_mode_</a>)
<a name="l00165"></a>00165         {
<a name="l00166"></a>00166             <span class="keywordflow">case</span> <a class="code" href="classmmn__lbp__solver.html#a44115b502148728d572adf7fdcb58b53ac93f2894ca511cde146724dbf175bb22">eALL_PARALLEL</a>:
<a name="l00167"></a>00167             {
<a name="l00168"></a>00168                 <span class="comment">//Calculate all updates in parallel using only previous iteration messages</span>
<a name="l00169"></a>00169                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inode=0; inode&lt;<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>;++inode)
<a name="l00170"></a>00170                 {
<a name="l00171"></a>00171                     <a class="code" href="classmmn__lbp__solver.html#a2a4949b6564307648d10beab19ffe46f" title="Update all messages from input node to its neighbours.">update_messages_to_neighbours</a>(inode,<a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>[inode]);
<a name="l00172"></a>00172                 }
<a name="l00173"></a>00173                 <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a> = <a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>;
<a name="l00174"></a>00174             }
<a name="l00175"></a>00175             <span class="keywordflow">break</span>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177             <span class="keywordflow">case</span> <a class="code" href="classmmn__lbp__solver.html#a44115b502148728d572adf7fdcb58b53a74a876d7b6646b12131ca08a034676e0">eRANDOM_SERIAL</a>:
<a name="l00178"></a>00178             <span class="keywordflow">default</span>:
<a name="l00179"></a>00179             {
<a name="l00180"></a>00180                 vcl_random_shuffle(random_indices.begin(),random_indices.end());
<a name="l00181"></a>00181                 <span class="comment">//Randomise the order of inter-node messages</span>
<a name="l00182"></a>00182                 <span class="comment">//May help avoid looping</span>
<a name="l00183"></a>00183                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> knode=0; knode&lt;<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>;++knode)
<a name="l00184"></a>00184                 {
<a name="l00185"></a>00185                     <span class="keywordtype">unsigned</span> inode=random_indices[knode];
<a name="l00186"></a>00186                     <a class="code" href="classmmn__lbp__solver.html#a2a4949b6564307648d10beab19ffe46f" title="Update all messages from input node to its neighbours.">update_messages_to_neighbours</a>(inode,<a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>[inode]);
<a name="l00187"></a>00187                     <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[inode] = <a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>[inode]; <span class="comment">//immediate update for this node</span>
<a name="l00188"></a>00188                 }
<a name="l00189"></a>00189             }
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#acdbaf0eb880b8004e837518afd877626" title="verbose debug output.">verbose_</a>)
<a name="l00193"></a>00193         {
<a name="l00194"></a>00194             vcl_cout&lt;&lt;<span class="stringliteral">&quot;Max message delta at iteration &quot;</span>&lt;&lt;<a class="code" href="classmmn__lbp__solver.html#a16e101a532ab14a828ac581c661b4db3" title="Current iteration count.">count_</a>&lt;&lt;<span class="stringliteral">&quot;\t is &quot;</span>&lt;&lt;<a class="code" href="classmmn__lbp__solver.html#acdae1d562af4c68ac0967da0d05c274c" title="Max change in any message value over this iteration.">max_delta_</a>&lt;&lt;vcl_endl;
<a name="l00195"></a>00195         }
<a name="l00196"></a>00196         <span class="comment">//Now calculate belief levels of each node&#39;s states</span>
<a name="l00197"></a>00197         <a class="code" href="classmmn__lbp__solver.html#a7bd5a8f2508184d1ab8d554288993397" title="update beliefs and calculate changes therein.">calculate_beliefs</a>(x);
<a name="l00198"></a>00198     }
<a name="l00199"></a>00199     <span class="keywordflow">while</span> (<a class="code" href="classmmn__lbp__solver.html#a9e576e112f0a4f91e942918fd3ac7466" title="Check if we carry on.">continue_propagation</a>(x));
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="comment">//Now calculate final belief levels of each node&#39;s states and select the maximising ones</span>
<a name="l00202"></a>00202     <a class="code" href="classmmn__lbp__solver.html#a7bd5a8f2508184d1ab8d554288993397" title="update beliefs and calculate changes therein.">calculate_beliefs</a>(x);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inode=0; inode&lt;<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>;++inode)
<a name="l00205"></a>00205     {
<a name="l00206"></a>00206         <a class="code" href="classmmn__lbp__solver.html#acea975839c9b65d40d86935b477e0211" title="Renormalise messages (assume they represent log probabilities) so SUM(exp) over target states is 1...">renormalise_log</a>(<a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>[inode]);
<a name="l00207"></a>00207         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;<a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>[inode].size();i++)
<a name="l00208"></a>00208         {
<a name="l00209"></a>00209             <a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>[inode][i]=vcl_exp(<a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>[inode][i]);
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211     }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     <span class="comment">//Return -best solution value (i.e. minimised form)</span>
<a name="l00214"></a>00214     <span class="comment">//vcl_cout&lt;&lt;&quot;Calculating solution cost...&quot;&lt;&lt;vcl_endl;</span>
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <span class="keywordflow">if</span> (!<a class="code" href="classmmn__lbp__solver.html#abd4a639e50968ce7a896d722056ff530" title="cycle condition detected.">isCycling_</a>)
<a name="l00217"></a>00217     {
<a name="l00218"></a>00218         <span class="keywordflow">return</span> -<a class="code" href="classmmn__lbp__solver.html#afd07e1921b4de20bc1f26fda6fd660e8" title="Calculate final sum of node and arc values.">solution_cost</a>(x);
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220     <span class="keywordflow">else</span>
<a name="l00221"></a>00221     {
<a name="l00222"></a>00222         <span class="keywordtype">double</span> zbest=<a class="code" href="classmmn__lbp__solver.html#a2f01e6dcd8d26f9a1053d8439de51141">best_solution_cost_in_history</a>(x);
<a name="l00223"></a>00223         <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#acdbaf0eb880b8004e837518afd877626" title="verbose debug output.">verbose_</a>)
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225             vcl_cout&lt;&lt;<span class="stringliteral">&quot;Best solution when cycling condition first detected was: &quot;</span>&lt;&lt;<a class="code" href="classmmn__lbp__solver.html#a1dfecc7152018d98a8d45b4c4e541657" title="solution value when cycling first detected.">zbest_on_cycle_detection_</a>&lt;&lt;vcl_endl
<a name="l00226"></a>00226                     &lt;&lt;<span class="stringliteral">&quot;Final Best solution : &quot;</span>&lt;&lt;zbest&lt;&lt;vcl_endl;
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228         <span class="keywordflow">return</span> -zbest;
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a><a class="code" href="classmmn__lbp__solver.html#a7bd5a8f2508184d1ab8d554288993397">00232</a> <span class="keywordtype">void</span> <a class="code" href="classmmn__lbp__solver.html#a7bd5a8f2508184d1ab8d554288993397" title="update beliefs and calculate changes therein.">mmn_lbp_solver::calculate_beliefs</a>(vcl_vector&lt;unsigned&gt;&amp; x)
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234     <span class="comment">//Now calculate belief levels of each node&#39;s states</span>
<a name="l00235"></a>00235     <span class="comment">//NB calculates log belief actually</span>
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     <span class="keyword">const</span> vcl_vector&lt;vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt; &gt;&amp; neighbourhoods=<a class="code" href="classmmn__lbp__solver.html#a4eb1e601f967738137e9c1618516a65e" title="Store in graph form (so each node&#39;s neighbours are conveniently to hand).">graph_</a>.<a class="code" href="classmmn__graph__rep1.html#a71d5385678301dd93d41432ea53d47c6" title="Indicates arcs connected to each node.">node_data</a>();
<a name="l00238"></a>00238     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inode=0; inode&lt;neighbourhoods.size();++inode)
<a name="l00239"></a>00239     {
<a name="l00240"></a>00240         <span class="keywordtype">unsigned</span> bestState=0;
<a name="l00241"></a>00241         <span class="keywordtype">double</span> best=-1.0E012;
<a name="l00242"></a>00242         <span class="keywordtype">unsigned</span> nstates=<a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>[inode].size();
<a name="l00243"></a>00243         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> istate=0; istate&lt;nstates;++istate)
<a name="l00244"></a>00244         {
<a name="l00245"></a>00245             <span class="keywordtype">double</span> b=<a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>[inode][istate];
<a name="l00246"></a>00246             <span class="comment">//Now loop over neighbourhood</span>
<a name="l00247"></a>00247             <span class="keyword">const</span> vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;&amp; neighbours=<a class="code" href="classmmn__lbp__solver.html#a4eb1e601f967738137e9c1618516a65e" title="Store in graph form (so each node&#39;s neighbours are conveniently to hand).">graph_</a>.<a class="code" href="classmmn__graph__rep1.html#a71d5385678301dd93d41432ea53d47c6" title="Indicates arcs connected to each node.">node_data</a>()[inode];
<a name="l00248"></a>00248             vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;::const_iterator neighIter=neighbours.begin();
<a name="l00249"></a>00249             vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;::const_iterator neighIterEnd=neighbours.end();
<a name="l00250"></a>00250             <span class="keywordflow">while</span> (neighIter != neighIterEnd)
<a name="l00251"></a>00251             {
<a name="l00252"></a>00252                 <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; msgsFromNeigh = <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[neighIter-&gt;first][inode];
<a name="l00253"></a>00253                 b+= msgsFromNeigh[istate];
<a name="l00254"></a>00254                 ++neighIter;
<a name="l00255"></a>00255             }
<a name="l00256"></a>00256             <a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>[inode][istate]=b;
<a name="l00257"></a>00257             <span class="keywordflow">if</span> (b&gt;best)
<a name="l00258"></a>00258             {
<a name="l00259"></a>00259                 best=b;
<a name="l00260"></a>00260                 bestState=istate;
<a name="l00261"></a>00261             }
<a name="l00262"></a>00262         }
<a name="l00263"></a>00263         x[inode]=bestState;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         <a class="code" href="classmmn__lbp__solver.html#acea975839c9b65d40d86935b477e0211" title="Renormalise messages (assume they represent log probabilities) so SUM(exp) over target states is 1...">renormalise_log</a>(<a class="code" href="classmmn__lbp__solver.html#a0cf1247802a72c78840dad46d8c181da" title="belief prob for each state of each node.">belief_</a>[inode]);
<a name="l00266"></a>00266     }
<a name="l00267"></a>00267 }
<a name="l00268"></a>00268 
<a name="l00269"></a><a class="code" href="classmmn__lbp__solver.html#afd07e1921b4de20bc1f26fda6fd660e8">00269</a> <span class="keywordtype">double</span> <a class="code" href="classmmn__lbp__solver.html#afd07e1921b4de20bc1f26fda6fd660e8" title="Calculate final sum of node and arc values.">mmn_lbp_solver::solution_cost</a>(vcl_vector&lt;unsigned&gt;&amp; x)
<a name="l00270"></a>00270 {
<a name="l00271"></a>00271     <span class="comment">//: Calculate best (max log prob) of solution x</span>
<a name="l00272"></a>00272     <span class="keywordtype">double</span> sumNodes=0.0;
<a name="l00273"></a>00273     <span class="comment">//Sum over all nodes</span>
<a name="l00274"></a>00274     vcl_vector&lt;vnl_vector&lt;double&gt; &gt;::const_iterator nodeIter=<a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>.begin();
<a name="l00275"></a>00275     vcl_vector&lt;vnl_vector&lt;double&gt; &gt;::const_iterator nodeIterEnd=<a class="code" href="classmmn__lbp__solver.html#aa8620190fa45b00d6954b347789ec37b" title="Node costs (outer vector is node ID, inner vnl_vector is by state value).">node_costs_</a>.end();
<a name="l00276"></a>00276     vcl_vector&lt;unsigned &gt;::const_iterator stateIter=x.begin();
<a name="l00277"></a>00277     <span class="keywordflow">while</span> (nodeIter != nodeIterEnd)
<a name="l00278"></a>00278     {
<a name="l00279"></a>00279         <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; ncosts = *nodeIter;
<a name="l00280"></a>00280         sumNodes+=ncosts[*stateIter];
<a name="l00281"></a>00281         ++nodeIter;++stateIter;
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     <span class="comment">// Sum over all arcs</span>
<a name="l00285"></a>00285     vcl_vector&lt;mmn_arc&gt;::const_iterator arcIter=<a class="code" href="classmmn__lbp__solver.html#ae03fc6cc1e174098337aaddc8f1cce05" title="The arcs from which the graph was generated.">arcs_</a>.begin();
<a name="l00286"></a>00286     vcl_vector&lt;mmn_arc&gt;::const_iterator arcIterEnd=<a class="code" href="classmmn__lbp__solver.html#ae03fc6cc1e174098337aaddc8f1cce05" title="The arcs from which the graph was generated.">arcs_</a>.end();
<a name="l00287"></a>00287     <span class="keywordtype">double</span> sumArcs=0.0;
<a name="l00288"></a>00288     <span class="keywordflow">while</span> (arcIter != arcIterEnd)
<a name="l00289"></a>00289     {
<a name="l00290"></a>00290         <span class="keywordtype">unsigned</span> nodeId1=arcIter-&gt;v1;
<a name="l00291"></a>00291         <span class="keywordtype">unsigned</span> nodeId2=arcIter-&gt;v2;
<a name="l00292"></a>00292         sumArcs += <a class="code" href="classmmn__lbp__solver.html#acc3175dbf136174243a9fecf316f86c6" title="Workspace for costs of each arc.">arc_costs_</a>[nodeId1][nodeId2](x[nodeId1],x[nodeId2]);
<a name="l00293"></a>00293         ++arcIter;
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     <span class="keywordflow">return</span> sumNodes+sumArcs;
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 
<a name="l00299"></a><a class="code" href="classmmn__lbp__solver.html#a2f01e6dcd8d26f9a1053d8439de51141">00299</a> <span class="keywordtype">double</span> <a class="code" href="classmmn__lbp__solver.html#a2f01e6dcd8d26f9a1053d8439de51141">mmn_lbp_solver::best_solution_cost_in_history</a>(vcl_vector&lt;unsigned&gt;&amp; x)
<a name="l00300"></a>00300 {
<a name="l00301"></a>00301     <span class="keywordtype">double</span> zbest=<a class="code" href="classmmn__lbp__solver.html#afd07e1921b4de20bc1f26fda6fd660e8" title="Calculate final sum of node and arc values.">solution_cost</a>(x);
<a name="l00302"></a>00302     vcl_vector&lt;double&gt; solution_vals(<a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.size());
<a name="l00303"></a>00303     vcl_deque&lt;vcl_vector&lt;unsigned&gt; &gt;::iterator xIter=<a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.begin();
<a name="l00304"></a>00304     vcl_deque&lt;vcl_vector&lt;unsigned&gt; &gt;::iterator xIterEnd=<a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.end();
<a name="l00305"></a>00305     vcl_deque&lt;vcl_vector&lt;unsigned&gt; &gt;::iterator xIterBest=<a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.end()-1;
<a name="l00306"></a>00306     <span class="keywordflow">while</span> (xIter != xIterEnd)
<a name="l00307"></a>00307     {
<a name="l00308"></a>00308         <span class="keywordtype">double</span> z = <a class="code" href="classmmn__lbp__solver.html#afd07e1921b4de20bc1f26fda6fd660e8" title="Calculate final sum of node and arc values.">solution_cost</a>(*xIter);
<a name="l00309"></a>00309         <span class="keywordflow">if</span> (z&gt;zbest)
<a name="l00310"></a>00310         {
<a name="l00311"></a>00311             zbest=z;
<a name="l00312"></a>00312             xIterBest=xIter;
<a name="l00313"></a>00313         }
<a name="l00314"></a>00314         ++xIter;
<a name="l00315"></a>00315     }
<a name="l00316"></a>00316     x=*xIterBest;
<a name="l00317"></a>00317     <span class="keywordflow">return</span> zbest;
<a name="l00318"></a>00318 }
<a name="l00319"></a>00319 
<a name="l00320"></a><a class="code" href="classmmn__lbp__solver.html#a2a4949b6564307648d10beab19ffe46f">00320</a> <span class="keywordtype">void</span> <a class="code" href="classmmn__lbp__solver.html#a2a4949b6564307648d10beab19ffe46f" title="Update all messages from input node to its neighbours.">mmn_lbp_solver::update_messages_to_neighbours</a>(<span class="keywordtype">unsigned</span> inode,
<a name="l00321"></a>00321                                                    <span class="keyword">const</span> <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; node_cost)
<a name="l00322"></a>00322 {
<a name="l00323"></a>00323     <span class="comment">//Update all messages from this node to its neighbours</span>
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="keyword">const</span> vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;&amp; neighbours=<a class="code" href="classmmn__lbp__solver.html#a4eb1e601f967738137e9c1618516a65e" title="Store in graph form (so each node&#39;s neighbours are conveniently to hand).">graph_</a>.<a class="code" href="classmmn__graph__rep1.html#a71d5385678301dd93d41432ea53d47c6" title="Indicates arcs connected to each node.">node_data</a>()[inode];
<a name="l00326"></a>00326 
<a name="l00327"></a>00327     vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;::const_iterator neighIter=neighbours.begin();
<a name="l00328"></a>00328     vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;::const_iterator neighIterEnd=neighbours.end();
<a name="l00329"></a>00329     <span class="keywordflow">while</span> (neighIter != neighIterEnd) <span class="comment">//Loop over all my neighbours</span>
<a name="l00330"></a>00330     {
<a name="l00331"></a>00331         <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double&gt;</a>&amp; msgsToNeigh = <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[inode][neighIter-&gt;first];
<a name="l00332"></a>00332         <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html">vnl_matrix&lt;double&gt;</a>&amp; linkCosts = <a class="code" href="classmmn__lbp__solver.html#acc3175dbf136174243a9fecf316f86c6" title="Workspace for costs of each arc.">arc_costs_</a>[inode][neighIter-&gt;first];
<a name="l00333"></a>00333         <span class="keywordtype">unsigned</span> nTargetStates=msgsToNeigh.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a11191c91a1dbb4e1d8423dad8b110712">size</a>();
<a name="l00334"></a>00334         <span class="keywordtype">unsigned</span> nSrcStates=linkCosts.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7">rows</a>(); <span class="comment">//number of source states for this node</span>
<a name="l00335"></a>00335         <span class="keywordflow">if</span> (nSrcStates!=node_cost.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a11191c91a1dbb4e1d8423dad8b110712">size</a>())
<a name="l00336"></a>00336         {
<a name="l00337"></a>00337             vcl_string msg(<span class="stringliteral">&quot;Inconsistent array sizes in mmn_lbp_solver::update_messages_to_neighbours\n&quot;</span>);
<a name="l00338"></a>00338             msg+= <span class="stringliteral">&quot;Inconsistent array sizes in mmn_lbp_solver::update_messages_to_neighbours &quot;</span>;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340             vcl_cerr&lt;&lt;msg&lt;&lt;vcl_endl;
<a name="l00341"></a>00341             <span class="keywordflow">throw</span> <a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/classmbl__exception__abort.html">mbl_exception_abort</a>(msg);
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> jstate=0;jstate&lt;nTargetStates;++jstate) <span class="comment">//do each state of the target neighbour</span>
<a name="l00344"></a>00344         {
<a name="l00345"></a>00345             <span class="keywordtype">double</span> max_istates= -1E99; <span class="comment">// minus infinity, as initialisation for a maximum</span>
<a name="l00346"></a>00346             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> istate=0; istate&lt;nSrcStates;++istate)
<a name="l00347"></a>00347             {
<a name="l00348"></a>00348                 <span class="keywordtype">double</span> logProdIncoming=0.0;
<a name="l00349"></a>00349                 <span class="comment">//Compute product of all incoming messages to this node i from elsewhere (excluding target node j)</span>
<a name="l00350"></a>00350                 vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;::const_iterator tomeIter=neighbours.begin();
<a name="l00351"></a>00351                 vcl_vector&lt;vcl_pair&lt;unsigned,unsigned&gt; &gt;::const_iterator tomeIterEnd=neighbours.end();
<a name="l00352"></a>00352                 <span class="keywordflow">while</span> (tomeIter != tomeIterEnd)
<a name="l00353"></a>00353                 {
<a name="l00354"></a>00354                     <span class="keywordflow">if</span> (tomeIter != neighIter)
<a name="l00355"></a>00355                     {
<a name="l00356"></a>00356                         <span class="keywordtype">unsigned</span> k=tomeIter-&gt;first;
<a name="l00357"></a>00357                         <span class="keywordtype">double</span> m_ki_xi=<a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[k][inode][istate];
<a name="l00358"></a>00358                         logProdIncoming += m_ki_xi;
<a name="l00359"></a>00359                     }
<a name="l00360"></a>00360                     ++tomeIter;
<a name="l00361"></a>00361                 }
<a name="l00362"></a>00362                 <span class="keywordtype">double</span> acost=linkCosts(istate,jstate);
<a name="l00363"></a>00363                 <span class="keywordtype">double</span> ncost=node_cost[istate];
<a name="l00364"></a>00364                 <span class="keywordtype">double</span> logMij=acost+ncost+logProdIncoming;
<a name="l00365"></a>00365                 max_istates = vcl_max(max_istates,logMij);
<a name="l00366"></a>00366             }
<a name="l00367"></a>00367             <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#a4a483e4a5a285b2d1458b6a704e7c4e4" title="Number of times cycling has been detected.">cycle_detection_count_</a>&gt;0 &amp;&amp; <a class="code" href="classmmn__lbp__solver.html#a9489ee1dbf2e2479741b5b0bdd3c1812" title="should message update be smoothed during cycling.">smooth_on_cycling_</a>)
<a name="l00368"></a>00368             {
<a name="l00369"></a>00369                 <a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>[inode][neighIter-&gt;first][jstate]=<a class="code" href="classmmn__lbp__solver.html#aae79520e85394a572d6380eea1fae6cf" title="message update smoothing constant (used if cycling detected).">alpha_</a>*max_istates+(1.0-<a class="code" href="classmmn__lbp__solver.html#aae79520e85394a572d6380eea1fae6cf" title="message update smoothing constant (used if cycling detected).">alpha_</a>)*<a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[inode][neighIter-&gt;first][jstate];
<a name="l00370"></a>00370             }
<a name="l00371"></a>00371             <span class="keywordflow">else</span>
<a name="l00372"></a>00372             {
<a name="l00373"></a>00373                 <a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>[inode][neighIter-&gt;first][jstate]=max_istates;
<a name="l00374"></a>00374             }
<a name="l00375"></a>00375         }
<a name="l00376"></a>00376         <a class="code" href="classmmn__lbp__solver.html#acea975839c9b65d40d86935b477e0211" title="Renormalise messages (assume they represent log probabilities) so SUM(exp) over target states is 1...">renormalise_log</a>(<a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>[inode][neighIter-&gt;first]);
<a name="l00377"></a>00377 <span class="preprocessor">#if 0</span>
<a name="l00378"></a>00378 <span class="preprocessor"></span>        vcl_cout&lt;&lt;<span class="stringliteral">&quot;Iteration &quot;</span>&lt;&lt;<a class="code" href="classmmn__lbp__solver.html#a16e101a532ab14a828ac581c661b4db3" title="Current iteration count.">count_</a>&lt;&lt;<span class="stringliteral">&quot;Msg Upd Node\t&quot;</span>&lt;&lt;inode&lt;&lt;<span class="stringliteral">&quot;\tto node &quot;</span>&lt;&lt;neighIter-&gt;first&lt;&lt;<span class="charliteral">&#39;\t&#39;</span>;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380         vcl_copy(<a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>[inode][neighIter-&gt;first].begin(),
<a name="l00381"></a>00381                  <a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>[inode][neighIter-&gt;first].end(),
<a name="l00382"></a>00382                  vcl_ostream_iterator&lt;double&gt;(vcl_cout,<span class="stringliteral">&quot;\t&quot;</span>));
<a name="l00383"></a>00383         vcl_cout&lt;&lt;vcl_endl
<a name="l00384"></a>00384                 &lt;&lt;<span class="stringliteral">&quot;Iteration &quot;</span>&lt;&lt;<a class="code" href="classmmn__lbp__solver.html#a16e101a532ab14a828ac581c661b4db3" title="Current iteration count.">count_</a>&lt;&lt;<span class="stringliteral">&quot;Msg Prv Node\t&quot;</span>&lt;&lt;inode&lt;&lt;<span class="stringliteral">&quot;\tto node &quot;</span>&lt;&lt;neighIter-&gt;first&lt;&lt;<span class="charliteral">&#39;\t&#39;</span>;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         vcl_copy(<a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[inode][neighIter-&gt;first].begin(),
<a name="l00387"></a>00387                  <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[inode][neighIter-&gt;first].end(),
<a name="l00388"></a>00388                  vcl_ostream_iterator&lt;double&gt;(vcl_cout,<span class="stringliteral">&quot;\t&quot;</span>));
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         vcl_cout&lt;&lt;vcl_endl&lt;&lt;vcl_endl;
<a name="l00391"></a>00391 <span class="preprocessor">#endif</span>
<a name="l00392"></a>00392 <span class="preprocessor"></span>
<a name="l00393"></a>00393         <span class="comment">//: Compute max change during iteration</span>
<a name="l00394"></a>00394         <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double &gt;</a> delta_message=(<a class="code" href="classmmn__lbp__solver.html#aad791d40e78ca1ab6d6da182e50a97b9" title="Update messages calculated during this iteration (vector index is source node).">messages_upd_</a>[inode][neighIter-&gt;first]-
<a name="l00395"></a>00395                                            <a class="code" href="classmmn__lbp__solver.html#a640407d216666940d30551cbefbdc122" title="All the messages at previous iteration (vector index is source node).">messages_</a>[inode][neighIter-&gt;first]);
<a name="l00396"></a>00396         <span class="keywordtype">double</span> delta=delta_message.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a68fc50f5690a03a88566b02fa9757f17">inf_norm</a>();
<a name="l00397"></a>00397         <a class="code" href="classmmn__lbp__solver.html#acdae1d562af4c68ac0967da0d05c274c" title="Max change in any message value over this iteration.">max_delta_</a> = vcl_max(<a class="code" href="classmmn__lbp__solver.html#acdae1d562af4c68ac0967da0d05c274c" title="Max change in any message value over this iteration.">max_delta_</a>,delta);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         ++neighIter;
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401 }
<a name="l00402"></a>00402 
<a name="l00403"></a><a class="code" href="classmmn__lbp__solver.html#acea975839c9b65d40d86935b477e0211">00403</a> <span class="keywordtype">void</span> <a class="code" href="classmmn__lbp__solver.html#acea975839c9b65d40d86935b477e0211" title="Renormalise messages (assume they represent log probabilities) so SUM(exp) over target states is 1...">mmn_lbp_solver::renormalise_log</a>(<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double &gt;</a>&amp; logMessageVec)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double &gt;::iterator</a> stateIter=logMessageVec.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#ade1c94ab8d54075269ef09d38e38b33b">begin</a>();
<a name="l00406"></a>00406     <a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector&lt;double &gt;::iterator</a> stateIterEnd=logMessageVec.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a49d0ea4f1e8825378c8adfec7de3c863">end</a>();
<a name="l00407"></a>00407     <span class="keywordtype">double</span> probSum=0.0;
<a name="l00408"></a>00408     <span class="keywordflow">while</span> (stateIter != stateIterEnd)
<a name="l00409"></a>00409     {
<a name="l00410"></a>00410         probSum+=vcl_exp(*stateIter);
<a name="l00411"></a>00411         ++stateIter;
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414     <span class="comment">//normalise so probabilities sum to 1</span>
<a name="l00415"></a>00415     <span class="keywordtype">double</span> alpha = 1.0/probSum;
<a name="l00416"></a>00416     <span class="comment">//But now rather than multiplying by alpha, add log(alpha);</span>
<a name="l00417"></a>00417     <span class="keywordtype">double</span> logAlpha=vcl_log(alpha);
<a name="l00418"></a>00418     vcl_transform(logMessageVec.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#ade1c94ab8d54075269ef09d38e38b33b">begin</a>(),logMessageVec.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#a49d0ea4f1e8825378c8adfec7de3c863">end</a>(),
<a name="l00419"></a>00419                   logMessageVec.<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html#ade1c94ab8d54075269ef09d38e38b33b">begin</a>(),
<a name="l00420"></a>00420                   vcl_bind2nd(vcl_plus&lt;double&gt;(),logAlpha));
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00423"></a><a class="code" href="classmmn__lbp__solver.html#a9e576e112f0a4f91e942918fd3ac7466">00423</a> <span class="keywordtype">bool</span> <a class="code" href="classmmn__lbp__solver.html#a9e576e112f0a4f91e942918fd3ac7466" title="Check if we carry on.">mmn_lbp_solver::continue_propagation</a>(vcl_vector&lt;unsigned&gt;&amp; x)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425     ++<a class="code" href="classmmn__lbp__solver.html#a16e101a532ab14a828ac581c661b4db3" title="Current iteration count.">count_</a>;
<a name="l00426"></a>00426     <span class="keywordtype">bool</span> retstate=<span class="keyword">true</span>;
<a name="l00427"></a>00427     <span class="keywordflow">if</span> (max_delta_&lt;epsilon_ || count_&gt;<a class="code" href="classmmn__lbp__solver.html#a9c5627ab3c4bacb6a3a4ded7e9db9e42" title="max number of iterations allowed.">max_iterations_</a>)
<a name="l00428"></a>00428     {
<a name="l00429"></a>00429         <span class="comment">//Terminate on either convergence or max iteration count reached</span>
<a name="l00430"></a>00430         retstate = <span class="keyword">false</span>;
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#a16e101a532ab14a828ac581c661b4db3" title="Current iteration count.">count_</a> &lt; <a class="code" href="classmmn__lbp__solver.html#af03c2da9ba17fda31fc1fde642714482" title="min number of iterations before checking for solution looping (cycling).">min_simple_iterations_</a>)
<a name="l00433"></a>00433     {
<a name="l00434"></a>00434         <span class="comment">//always do at least this many if not converged in delta</span>
<a name="l00435"></a>00435         retstate = <span class="keyword">true</span>;
<a name="l00436"></a>00436     }
<a name="l00437"></a>00437     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#a4a483e4a5a285b2d1458b6a704e7c4e4" title="Number of times cycling has been detected.">cycle_detection_count_</a>&lt;2 &amp;&amp;
<a name="l00438"></a>00438              vcl_count_if(<a class="code" href="classmmn__lbp__solver.html#a62ccc1763e88d8bd018e2f1e592f0165" title="previous max_delta values(used to check still descending).">max_delta_history_</a>.begin(),<a class="code" href="classmmn__lbp__solver.html#a62ccc1763e88d8bd018e2f1e592f0165" title="previous max_delta values(used to check still descending).">max_delta_history_</a>.end(),
<a name="l00439"></a>00439                           vcl_bind1st(vcl_less&lt;double &gt;(),<a class="code" href="classmmn__lbp__solver.html#acdae1d562af4c68ac0967da0d05c274c" title="Max change in any message value over this iteration.">max_delta_</a>))
<a name="l00440"></a>00440              == <span class="keywordtype">int</span>(<a class="code" href="classmmn__lbp__solver.html#a62ccc1763e88d8bd018e2f1e592f0165" title="previous max_delta values(used to check still descending).">max_delta_history_</a>.size()))
<a name="l00441"></a>00441     {
<a name="l00442"></a>00442         retstate =<span class="keyword">true</span>; <span class="comment">//delta is definitely decreasing so keep going unless we&#39;ve had &gt;2 cycles already</span>
<a name="l00443"></a>00443     }
<a name="l00444"></a>00444     <span class="keywordflow">else</span>
<a name="l00445"></a>00445     {
<a name="l00446"></a>00446         <a class="code" href="classmmn__lbp__solver.html#abd4a639e50968ce7a896d722056ff530" title="cycle condition detected.">isCycling_</a>=<span class="keyword">false</span>;
<a name="l00447"></a>00447         <span class="comment">//Check for cycling condition</span>
<a name="l00448"></a>00448         vcl_deque&lt;vcl_vector&lt;unsigned  &gt; &gt;::iterator finder=vcl_find(<a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.begin(),<a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.end(),x);
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (finder != <a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.end())
<a name="l00450"></a>00450         {
<a name="l00451"></a>00451             ++<a class="code" href="classmmn__lbp__solver.html#a65630a8f96ec17a81ce520d661ea4da4" title="count of number of times a solution in history is revisited.">nrevisits_</a>;
<a name="l00452"></a>00452         }
<a name="l00453"></a>00453         <span class="keywordflow">else</span>
<a name="l00454"></a>00454         {
<a name="l00455"></a>00455             <a class="code" href="classmmn__lbp__solver.html#a65630a8f96ec17a81ce520d661ea4da4" title="count of number of times a solution in history is revisited.">nrevisits_</a>=0;
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457         <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#a65630a8f96ec17a81ce520d661ea4da4" title="count of number of times a solution in history is revisited.">nrevisits_</a>&gt;<a class="code" href="classmmn__lbp__solver.html#a2e170c938a0514ffcd9843b7b95adddc">NCYCLE_DETECT_</a>)
<a name="l00458"></a>00458         {
<a name="l00459"></a>00459             <a class="code" href="classmmn__lbp__solver.html#abd4a639e50968ce7a896d722056ff530" title="cycle condition detected.">isCycling_</a>=<span class="keyword">true</span>;
<a name="l00460"></a>00460             ++<a class="code" href="classmmn__lbp__solver.html#a4a483e4a5a285b2d1458b6a704e7c4e4" title="Number of times cycling has been detected.">cycle_detection_count_</a>;
<a name="l00461"></a>00461             vcl_cout&lt;&lt;<span class="stringliteral">&quot;!!!! Loopy Belief is CYCLING... &quot;</span>&lt;&lt;vcl_endl;
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463         <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#abd4a639e50968ce7a896d722056ff530" title="cycle condition detected.">isCycling_</a>)
<a name="l00464"></a>00464         {
<a name="l00465"></a>00465             <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#a4a483e4a5a285b2d1458b6a704e7c4e4" title="Number of times cycling has been detected.">cycle_detection_count_</a>==1)
<a name="l00466"></a>00466             {
<a name="l00467"></a>00467                 vcl_vector&lt;unsigned &gt; xdummy=x;
<a name="l00468"></a>00468                 <a class="code" href="classmmn__lbp__solver.html#a1dfecc7152018d98a8d45b4c4e541657" title="solution value when cycling first detected.">zbest_on_cycle_detection_</a>=<a class="code" href="classmmn__lbp__solver.html#a2f01e6dcd8d26f9a1053d8439de51141">best_solution_cost_in_history</a>(xdummy);
<a name="l00469"></a>00469             }
<a name="l00470"></a>00470             <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#a9489ee1dbf2e2479741b5b0bdd3c1812" title="should message update be smoothed during cycling.">smooth_on_cycling_</a> &amp;&amp; <a class="code" href="classmmn__lbp__solver.html#a4a483e4a5a285b2d1458b6a704e7c4e4" title="Number of times cycling has been detected.">cycle_detection_count_</a>&lt;<a class="code" href="classmmn__lbp__solver.html#abf17e8cf5def593a58d07c5d3ea1ae2e">max_cycle_detection_count_</a>)
<a name="l00471"></a>00471             {
<a name="l00472"></a>00472                 <a class="code" href="classmmn__lbp__solver.html#a65630a8f96ec17a81ce520d661ea4da4" title="count of number of times a solution in history is revisited.">nrevisits_</a>=0;
<a name="l00473"></a>00473                 vcl_cout&lt;&lt;<span class="stringliteral">&quot;Initiating message alpha smoothing to try and break cycling...&quot;</span>&lt;&lt;vcl_endl;
<a name="l00474"></a>00474                 <a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.clear();
<a name="l00475"></a>00475             }
<a name="l00476"></a>00476             <span class="keywordflow">else</span>
<a name="l00477"></a>00477             {
<a name="l00478"></a>00478                 vcl_cout&lt;&lt;<span class="stringliteral">&quot;Abort and pick best solution in history.&quot;</span>&lt;&lt;vcl_endl;
<a name="l00479"></a>00479                 retstate= <span class="keyword">false</span>;
<a name="l00480"></a>00480             }
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482     }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <a class="code" href="classmmn__lbp__solver.html#a62ccc1763e88d8bd018e2f1e592f0165" title="previous max_delta values(used to check still descending).">max_delta_history_</a>.push_back(<a class="code" href="classmmn__lbp__solver.html#acdae1d562af4c68ac0967da0d05c274c" title="Max change in any message value over this iteration.">max_delta_</a>);
<a name="l00485"></a>00485     <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#a62ccc1763e88d8bd018e2f1e592f0165" title="previous max_delta values(used to check still descending).">max_delta_history_</a>.size()&gt;<a class="code" href="classmmn__lbp__solver.html#a9c03c76e6033bc5d2665dff1c120f220" title="Magic numbers for cycle detection.">NHISTORY_</a>)
<a name="l00486"></a>00486     {
<a name="l00487"></a>00487         <a class="code" href="classmmn__lbp__solver.html#a62ccc1763e88d8bd018e2f1e592f0165" title="previous max_delta values(used to check still descending).">max_delta_history_</a>.pop_front();
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489     <a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.push_back(x);
<a name="l00490"></a>00490     <span class="keywordflow">if</span> (<a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.size()&gt;<a class="code" href="classmmn__lbp__solver.html#a9c03c76e6033bc5d2665dff1c120f220" title="Magic numbers for cycle detection.">NHISTORY_</a>)
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492         <a class="code" href="classmmn__lbp__solver.html#a9eb5f49b251628b844a053ddb2398d75" title="previous N solutions (used to trap cycling).">soln_history_</a>.pop_front();
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="keywordflow">return</span> retstate;
<a name="l00496"></a>00496 }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="comment">//=======================================================================</span>
<a name="l00500"></a>00500 <span class="comment">// Method: set_from_stream</span>
<a name="l00501"></a>00501 <span class="comment">//=======================================================================</span>
<a name="l00502"></a>00502 <span class="comment">//: Initialise from a string stream</span>
<a name="l00503"></a><a class="code" href="classmmn__lbp__solver.html#aa0f9559e6fd855d7b13f399d948b93d4">00503</a> <span class="keywordtype">bool</span> <a class="code" href="classmmn__lbp__solver.html#aa0f9559e6fd855d7b13f399d948b93d4" title="Initialise from a text stream.">mmn_lbp_solver::set_from_stream</a>(vcl_istream &amp;is)
<a name="l00504"></a>00504 {
<a name="l00505"></a>00505   <span class="comment">// Cycle through stream and produce a map of properties</span>
<a name="l00506"></a>00506   vcl_string s = <a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/mbl__parse__block_8cxx.html#a684a27aaae999af03348b00248263e80">mbl_parse_block</a>(is);
<a name="l00507"></a>00507   vcl_istringstream ss(s);
<a name="l00508"></a>00508   <a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/classmbl__read__props__type.html">mbl_read_props_type</a> props = <a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/mbl__read__props_8cxx.html#ab92bddc7c08bdfd06700a567c9dbb127">mbl_read_props_ws</a>(ss);
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="comment">// No properties expected.</span>
<a name="l00511"></a>00511 
<a name="l00512"></a>00512   <span class="comment">// Check for unused props</span>
<a name="l00513"></a>00513   <a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/mbl__read__props_8cxx.html#ac7721a95b8e94481944044ac28561884">mbl_read_props_look_for_unused_props</a>(
<a name="l00514"></a>00514       <span class="stringliteral">&quot;mmn_lbp_solver::set_from_stream&quot;</span>, props, <a class="codeRef" doxygen="contrib_mul_mbl.tag:../../../../contrib/mul/mbl/html" href="../../../../contrib/mul/mbl/html/classmbl__read__props__type.html">mbl_read_props_type</a>());
<a name="l00515"></a>00515   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00516"></a>00516 }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="comment">//=======================================================================</span>
<a name="l00520"></a>00520 <span class="comment">// Method: version_no</span>
<a name="l00521"></a>00521 <span class="comment">//=======================================================================</span>
<a name="l00522"></a>00522 
<a name="l00523"></a><a class="code" href="classmmn__lbp__solver.html#a130862fd157c63eb3fc6f7dc3e8d2c57">00523</a> <span class="keywordtype">short</span> <a class="code" href="classmmn__lbp__solver.html#a130862fd157c63eb3fc6f7dc3e8d2c57" title="Version number for I/O.">mmn_lbp_solver::version_no</a>()<span class="keyword"> const</span>
<a name="l00524"></a>00524 <span class="keyword"></span>{
<a name="l00525"></a>00525   <span class="keywordflow">return</span> 1;
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="comment">//=======================================================================</span>
<a name="l00529"></a>00529 <span class="comment">// Method: is_a</span>
<a name="l00530"></a>00530 <span class="comment">//=======================================================================</span>
<a name="l00531"></a>00531 
<a name="l00532"></a><a class="code" href="classmmn__lbp__solver.html#affc8785adb1764eaaebfb507c1cb31f5">00532</a> vcl_string <a class="code" href="classmmn__lbp__solver.html#affc8785adb1764eaaebfb507c1cb31f5" title="Name of the class.">mmn_lbp_solver::is_a</a>()<span class="keyword"> const</span>
<a name="l00533"></a>00533 <span class="keyword"></span>{
<a name="l00534"></a>00534   <span class="keywordflow">return</span> vcl_string(<span class="stringliteral">&quot;mmn_lbp_solver&quot;</span>);
<a name="l00535"></a>00535 }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537 <span class="comment">//: Create a copy on the heap and return base class pointer</span>
<a name="l00538"></a><a class="code" href="classmmn__lbp__solver.html#ae7e34dc34d0014a9d1ab7394474b34be">00538</a> <a class="code" href="classmmn__solver.html" title="Base for classes which solve Markov Random Field problems.">mmn_solver</a>* <a class="code" href="classmmn__lbp__solver.html#ae7e34dc34d0014a9d1ab7394474b34be" title="Create a copy on the heap and return base class pointer.">mmn_lbp_solver::clone</a>()<span class="keyword"> const</span>
<a name="l00539"></a>00539 <span class="keyword"></span>{
<a name="l00540"></a>00540   <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classmmn__lbp__solver.html#af1a47bc70af4d548026fb693873a4d65" title="Default constructor.">mmn_lbp_solver</a>(*<span class="keyword">this</span>);
<a name="l00541"></a>00541 }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="comment">//=======================================================================</span>
<a name="l00544"></a>00544 <span class="comment">// Method: print</span>
<a name="l00545"></a>00545 <span class="comment">//=======================================================================</span>
<a name="l00546"></a>00546 
<a name="l00547"></a><a class="code" href="classmmn__lbp__solver.html#a874e107ba3f1e33c24d3af90429a0f15">00547</a> <span class="keywordtype">void</span> <a class="code" href="classmmn__lbp__solver.html#a874e107ba3f1e33c24d3af90429a0f15" title="Print class to os.">mmn_lbp_solver::print_summary</a>(vcl_ostream&amp; os)<span class="keyword"> const</span>
<a name="l00548"></a>00548 <span class="keyword"></span>{
<a name="l00549"></a>00549     os&lt;&lt;<span class="stringliteral">&quot;This is a &quot;</span>&lt;&lt;<a class="code" href="classmmn__lbp__solver.html#affc8785adb1764eaaebfb507c1cb31f5" title="Name of the class.">is_a</a>()&lt;&lt;<span class="charliteral">&#39;\t&#39;</span>&lt;&lt;<span class="stringliteral">&quot;with &quot;</span>&lt;&lt;<a class="code" href="classmmn__lbp__solver.html#acf9ae29c374f81c0614be42cd6ce3234" title="Total number of nodes.">nnodes_</a>&lt;&lt;<span class="stringliteral">&quot; nodes&quot;</span>&lt;&lt;vcl_endl;
<a name="l00550"></a>00550 }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="comment">//=======================================================================</span>
<a name="l00553"></a>00553 <span class="comment">// Method: save</span>
<a name="l00554"></a>00554 <span class="comment">//=======================================================================</span>
<a name="l00555"></a>00555 
<a name="l00556"></a><a class="code" href="classmmn__lbp__solver.html#a5197fa1127e16858f43ad375837bd7ec">00556</a> <span class="keywordtype">void</span> <a class="code" href="classmmn__lbp__solver.html#a5197fa1127e16858f43ad375837bd7ec" title="Save class to binary file stream.">mmn_lbp_solver::b_write</a>(<a class="codeRef" doxygen="core_vsl.tag:../../../../core/vsl/html" href="../../../../core/vsl/html/classvsl__b__ostream.html">vsl_b_ostream</a>&amp; bfs)<span class="keyword"> const</span>
<a name="l00557"></a>00557 <span class="keyword"></span>{
<a name="l00558"></a>00558   <a class="code" href="mmn__arc_8h.html#a7b69c0be59781c9fe5dcd31008fa9726">vsl_b_write</a>(bfs,<a class="code" href="classmmn__lbp__solver.html#a130862fd157c63eb3fc6f7dc3e8d2c57" title="Version number for I/O.">version_no</a>());
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="comment">//=======================================================================</span>
<a name="l00562"></a>00562 <span class="comment">// Method: load</span>
<a name="l00563"></a>00563 <span class="comment">//=======================================================================</span>
<a name="l00564"></a>00564 
<a name="l00565"></a><a class="code" href="classmmn__lbp__solver.html#a9ef5dc84aaf6311af2a42daa0d59e0d8">00565</a> <span class="keywordtype">void</span> <a class="code" href="classmmn__lbp__solver.html#a9ef5dc84aaf6311af2a42daa0d59e0d8" title="Load class from binary file stream.">mmn_lbp_solver::b_read</a>(<a class="codeRef" doxygen="core_vsl.tag:../../../../core/vsl/html" href="../../../../core/vsl/html/classvsl__b__istream.html">vsl_b_istream</a>&amp; bfs)
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567   <span class="keywordflow">if</span> (!bfs) <span class="keywordflow">return</span>;
<a name="l00568"></a>00568   <span class="keywordtype">short</span> version;
<a name="l00569"></a>00569   <a class="code" href="mmn__arc_8h.html#a97248c2b37c6c403056bd64905f182e1">vsl_b_read</a>(bfs,version);
<a name="l00570"></a>00570   <span class="keywordflow">switch</span> (version)
<a name="l00571"></a>00571   {
<a name="l00572"></a>00572     <span class="keywordflow">case</span> (1):
<a name="l00573"></a>00573       <span class="keywordflow">break</span>;
<a name="l00574"></a>00574     <span class="keywordflow">default</span>:
<a name="l00575"></a>00575       vcl_cerr &lt;&lt; <span class="stringliteral">&quot;I/O ERROR: vsl_b_read(vsl_b_istream&amp;)\n&quot;</span>
<a name="l00576"></a>00576                &lt;&lt; <span class="stringliteral">&quot;           Unknown version number &quot;</span>&lt;&lt; version &lt;&lt; vcl_endl;
<a name="l00577"></a>00577       bfs.<a class="codeRef" doxygen="core_vsl.tag:../../../../core/vsl/html" href="../../../../core/vsl/html/classvsl__b__istream.html#a413bd96d4f02499d101f7e4f3724f051">is</a>().clear(vcl_ios::badbit); <span class="comment">// Set an unrecoverable IO error on stream</span>
<a name="l00578"></a>00578       <span class="keywordflow">return</span>;
<a name="l00579"></a>00579   }
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:34:38 for contrib/mul/mmn by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
