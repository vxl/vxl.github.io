<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>vil3d : 3D image library</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">vil3d : 3D image library </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>A set of classes to represent and manipulate 3D images</p>
<p>The core class is vil3d_image_view&lt;T&gt; which gives a view of an image in memory. The only way to get at the pixel data in an image is through a vil3d_image_view&lt;T&gt;.</p>
<p>The vil3d_image_view&lt;T&gt; represents a view of a multi-plane image of given type. A pointer is stored to the top-left pixel in the first plane of the image (top_left_ptr()) and integers indicating how to get to neighbours in the i (istep()), j (jstep()), k (kstep()) and plane (planestep()) directions.</p>
<p>Since the vil3d_image_view&lt;T&gt; is a `view' of the actual image data, copying one only copies the `view', not the image data itself - you get two views looking at the same chunk of memory. Some cunning smart pointer stuff is used to ensure that the actual data remains as long as a valid view is looking at it. (Note that this may not always be the case, since the view can be of a chunk of memory that the view does not have direct control of, such as a video buffer). This view copying will work between different types of view if it is possible to reconfigure the view very cheaply. If you wish to copy the image data itself, then use the vil3d_copy_deep(src_im) function. This copies the raw data into a newly created space, and returns a new view of it. Alternatively, use the method dest_im.deep_copy(src_im), or the function vil3d_copy_reformat(src_im, dest_im).</p>
<p>Example of loading, copying then processing: </p>
<div class="fragment"><pre class="fragment">
vil3d_image_view&lt;vxl_byte&gt; image;
image = vil3d_load("test_image.jpg");
vil3d_image_view&lt;vxl_byte&gt; image2 = vil3d_copy_deep(image);
my_invert_image(image2);
vil3d_save(image2,"output_image.jpg");
</pre></div><p>Example of creating an image in memory </p>
<div class="fragment"><pre class="fragment">
unsigned ni=256;
unsigned nj=256;
unsigned nk=256;
unsigned nplanes=3;
vil3d_image_view&lt;vxl_byte&gt; image(ni,nj,nk,nplanes);
for (unsigned p=0;p&lt;nplanes;++p)
  for (unsigned k=0;k&lt;nk;++k)
    for (unsigned j=0;j&lt;nj;++j)
      for (unsigned i=0;i&lt;ni;++i)
        image(i,j,k,p) = vxl_byte(i+j+k+p);
</pre></div><p>Example of creating an image in memory, using pointer arithmetic </p>
<div class="fragment"><pre class="fragment">
  unsigned ni=256;
  unsigned nj=256;
  unsigned nk=256;
  unsigned nplanes=3;
  vil3d_image_view&lt;vxl_byte&gt; image(ni,nj,nk,nplanes);
  vxl_byte* plane = image.top_left_ptr();
  for (unsigned p=0;p&lt;nplanes;++p,plane += image.planestep())
  {
    vxl_byte* slice = plane;
    for (unsigned k=0;k&lt;nk;++k,slice += image.kstep())
    {
      vxl_byte* row = slice;
      for (unsigned j=0;j&lt;nj;++j,row += image.jstep())
      {
        vxl_byte* pixel = row;
        for (unsigned i=0;i&lt;ni;++i,pixel+=image.istep())
          *pixel = vxl_byte(i+10*j+3*k+100*p);
      }
    }
  }
</pre></div><p>When one resizes (using set_size) a vil3d_image_view&lt;T&gt; the view disconnects from the data (which may then be deleted if no other views are connected), allocates a new chunk of memory for the new image and sets the view to look at it.</p>
<p>Note that if the set_size does not change the image size, then nothing is done and the view remains unchanged.</p>
<p>There are a variety of ways one can view the same data, allowing one to appear to change the data simply by changing ones view of it.</p>
<p>For instance,</p>
<ul>
<li>vil3d_crop : Create sub-image</li>
<li>vil3d_plane : Get plane of image</li>
<li>vil3d_slice_ij : Get 2D image which is a slice in i-j of a 3D image</li>
<li>vil3d_slice_jk : Get 2D image which is a slice in j-k of a 3D image</li>
<li>vil3d_slice_ki : Get 2D image which is a slice in k-i of a 3D image</li>
<li>(see also vil3d_slice_ji,vil3d_slice_kj,vil3d_slice_ik)</li>
</ul>
<p>A variety of useful functions are provided:</p>
<ul>
<li>vil3d_threshold_above(src_im,dest_im,t)</li>
<li>vil3d_threshold_below(src_im,dest_im,t)</li>
<li>vil3d_threshold_inside(src_im,dest_im,tlo,thi)</li>
<li>vil3d_threshold_outside(src_im,dest_im,tlo,thi)</li>
<li>vil3d_grad_1x3(...) : Compute gradients in 3D using (-1 0 1) filter</li>
<li>vil3d_grad_3x3x3 : Compute gradients using Sobel like 3x3x3 filter</li>
<li>vil3d_smooth_121 : Smooth using 1-2-1 shape filter</li>
<li>vil3d_quad_distance_function : Cunning square distance filtering</li>
<li>vil3d_distance_function : Efficient distance function computation</li>
</ul>
<p>Morphological functions (using <a class="el" href="classvil3d__structuring__element.html" title="Structuring element for morphology represented as a list of non-zero pixels.">vil3d_structuring_element</a>)</p>
<ul>
<li>vil3d_binary_erode</li>
<li>vil3d_binary_dilate</li>
<li>vil3d_binary_opening</li>
<li>vil3d_binary_closing </li>
</ul>
</div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:34:07 for contrib/mul/vil3d by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
