<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>msm_aligner Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">msm_aligner Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="msm_aligner" -->
<p>Base for functions which calculate and apply 2D transformations.  
 <a href="classmsm__aligner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="msm__aligner_8h_source.html">msm_aligner.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for msm_aligner:</div>
<div class="dyncontent">
<div class="center"><img src="classmsm__aligner__inherit__graph.png" border="0" usemap="#msm__aligner_inherit__map" alt="Inheritance graph"/></div>
<map name="msm__aligner_inherit__map" id="msm__aligner_inherit__map">
<area shape="rect" href="classmsm__similarity__aligner.html" title="Calculate and apply 2D similarity transformations." alt="" coords="5,81,163,105"/><area shape="rect" href="classmsm__translation__aligner.html" title="Calculate and apply 2D translations." alt="" coords="187,81,352,105"/><area shape="rect" href="classmsm__zoom__aligner.html" title="Calculate and apply translation + scale transform." alt="" coords="376,81,515,105"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classmsm__aligner-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a81d939c80837b46548eb74b44bf78439">~msm_aligner</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#ad3af92dd9497984b3f47c687d5be72ec">size</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of parameters defining the transformation.  <a href="#ad3af92dd9497984b3f47c687d5be72ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#aa27dd14540db72c9799731b28e016cca">inverse</a> (const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute parameters for inverse transformation.  <a href="#aa27dd14540db72c9799731b28e016cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#aecc3bdc07a3a8fd48bffd189338dd2ea">apply_transform</a> (const <a class="el" href="classmsm__points.html">msm_points</a> &amp;points, const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;trans, <a class="el" href="classmsm__points.html">msm_points</a> &amp;new_points) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the transformation to the given points.  <a href="#aecc3bdc07a3a8fd48bffd189338dd2ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#ad8b95e3a1c91dabf44e6860cd1c9ae4e">scale</a> (const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;trans) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return scaling applied by the transform with given parameters.  <a href="#ad8b95e3a1c91dabf44e6860cd1c9ae4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#ae6715e2868491f93ee98064bd31e4ac6">calc_transform_from_ref</a> (const <a class="el" href="classmsm__points.html">msm_points</a> &amp;ref_points, const <a class="el" href="classmsm__points.html">msm_points</a> &amp;points2, <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;trans) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate parameter which best map ref_points to points2.  <a href="#ae6715e2868491f93ee98064bd31e4ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a7f82040220e4e362fbfbff32a92c8192">calc_transform</a> (const <a class="el" href="classmsm__points.html">msm_points</a> &amp;points1, const <a class="el" href="classmsm__points.html">msm_points</a> &amp;points2, <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;trans) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate parameter which best map points1 to points2.  <a href="#a7f82040220e4e362fbfbff32a92c8192"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#ac8bf076c6118d36bd7da3e9cb4793dfc">calc_transform_wt</a> (const <a class="el" href="classmsm__points.html">msm_points</a> &amp;points1, const <a class="el" href="classmsm__points.html">msm_points</a> &amp;points2, const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;wts, <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;trans) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate parameters which map points1 to points2 allowing for weights.  <a href="#ac8bf076c6118d36bd7da3e9cb4793dfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#ab1d7e9de9bf882cd8085c8b56be8670b">calc_transform_wt_mat</a> (const <a class="el" href="classmsm__points.html">msm_points</a> &amp;points1, const <a class="el" href="classmsm__points.html">msm_points</a> &amp;points2, const vcl_vector&lt; <a class="el" href="classmsm__wt__mat__2d.html">msm_wt_mat_2d</a> &gt; &amp;wt_mat, <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;trans) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate parameters which map points allowing for anisotropic wts.  <a href="#ab1d7e9de9bf882cd8085c8b56be8670b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a71b60d964f3f66c4eb9d234be4c25b75">transform_wt_mat</a> (const vcl_vector&lt; <a class="el" href="classmsm__wt__mat__2d.html">msm_wt_mat_2d</a> &gt; &amp;wt_mat, const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;trans, vcl_vector&lt; <a class="el" href="classmsm__wt__mat__2d.html">msm_wt_mat_2d</a> &gt; &amp;new_wt_mat) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transform to weight matrices (ie ignore translation component).  <a href="#a71b60d964f3f66c4eb9d234be4c25b75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a27555df66f4584caa227c46bcdf8d706">compose</a> (const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;pose1, const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;pose2) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns params of pose such that pose(x) = pose1(pose2(x)).  <a href="#a27555df66f4584caa227c46bcdf8d706"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a0505f19e4191504601aa66e4968aede6">normalise_shape</a> (<a class="el" href="classmsm__points.html">msm_points</a> &amp;points) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transform to generate points in some reference frame.  <a href="#a0505f19e4191504601aa66e4968aede6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#af816f250bddc44f0c2feae2c10bcc90a">align_set</a> (const vcl_vector&lt; <a class="el" href="classmsm__points.html">msm_points</a> &gt; &amp;points, <a class="el" href="classmsm__points.html">msm_points</a> &amp;ref_mean_shape, vcl_vector&lt; <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &gt; &amp;pose_to_ref, <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;average_pose) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find poses which align a set of points.  <a href="#af816f250bddc44f0c2feae2c10bcc90a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a9a3e923736e94516530d0ed07c25cd0d">mean_of_transformed</a> (const vcl_vector&lt; <a class="el" href="classmsm__points.html">msm_points</a> &gt; &amp;points, const vcl_vector&lt; <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &gt; &amp;pose, <a class="el" href="classmsm__points.html">msm_points</a> &amp;mean) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mean of points[i] after transforming with pose[i].  <a href="#a9a3e923736e94516530d0ed07c25cd0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual vcl_string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a71483608cda51798ae559a85df85edb8">is_a</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the class.  <a href="#a71483608cda51798ae559a85df85edb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmsm__aligner.html">msm_aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#afb2a7ec73b12c4c322e433f6f69d12c9">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy on the heap and return base class pointer.  <a href="#afb2a7ec73b12c4c322e433f6f69d12c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a27e54f25b4b620dc885dc15291aaad4e">print_summary</a> (vcl_ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print class to os.  <a href="#a27e54f25b4b620dc885dc15291aaad4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a1754d2baa79ff6937d102da4aa326fd8">b_write</a> (<a class="elRef" doxygen="core_vsl.tag:../../../../core/vsl/html" href="../../../../core/vsl/html/classvsl__b__ostream.html">vsl_b_ostream</a> &amp;bfs) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save class to binary file stream.  <a href="#a1754d2baa79ff6937d102da4aa326fd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a9bcb2ed4f64a090e4bca86fe0152c5c6">b_read</a> (<a class="elRef" doxygen="core_vsl.tag:../../../../core/vsl/html" href="../../../../core/vsl/html/classvsl__b__istream.html">vsl_b_istream</a> &amp;bfs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load class from binary file stream.  <a href="#a9bcb2ed4f64a090e4bca86fe0152c5c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a915e596e59b3cd7aed55c902c6240f79">config_from_stream</a> (vcl_istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise from a text stream.  <a href="#a915e596e59b3cd7aed55c902c6240f79"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static vcl_auto_ptr&lt; <a class="el" href="classmsm__aligner.html">msm_aligner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsm__aligner.html#a8bfbd287e0401e74330ab791f231890b">create_from_stream</a> (vcl_istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a concrete msm_aligner-derived object, from a text specification.  <a href="#a8bfbd287e0401e74330ab791f231890b"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Base for functions which calculate and apply 2D transformations. </p>
<p>Derived classes represent transformations, eg translation, similarity, affine. The parameters of the transformation are stored in a vector, arranged so that the zero vector corresponds to the identity transformation. Each class contains functions to apply the transformation, invert it and to estimate the best transform parameters to map one set of points to another. </p>

<p>Definition at line <a class="el" href="msm__aligner_8h_source.html#l00025">25</a> of file <a class="el" href="msm__aligner_8h_source.html">msm_aligner.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a81d939c80837b46548eb74b44bf78439"></a><!-- doxytag: member="msm_aligner::~msm_aligner" ref="a81d939c80837b46548eb74b44bf78439" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual msm_aligner::~msm_aligner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="msm__aligner_8h_source.html#l00029">29</a> of file <a class="el" href="msm__aligner_8h_source.html">msm_aligner.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af816f250bddc44f0c2feae2c10bcc90a"></a><!-- doxytag: member="msm_aligner::align_set" ref="af816f250bddc44f0c2feae2c10bcc90a" args="(const vcl_vector&lt; msm_points &gt; &amp;points, msm_points &amp;ref_mean_shape, vcl_vector&lt; vnl_vector&lt; double &gt; &gt; &amp;pose_to_ref, vnl_vector&lt; double &gt; &amp;average_pose) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void msm_aligner::align_set </td>
          <td>(</td>
          <td class="paramtype">const vcl_vector&lt; <a class="el" href="classmsm__points.html">msm_points</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>ref_mean_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose_to_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>average_pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find poses which align a set of points. </p>
<p>On exit ref_mean_shape is the mean shape in the reference frame, pose_to_ref[i] maps points[i] into the reference frame (ie pose is the mapping from the reference frame to the target frames). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">average_pose</td><td>Some estimate of the average mapping </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#a8ec8f99f1a8ec5acb278819741a10249">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#ac7a9b05296c42202399d68f773957fb4">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#aca3a7864464613f58bdfd21a22d703b1">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="aecc3bdc07a3a8fd48bffd189338dd2ea"></a><!-- doxytag: member="msm_aligner::apply_transform" ref="aecc3bdc07a3a8fd48bffd189338dd2ea" args="(const msm_points &amp;points, const vnl_vector&lt; double &gt; &amp;trans, msm_points &amp;new_points) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void msm_aligner::apply_transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the transformation to the given points. </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#afcd89e96f7cb5cded561585f258c72fb">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#ac3cdea3cdf10f089e97d60437dd45b95">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a46e2315bd596ab8cf44d117043faf8f7">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a9bcb2ed4f64a090e4bca86fe0152c5c6"></a><!-- doxytag: member="msm_aligner::b_read" ref="a9bcb2ed4f64a090e4bca86fe0152c5c6" args="(vsl_b_istream &amp;bfs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msm_aligner::b_read </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="core_vsl.tag:../../../../core/vsl/html" href="../../../../core/vsl/html/classvsl__b__istream.html">vsl_b_istream</a> &amp;&#160;</td>
          <td class="paramname"><em>bfs</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load class from binary file stream. </p>

<p>Definition at line <a class="el" href="msm__aligner_8cxx_source.html#l00046">46</a> of file <a class="el" href="msm__aligner_8cxx_source.html">msm_aligner.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1754d2baa79ff6937d102da4aa326fd8"></a><!-- doxytag: member="msm_aligner::b_write" ref="a1754d2baa79ff6937d102da4aa326fd8" args="(vsl_b_ostream &amp;bfs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msm_aligner::b_write </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="core_vsl.tag:../../../../core/vsl/html" href="../../../../core/vsl/html/classvsl__b__ostream.html">vsl_b_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>bfs</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save class to binary file stream. </p>

<p>Definition at line <a class="el" href="msm__aligner_8cxx_source.html#l00039">39</a> of file <a class="el" href="msm__aligner_8cxx_source.html">msm_aligner.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a7f82040220e4e362fbfbff32a92c8192"></a><!-- doxytag: member="msm_aligner::calc_transform" ref="a7f82040220e4e362fbfbff32a92c8192" args="(const msm_points &amp;points1, const msm_points &amp;points2, vnl_vector&lt; double &gt; &amp;trans) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void msm_aligner::calc_transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate parameter which best map points1 to points2. </p>
<p>Minimises ||points2-T(points1)||^2 </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#ad92995ea5f2651de989840cea8af0897">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a3c95f98c38fda51df0648240db725385">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a396cb131a48bd85fb42e39250c224790">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="ae6715e2868491f93ee98064bd31e4ac6"></a><!-- doxytag: member="msm_aligner::calc_transform_from_ref" ref="ae6715e2868491f93ee98064bd31e4ac6" args="(const msm_points &amp;ref_points, const msm_points &amp;points2, vnl_vector&lt; double &gt; &amp;trans) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void msm_aligner::calc_transform_from_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>ref_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate parameter which best map ref_points to points2. </p>
<p>Minimises ||points2-T(ref_points)||^2. Takes advantage of assumed properties of ref_points (eg CoG=origin, unit size etc) to perform efficiently.</p>
<p>When used with a shape model of form ref_points+Pb, where the modes P have certain orthogonality properties with respect to the ref shape, this can give the optimal transformation into a tangent plane, independent of the current parameters. In this case a one-shot method can be used to compute the optimal shape and pose parameters, rather than an iterative method which is required where the orthogonality properties do not hold, or where weights are considered. </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#a1b441b4ff53a31b6abc06e8cfdb11605">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a1557a91f1a2937e0d89d45c55c700fa9">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a7c89e87281e8c3cd83e5bd5f09b11cdf">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="ac8bf076c6118d36bd7da3e9cb4793dfc"></a><!-- doxytag: member="msm_aligner::calc_transform_wt" ref="ac8bf076c6118d36bd7da3e9cb4793dfc" args="(const msm_points &amp;points1, const msm_points &amp;points2, const vnl_vector&lt; double &gt; &amp;wts, vnl_vector&lt; double &gt; &amp;trans) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void msm_aligner::calc_transform_wt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate parameters which map points1 to points2 allowing for weights. </p>
<p>Minimises sum of weighted squares error in frame of pts2, ie sum w_i * ||p2_i - T(p1_i)|| </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#ac17eb167e8b7f5b9618f1518d18a103a">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a0eeffc17fdebaa7a8a0f38a9d5788342">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#af952ddeb0e8e51347983656c8e37cf5c">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="ab1d7e9de9bf882cd8085c8b56be8670b"></a><!-- doxytag: member="msm_aligner::calc_transform_wt_mat" ref="ab1d7e9de9bf882cd8085c8b56be8670b" args="(const msm_points &amp;points1, const msm_points &amp;points2, const vcl_vector&lt; msm_wt_mat_2d &gt; &amp;wt_mat, vnl_vector&lt; double &gt; &amp;trans) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void msm_aligner::calc_transform_wt_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vcl_vector&lt; <a class="el" href="classmsm__wt__mat__2d.html">msm_wt_mat_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>wt_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate parameters which map points allowing for anisotropic wts. </p>
<p>Errors on point i are weighted by wt_mat[i] in pts2 frame. ie error is sum (p2_i-T(p1_i)'*wt_mat[i]*(p2_i-T(p1_i) </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#a9c52d328acb6134baf602f06cb0eb2b0">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a88e716c1409911459d1bd95de0df83a3">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#aa332fcc5e88db81f3babf88f49529b16">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="afb2a7ec73b12c4c322e433f6f69d12c9"></a><!-- doxytag: member="msm_aligner::clone" ref="afb2a7ec73b12c4c322e433f6f69d12c9" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmsm__aligner.html">msm_aligner</a>* msm_aligner::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a copy on the heap and return base class pointer. </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#ad70684203e6e933436ef744ba35020fd">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a63dd1d83240765baf4adf93b4b6d3d26">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a9b869037ff29ed1c129f963058ca2e70">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a27555df66f4584caa227c46bcdf8d706"></a><!-- doxytag: member="msm_aligner::compose" ref="a27555df66f4584caa227c46bcdf8d706" args="(const vnl_vector&lt; double &gt; &amp;pose1, const vnl_vector&lt; double &gt; &amp;pose2) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt;double&gt; msm_aligner::compose </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns params of pose such that pose(x) = pose1(pose2(x)). </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#ac168896bfbde1301cb575a9d119a6164">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#ac7cc4bf3405ce1347a23a10b3d86822a">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a5bd716775e6efde35dea6eaf50f6b4da">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a915e596e59b3cd7aed55c902c6240f79"></a><!-- doxytag: member="msm_aligner::config_from_stream" ref="a915e596e59b3cd7aed55c902c6240f79" args="(vcl_istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msm_aligner::config_from_stream </td>
          <td>(</td>
          <td class="paramtype">vcl_istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise from a text stream. </p>
<p>The default implementation is for attribute-less normalisers, and throws if it finds any data in the stream. </p>

<p>Definition at line <a class="el" href="msm__aligner_8cxx_source.html#l00070">70</a> of file <a class="el" href="msm__aligner_8cxx_source.html">msm_aligner.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a8bfbd287e0401e74330ab791f231890b"></a><!-- doxytag: member="msm_aligner::create_from_stream" ref="a8bfbd287e0401e74330ab791f231890b" args="(vcl_istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_auto_ptr&lt; <a class="el" href="classmsm__aligner.html">msm_aligner</a> &gt; msm_aligner::create_from_stream </td>
          <td>(</td>
          <td class="paramtype">vcl_istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a concrete msm_aligner-derived object, from a text specification. </p>

<p>Definition at line <a class="el" href="msm__aligner_8cxx_source.html#l00084">84</a> of file <a class="el" href="msm__aligner_8cxx_source.html">msm_aligner.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa27dd14540db72c9799731b28e016cca"></a><!-- doxytag: member="msm_aligner::inverse" ref="aa27dd14540db72c9799731b28e016cca" args="(const vnl_vector&lt; double &gt; &amp;) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt;double&gt; msm_aligner::inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameters for inverse transformation. </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#a18ebe6480275d4c54baf872c57c4c927">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a379d1264ffbf264dadc16a5310563df7">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a83473fbe524e0521202c3615d81c8275">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a71483608cda51798ae559a85df85edb8"></a><!-- doxytag: member="msm_aligner::is_a" ref="a71483608cda51798ae559a85df85edb8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual vcl_string msm_aligner::is_a </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name of the class. </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#ac648fe19de9f32ca0b96a7510f178c9f">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a39cddfead3da36c9e9f43e455600e969">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a00b4fc064669fe29fd62ec78045deadf">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a9a3e923736e94516530d0ed07c25cd0d"></a><!-- doxytag: member="msm_aligner::mean_of_transformed" ref="a9a3e923736e94516530d0ed07c25cd0d" args="(const vcl_vector&lt; msm_points &gt; &amp;points, const vcl_vector&lt; vnl_vector&lt; double &gt; &gt; &amp;pose, msm_points &amp;mean) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msm_aligner::mean_of_transformed </td>
          <td>(</td>
          <td class="paramtype">const vcl_vector&lt; <a class="el" href="classmsm__points.html">msm_points</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vcl_vector&lt; <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute mean of points[i] after transforming with pose[i]. </p>
<p>Compute mean of points after transforming with pose. </p>

<p>Definition at line <a class="el" href="msm__aligner_8cxx_source.html#l00014">14</a> of file <a class="el" href="msm__aligner_8cxx_source.html">msm_aligner.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a0505f19e4191504601aa66e4968aede6"></a><!-- doxytag: member="msm_aligner::normalise_shape" ref="a0505f19e4191504601aa66e4968aede6" args="(msm_points &amp;points) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void msm_aligner::normalise_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsm__points.html">msm_points</a> &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply transform to generate points in some reference frame. </p>
<p>For instance, depending on transform, may translate so the centre of gravity is at the origin and scale to a unit size. </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#a4fb9aae2d319d4b1cae69ab1b08b6879">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a177195b449adea7bc8d8435251fe9245">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#acf9500368680d9bcf159014e7ea5d220">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a27e54f25b4b620dc885dc15291aaad4e"></a><!-- doxytag: member="msm_aligner::print_summary" ref="a27e54f25b4b620dc885dc15291aaad4e" args="(vcl_ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msm_aligner::print_summary </td>
          <td>(</td>
          <td class="paramtype">vcl_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print class to os. </p>

<p>Definition at line <a class="el" href="msm__aligner_8cxx_source.html#l00031">31</a> of file <a class="el" href="msm__aligner_8cxx_source.html">msm_aligner.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad8b95e3a1c91dabf44e6860cd1c9ae4e"></a><!-- doxytag: member="msm_aligner::scale" ref="ad8b95e3a1c91dabf44e6860cd1c9ae4e" args="(const vnl_vector&lt; double &gt; &amp;trans) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double msm_aligner::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return scaling applied by the transform with given parameters. </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#a88be2b22e70faabef02753cad41e8a0d">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a4b27dd217db6a53a7ae3d312654e4924">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#aa374b71a54b98c36b43a80db26e13e70">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="ad3af92dd9497984b3f47c687d5be72ec"></a><!-- doxytag: member="msm_aligner::size" ref="ad3af92dd9497984b3f47c687d5be72ec" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned msm_aligner::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of parameters defining the transformation. </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#acdf734d0d12a8954035a3106c16b6b50">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a64530faf2474a9174bf5882949741c08">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a990565412e53c8c48d216182aa10f9d2">msm_translation_aligner</a>.</p>

</div>
</div>
<a class="anchor" id="a71b60d964f3f66c4eb9d234be4c25b75"></a><!-- doxytag: member="msm_aligner::transform_wt_mat" ref="a71b60d964f3f66c4eb9d234be4c25b75" args="(const vcl_vector&lt; msm_wt_mat_2d &gt; &amp;wt_mat, const vnl_vector&lt; double &gt; &amp;trans, vcl_vector&lt; msm_wt_mat_2d &gt; &amp;new_wt_mat) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void msm_aligner::transform_wt_mat </td>
          <td>(</td>
          <td class="paramtype">const vcl_vector&lt; <a class="el" href="classmsm__wt__mat__2d.html">msm_wt_mat_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>wt_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classmsm__wt__mat__2d.html">msm_wt_mat_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_wt_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply transform to weight matrices (ie ignore translation component). </p>

<p>Implemented in <a class="el" href="classmsm__similarity__aligner.html#aceb489fbce94628be2aa358f556aff88">msm_similarity_aligner</a>, <a class="el" href="classmsm__zoom__aligner.html#a15870591c340d567ca022bff0c550e6d">msm_zoom_aligner</a>, and <a class="el" href="classmsm__translation__aligner.html#a8bfa233e075517b9186ec56cbc49f447">msm_translation_aligner</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>contrib/mul/msm/<a class="el" href="msm__aligner_8h_source.html">msm_aligner.h</a></li>
<li>contrib/mul/msm/<a class="el" href="msm__aligner_8cxx_source.html">msm_aligner.cxx</a></li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:35:01 for contrib/mul/msm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
