<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>contrib/oxl/osl/osl_edge_detector.cxx Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">contrib/oxl/osl/osl_edge_detector.cxx</div>  </div>
</div>
<div class="contents">
<a href="osl__edge__detector_8cxx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This is oxl/osl/osl_edge_detector.cxx</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include &quot;<a class="code" href="osl__edge__detector_8h.html" title="Charlie&#39;s topological edge detector.">osl_edge_detector.h</a>&quot;</span>
<a name="l00003"></a>00003 <span class="comment">//:</span>
<a name="l00004"></a>00004 <span class="comment">// \file</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;vcl_cmath.h&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;vcl_cstdlib.h&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;vcl_cassert.h&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;vcl_list.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;vcl_iostream.h&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;vcl_algorithm.h&gt;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;<a class="code" href="osl__canny__base_8h.html">osl/osl_canny_base.h</a>&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;<a class="code" href="osl__kernel_8h.html">osl/osl_kernel.h</a>&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;<a class="code" href="osl__canny__smooth_8h.html">osl/osl_canny_smooth.h</a>&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;<a class="code" href="osl__canny__gradient_8h.html">osl/osl_canny_gradient.h</a>&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;<a class="code" href="osl__chamfer_8h.html">osl/osl_chamfer.h</a>&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;<a class="code" href="osl__reorder__chain_8h.html">osl/internals/osl_reorder_chain.h</a>&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__math_8h.html">vnl/vnl_math.h</a>&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a><a class="code" href="osl__edge__detector_8cxx.html#a326e0e8c24ba392f076a5669b2d46db5">00021</a> <span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code" href="osl__canny__rothwell_8cxx.html#a326e0e8c24ba392f076a5669b2d46db5">DUMMYTHETA</a> = 10000.0f;
<a name="l00022"></a><a class="code" href="osl__edge__detector_8cxx.html#a51d0dbc28d8dc4e3c9fa3217f6f9b424">00022</a> <span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code" href="osl__edge__detector_8cxx.html#a51d0dbc28d8dc4e3c9fa3217f6f9b424">ALPHA</a> = 0.9f;
<a name="l00023"></a>00023 
<a name="l00024"></a><a class="code" href="osl__edge__detector_8cxx.html#aef060b3456fdcc093a7210a762d5f2ed">00024</a> <span class="preprocessor">#define FAR 65535</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span>
<a name="l00026"></a><a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">00026</a> <span class="preprocessor">#define Make_float_image(w, h) osl_canny_base_make_raw_image(w, h, (float*)0)</span>
<a name="l00027"></a><a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">00027</a> <span class="preprocessor"></span><span class="preprocessor">#define Make_int_image(w, h) osl_canny_base_make_raw_image(w, h, (int*)0)</span>
<a name="l00028"></a><a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">00028</a> <span class="preprocessor"></span><span class="preprocessor">#define Free_float_image(i,dummy) osl_canny_base_free_raw_image(i)</span>
<a name="l00029"></a><a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">00029</a> <span class="preprocessor"></span><span class="preprocessor">#define Free_int_image(i,dummy) osl_canny_base_free_raw_image(i)</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="comment">//-----------------------------------------------------------------------</span>
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="structosl__edge__detector.html#a87e8c196aaf20be0bc780964f4cefab5">00033</a> <a class="code" href="structosl__edge__detector.html#a87e8c196aaf20be0bc780964f4cefab5">osl_edge_detector::osl_edge_detector</a>(<a class="code" href="classosl__edge__detector__params.html">osl_edge_detector_params</a> <span class="keyword">const</span> &amp;params)
<a name="l00034"></a>00034   : <a class="code" href="classosl__edge__detector__params.html">osl_edge_detector_params</a>(params)
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036   <span class="comment">//Set up histogram stuff -  old style maintained for compatability</span>
<a name="l00037"></a>00037   <a class="code" href="structosl__edge__detector.html#afda3669e5ed3ee098dbe80c2b3321a05">gradient_histogram_</a> = <span class="keyword">false</span>; <span class="comment">//Do we need to compute a histogram?</span>
<a name="l00038"></a>00038   <a class="code" href="structosl__edge__detector.html#afc362ef495e359ca93d35ecb7456c1f3">histogram_resolution_</a> = 15; <span class="comment">// The number of buckets</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040  <a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a> = int(<a class="code" href="classosl__edge__detector__params.html#ada41e68006e9eacb369883be6f462b91">sigma_</a>*vcl_sqrt(2*vcl_log(1.0/<a class="code" href="classosl__edge__detector__params.html#af28c5dacbd2f5181e42f13c76fc9f002">gauss_tail_</a>))+1); <span class="comment">// round up to int</span>
<a name="l00041"></a>00041   <a class="code" href="structosl__edge__detector.html#a57523c088b5ede2369e5eea13493c211">k_size_</a> = 2*<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>+ 1;
<a name="l00042"></a>00042   <a class="code" href="structosl__edge__detector.html#a4c854c51a3986f37611bb8f14230624e">kernel_</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[<a class="code" href="structosl__edge__detector.html#a57523c088b5ede2369e5eea13493c211">k_size_</a>];
<a name="l00043"></a>00043   <a class="code" href="structosl__edge__detector.html#a4efa99e71870927b02af7a0c24427009">max_gradient_</a> = <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a>;
<a name="l00044"></a>00044   <a class="code" href="structosl__edge__detector.html#a23afd0a690902373263afe692f28519d">xjunc_</a> = <span class="keyword">new</span> vcl_list&lt;int&gt;;
<a name="l00045"></a>00045   <a class="code" href="structosl__edge__detector.html#aeafecb04aa65c76e14e3c4c01227f226">yjunc_</a> = <span class="keyword">new</span> vcl_list&lt;int&gt;;
<a name="l00046"></a>00046   <a class="code" href="structosl__edge__detector.html#ac0bcf90a8702a10781b3aa210de56c69">vlist_</a> = <span class="keyword">new</span> vcl_list&lt;osl_Vertex*&gt;;
<a name="l00047"></a>00047 
<a name="l00048"></a>00048   <a class="code" href="structosl__edge__detector.html#a50af95464dfb7731c9ae26db2bc4ff70">jval_</a> = 2000.0;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <a class="code" href="structosl__edge__detector.html#a94028ec9803038c1229240931da3a9c7">vertidcount_</a> = 0;
<a name="l00051"></a>00051 }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="structosl__edge__detector.html#a6c21425b8179cbbf7750e7e6ffd99584">00055</a> <a class="code" href="structosl__edge__detector.html#a6c21425b8179cbbf7750e7e6ffd99584">osl_edge_detector::~osl_edge_detector</a>()
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(<a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00058"></a>00058   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(<a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00059"></a>00059   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(<a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00060"></a>00060 
<a name="l00061"></a>00061   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(<a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00062"></a>00062   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(<a class="code" href="structosl__edge__detector.html#ae46dd0604cc4bf41a9373ceb61ce0695">theta_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00063"></a>00063   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(<a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">Free_int_image</a>(<a class="code" href="structosl__edge__detector.html#ad01678e13e38206be7dd5b17e6575413">dist_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00066"></a>00066   <a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">Free_int_image</a>(<a class="code" href="structosl__edge__detector.html#a7936dd773024f85eea9f2e4979381e69">jx_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00067"></a>00067   <a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">Free_int_image</a>(<a class="code" href="structosl__edge__detector.html#abfe074de640c9e225d91b97589265d9e">jy_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00068"></a>00068   <a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">Free_int_image</a>(<a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a>,<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>);
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <span class="comment">//no point vlist_-&gt;clear();</span>
<a name="l00071"></a>00071   <span class="keyword">delete</span> <a class="code" href="structosl__edge__detector.html#ac0bcf90a8702a10781b3aa210de56c69">vlist_</a>;
<a name="l00072"></a>00072   <span class="keyword">delete</span> [] <a class="code" href="structosl__edge__detector.html#a4c854c51a3986f37611bb8f14230624e">kernel_</a>;
<a name="l00073"></a>00073   <span class="keyword">delete</span> <a class="code" href="structosl__edge__detector.html#a23afd0a690902373263afe692f28519d">xjunc_</a>;
<a name="l00074"></a>00074   <span class="keyword">delete</span> <a class="code" href="structosl__edge__detector.html#aeafecb04aa65c76e14e3c4c01227f226">yjunc_</a>;
<a name="l00075"></a>00075 }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="structosl__edge__detector.html#a094a04ae873ad447a2ac9be942d7e0a5">00080</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#a094a04ae873ad447a2ac9be942d7e0a5">osl_edge_detector::detect_edges</a>(vil1_image <span class="keyword">const</span> &amp;image,
<a name="l00081"></a>00081                                      vcl_list&lt;osl_edge*&gt; *edges,
<a name="l00082"></a>00082                                      <span class="keywordtype">bool</span> maintain_topology)
<a name="l00083"></a>00083 {
<a name="l00084"></a>00084   assert(edges!=0);
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="comment">//</span>
<a name="l00087"></a>00087   <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a> = image.height();
<a name="l00088"></a>00088   <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a> = image.width();
<a name="l00089"></a>00089   <a class="code" href="structosl__edge__detector.html#a5e9e2ef0045946128f5c565f429d1efd">xstart_</a> = 0;
<a name="l00090"></a>00090   <a class="code" href="structosl__edge__detector.html#a6d5d9183a13486dd2c5d599d8306837d">ystart_</a> = 0;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <span class="comment">//vcl_cerr &lt;&lt; &quot;xstart_ = &quot; &lt;&lt; xstart_ &lt;&lt; &quot; ystart_ = &quot; &lt;&lt; ystart_ &lt;&lt; vcl_endl</span>
<a name="l00093"></a>00093   <span class="comment">//         &lt;&lt; &quot;xsize_ = &quot; &lt;&lt; xsize_ &lt;&lt; &quot; ysize_ = &quot; &lt;&lt; ysize_ &lt;&lt; vcl_endl;</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095   <a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a> = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00096"></a>00096   <a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a> = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00097"></a>00097   <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a> = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00098"></a>00098   <a class="code" href="structosl__edge__detector.html#aff7444a977136b2d513826ad1a26a561">smooth_</a> = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a> = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00101"></a>00101   <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a> = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00102"></a>00102   <a class="code" href="structosl__edge__detector.html#ae46dd0604cc4bf41a9373ceb61ce0695">theta_</a> = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <a class="code" href="structosl__edge__detector.html#ad01678e13e38206be7dd5b17e6575413">dist_</a> = <a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">Make_int_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00105"></a>00105   <a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a> = <a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">Make_int_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00106"></a>00106   <a class="code" href="structosl__edge__detector.html#a7936dd773024f85eea9f2e4979381e69">jx_</a> = <a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">Make_int_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00107"></a>00107   <a class="code" href="structosl__edge__detector.html#abfe074de640c9e225d91b97589265d9e">jy_</a> = <a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">Make_int_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>)
<a name="l00110"></a>00110     vcl_cerr &lt;&lt; <span class="stringliteral">&quot;Doing canny on image region &quot;</span>
<a name="l00111"></a>00111              &lt;&lt; <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a> &lt;&lt; <span class="stringliteral">&quot; by &quot;</span> &lt;&lt; <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a> &lt;&lt; vcl_endl
<a name="l00112"></a>00112              &lt;&lt; <span class="stringliteral">&quot;Gaussian tail = &quot;</span> &lt;&lt; <a class="code" href="classosl__edge__detector__params.html#af28c5dacbd2f5181e42f13c76fc9f002">gauss_tail_</a> &lt;&lt; vcl_endl
<a name="l00113"></a>00113              &lt;&lt; <span class="stringliteral">&quot;Sigma         = &quot;</span> &lt;&lt; <a class="code" href="classosl__edge__detector__params.html#ada41e68006e9eacb369883be6f462b91">sigma_</a> &lt;&lt; vcl_endl
<a name="l00114"></a>00114              &lt;&lt; <span class="stringliteral">&quot;Kernel size   = &quot;</span> &lt;&lt; <a class="code" href="structosl__edge__detector.html#a57523c088b5ede2369e5eea13493c211">k_size_</a> &lt;&lt; vcl_endl
<a name="l00115"></a>00115              &lt;&lt; <span class="stringliteral">&quot;Threshold     = &quot;</span> &lt;&lt; <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a> &lt;&lt; vcl_endl;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>)
<a name="l00118"></a>00118     vcl_cerr &lt;&lt; <span class="stringliteral">&quot;setting convolution kernel and zeroing images\n&quot;</span>;
<a name="l00119"></a>00119   <a class="code" href="osl__kernel_8cxx.html#ab2047c4eecedc2bcdfa3198f70b2c57e" title="Compute one half of the 1st Derivative Of a Gaussian.">osl_kernel_DOG</a>(<a class="code" href="classosl__edge__detector__params.html#ada41e68006e9eacb369883be6f462b91">sigma_</a>, <a class="code" href="structosl__edge__detector.html#a4c854c51a3986f37611bb8f14230624e">kernel_</a>, <a class="code" href="structosl__edge__detector.html#a57523c088b5ede2369e5eea13493c211">k_size_</a>, <a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <a class="code" href="osl__canny__base_8cxx.html#a459c3cb98a41361d67fb55d1b32d764d" title="Initialise an m*n array of Ts with value.">osl_canny_base_fill_raw_image</a>(<a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, 0.0f);
<a name="l00122"></a>00122   <a class="code" href="osl__canny__base_8cxx.html#a459c3cb98a41361d67fb55d1b32d764d" title="Initialise an m*n array of Ts with value.">osl_canny_base_fill_raw_image</a>(<a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a>);
<a name="l00123"></a>00123   <a class="code" href="osl__canny__base_8cxx.html#a459c3cb98a41361d67fb55d1b32d764d" title="Initialise an m*n array of Ts with value.">osl_canny_base_fill_raw_image</a>(<a class="code" href="structosl__edge__detector.html#ae46dd0604cc4bf41a9373ceb61ce0695">theta_</a>, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, <a class="code" href="osl__canny__rothwell_8cxx.html#a326e0e8c24ba392f076a5669b2d46db5">DUMMYTHETA</a>);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="comment">// A suitably large value (FAR) - perhaps should be more. This represents the</span>
<a name="l00126"></a>00126   <span class="comment">// distance of a point to the nearest edgel</span>
<a name="l00127"></a>00127   <a class="code" href="osl__canny__base_8cxx.html#a459c3cb98a41361d67fb55d1b32d764d" title="Initialise an m*n array of Ts with value.">osl_canny_base_fill_raw_image</a>(<a class="code" href="structosl__edge__detector.html#ad01678e13e38206be7dd5b17e6575413">dist_</a>, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, <a class="code" href="osl__edge__detector_8cxx.html#aef060b3456fdcc093a7210a762d5f2ed">FAR</a>);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <span class="comment">// Do the traditional Canny parts, and use non-maximal suppression to</span>
<a name="l00130"></a>00130   <span class="comment">// set the thresholds.</span>
<a name="l00131"></a>00131   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>) vcl_cerr &lt;&lt; <span class="stringliteral">&quot;smoothing the image\n&quot;</span>;
<a name="l00132"></a>00132   <a class="code" href="osl__canny__smooth_8cxx.html#a745ca728dac4d9bb072a0668b94dfe93">osl_canny_smooth_rothwell</a>(image, <a class="code" href="structosl__edge__detector.html#a4c854c51a3986f37611bb8f14230624e">kernel_</a>, <a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>, <a class="code" href="structosl__edge__detector.html#a57523c088b5ede2369e5eea13493c211">k_size_</a>, <a class="code" href="structosl__edge__detector.html#aff7444a977136b2d513826ad1a26a561">smooth_</a>);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>)
<a name="l00135"></a>00135     vcl_cerr &lt;&lt; <span class="stringliteral">&quot;computing x,y derivatives and norm of gradient\n&quot;</span>;
<a name="l00136"></a>00136   <a class="code" href="osl__canny__gradient_8cxx.html#a22f32dcdcb9e2d44b40d342d0c2e84b2" title="compute x,y-derivatives and absolute value of gradient.">osl_canny_gradient</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, <a class="code" href="structosl__edge__detector.html#aff7444a977136b2d513826ad1a26a561">smooth_</a>, <a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>, <a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>, <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>)
<a name="l00139"></a>00139     vcl_cerr &lt;&lt; <span class="stringliteral">&quot;doing sub-pixel interpolation\n&quot;</span>;
<a name="l00140"></a>00140   <a class="code" href="structosl__edge__detector.html#aa71720909e87cca5a4afe973b1a78b90" title="A procedure that performs sub-pixel interpolation for all edges greater than the threshold by parabol...">Sub_pixel_interpolation</a>();
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>) vcl_cerr &lt;&lt; <span class="stringliteral">&quot;assigning thresholds\n&quot;</span>;
<a name="l00143"></a>00143   <a class="code" href="structosl__edge__detector.html#afec62c580e84d0ab8cb2c7eb52f15720" title="Takes the thresh_ image that contains threshold values near to where non-maximal suppression succeede...">Set_thresholds</a>(); <span class="comment">// ghist_ is computed here</span>
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="comment">// If we don&#39;t want to maintain the strict measurement of the topology</span>
<a name="l00146"></a>00146   <span class="comment">// (ie. we want to stop the junction regions becoming too extensive), we</span>
<a name="l00147"></a>00147   <span class="comment">// fill in single pixel holes in the edge description.</span>
<a name="l00148"></a>00148   <span class="keywordflow">if</span> ( !maintain_topology ) {
<a name="l00149"></a>00149     vcl_cerr &lt;&lt; <span class="stringliteral">&quot;Filling holes\n&quot;</span>;
<a name="l00150"></a>00150     <a class="code" href="structosl__edge__detector.html#ae78b78bfb888ec7e4c808d3e049287dc" title="Finds all pixels that are surrounded by four edgels, but which are themselves not edgels...">Fill_holes</a>();
<a name="l00151"></a>00151   }
<a name="l00152"></a>00152 
<a name="l00153"></a>00153   <span class="comment">// Thin the edge image, though keep the original thick one</span>
<a name="l00154"></a>00154   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>) vcl_cerr &lt;&lt; <span class="stringliteral">&quot;thinning edges\n&quot;</span>;
<a name="l00155"></a>00155   <a class="code" href="structosl__edge__detector.html#a0b87d4c0e704f034bb40cfdd438b2332" title="Method to thin the image using the variation of Tsai-Fu thinning used by Van-Duc Nguyen in Geo-Calc...">Thin_edges</a>();
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="comment">// Locate junctions in the edge image and joint the clusters together</span>
<a name="l00158"></a>00158   <span class="comment">// as we have no confidence in the geometry around them.</span>
<a name="l00159"></a>00159   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>)
<a name="l00160"></a>00160     vcl_cerr &lt;&lt; <span class="stringliteral">&quot;locating junctions in the edge image - &quot;</span>;
<a name="l00161"></a>00161   <a class="code" href="structosl__edge__detector.html#a8e5a4bbdfc30715b3fd0637bec847f10" title="Searches for the junctions in the image.">Find_junctions</a>();
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>)
<a name="l00163"></a>00163     vcl_cerr &lt;&lt; <a class="code" href="structosl__edge__detector.html#a23afd0a690902373263afe692f28519d">xjunc_</a>-&gt;size() &lt;&lt; <span class="stringliteral">&quot; junctions found\n&quot;</span>;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165   <a class="code" href="structosl__edge__detector.html#a10b31ac31c24f524457820e3edc344f0" title="Locate junction clusters using the following method of hysteresis.">Find_junction_clusters</a>();
<a name="l00166"></a>00166   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>)
<a name="l00167"></a>00167     vcl_cerr &lt;&lt; <a class="code" href="structosl__edge__detector.html#ac0bcf90a8702a10781b3aa210de56c69">vlist_</a>-&gt;size() &lt;&lt; <span class="stringliteral">&quot; junction clusters found\n&quot;</span>;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169   <span class="comment">// Finally do edge following to extract the edge data from the thin_ image</span>
<a name="l00170"></a>00170   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>) vcl_cerr &lt;&lt; <span class="stringliteral">&quot;doing final edge following\n&quot;</span>;
<a name="l00171"></a>00171   <a class="code" href="structosl__edge__detector.html#a67f72b214883fe4332c43ff73803e74e" title="Follow all edgel chains that have pixel values above their corresponding threshold values (thin_[x][y...">Follow_curves</a>(edges);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="keywordflow">if</span> (<a class="code" href="classosl__edge__detector__params.html#a848782bc6de9596826b937a932adffa0">verbose_</a>) vcl_cerr &lt;&lt; <span class="stringliteral">&quot;finished osl_edge_detector\n&quot;</span>;
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00177"></a>00177 <span class="comment">//:</span>
<a name="l00178"></a>00178 <span class="comment">// A procedure that performs sub-pixel interpolation for all edges greater</span>
<a name="l00179"></a>00179 <span class="comment">// than the threshold by parabolic fitting. Writes edges into the thresh_ image</span>
<a name="l00180"></a>00180 <span class="comment">// if they are maxima and above low_. This gives a good indication of the local</span>
<a name="l00181"></a>00181 <span class="comment">// edge strengths. Stores sub-pixel positions in dx_ and dy_, and set the</span>
<a name="l00182"></a>00182 <span class="comment">// orientations in theta_.</span>
<a name="l00183"></a>00183 <span class="comment">//</span>
<a name="l00184"></a><a class="code" href="structosl__edge__detector.html#aa71720909e87cca5a4afe973b1a78b90">00184</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#aa71720909e87cca5a4afe973b1a78b90" title="A procedure that performs sub-pixel interpolation for all edges greater than the threshold by parabol...">osl_edge_detector::Sub_pixel_interpolation</a>()
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186   <span class="keywordtype">float</span> h1=0.0,h2=0.0; <span class="comment">// dummy initialisation values</span>
<a name="l00187"></a>00187   <span class="keywordtype">float</span> k = float(vnl_math::deg_per_rad);
<a name="l00188"></a>00188   <span class="keywordtype">int</span> orient;
<a name="l00189"></a>00189   <span class="keywordtype">float</span> theta,grad;
<a name="l00190"></a>00190   <span class="keywordtype">float</span> fraction,dnewx=0.0,dnewy=0.0; <span class="comment">// dummy initialisation values</span>
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   <span class="comment">// Add 1 to get rid of border effects.</span>
<a name="l00193"></a>00193   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>+1; x+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>+1&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x)
<a name="l00194"></a>00194   {
<a name="l00195"></a>00195     <span class="keywordtype">float</span> *g0 = <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[x-1];
<a name="l00196"></a>00196     <span class="keywordtype">float</span> *g1 = <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[x];
<a name="l00197"></a>00197     <span class="keywordtype">float</span> *g2 = <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[x+1];
<a name="l00198"></a>00198     <span class="keywordtype">float</span> *dx = <a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>[x];
<a name="l00199"></a>00199     <span class="keywordtype">float</span> *dy = <a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>[x];
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>+1; y+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>+1&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y)
<a name="l00202"></a>00202     {
<a name="l00203"></a>00203       <span class="comment">// First check that we have a potential edge</span>
<a name="l00204"></a>00204       <span class="keywordflow">if</span> ( g1[y] &gt; <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a> ) {
<a name="l00205"></a>00205         theta = k*(float)vcl_atan2(dy[y],dx[y]);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         <span class="comment">// Now work out which direction wrt the eight-way</span>
<a name="l00208"></a>00208         <span class="comment">// neighbours the edge normal points</span>
<a name="l00209"></a>00209         <span class="keywordflow">if</span> ( theta &gt;= 0.0 )
<a name="l00210"></a>00210           orient = int(theta/45.0);
<a name="l00211"></a>00211         <span class="keywordflow">else</span>
<a name="l00212"></a>00212           orient = int(theta/45.0+4);
<a name="l00213"></a>00213         <span class="comment">// if theta == 180.0 we will have orient = 4</span>
<a name="l00214"></a>00214         orient = orient%4;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         <span class="comment">// And now compute the interpolated heights</span>
<a name="l00217"></a>00217         <span class="keywordflow">switch</span> ( orient ) {
<a name="l00218"></a>00218         <span class="keywordflow">case</span> 0:
<a name="l00219"></a>00219           grad = dy[y]/dx[y];
<a name="l00220"></a>00220           h1 = grad*g0[y-1] + (1 - grad)*g0[y];
<a name="l00221"></a>00221           h2 = grad*g2[y+1] + (1 - grad)*g2[y];
<a name="l00222"></a>00222           <span class="keywordflow">break</span>;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224         <span class="keywordflow">case</span> 1:
<a name="l00225"></a>00225           grad = dx[y]/dy[y];
<a name="l00226"></a>00226           h1 = grad*g0[y-1] + (1 - grad)*g1[y-1];
<a name="l00227"></a>00227           h2 = grad*g2[y+1] + (1 - grad)*g1[y+1];
<a name="l00228"></a>00228           <span class="keywordflow">break</span>;
<a name="l00229"></a>00229 
<a name="l00230"></a>00230         <span class="keywordflow">case</span> 2:
<a name="l00231"></a>00231           grad = -dx[y]/dy[y];
<a name="l00232"></a>00232           h1 = grad*g2[y-1] + (1 - grad)*g1[y-1];
<a name="l00233"></a>00233           h2 = grad*g0[y+1] + (1 - grad)*g1[y+1];
<a name="l00234"></a>00234           <span class="keywordflow">break</span>;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         <span class="keywordflow">case</span> 3:
<a name="l00237"></a>00237           grad = -dy[y]/dx[y];
<a name="l00238"></a>00238           h1 = grad*g2[y-1] + (1 - grad)*g2[y];
<a name="l00239"></a>00239           h2 = grad*g0[y+1] + (1 - grad)*g0[y];
<a name="l00240"></a>00240           <span class="keywordflow">break</span>;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         <span class="keywordflow">default</span>:
<a name="l00243"></a>00243           vcl_abort();
<a name="l00244"></a>00244           <span class="comment">//vcl_cerr &lt;&lt; &quot;*** ERROR ON SWITCH IN NMS ***\n&quot;;</span>
<a name="l00245"></a>00245         }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         <span class="comment">// Do subpixel interpolation by fitting a parabola</span>
<a name="l00248"></a>00248         <span class="comment">// along the NMS line and finding its peak</span>
<a name="l00249"></a>00249         fraction = (h1-h2)/(2*(h1-2*g1[y]+h2));
<a name="l00250"></a>00250         <span class="keywordflow">switch</span> ( orient ) {
<a name="l00251"></a>00251         <span class="keywordflow">case</span> 0:
<a name="l00252"></a>00252           dnewx = fraction;
<a name="l00253"></a>00253           dnewy = dy[y]/dx[y]*fraction;
<a name="l00254"></a>00254           <span class="keywordflow">break</span>;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         <span class="keywordflow">case</span> 1:
<a name="l00257"></a>00257           dnewx = dx[y]/dy[y]*fraction;
<a name="l00258"></a>00258           dnewy = fraction;
<a name="l00259"></a>00259           <span class="keywordflow">break</span>;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261         <span class="keywordflow">case</span> 2:
<a name="l00262"></a>00262           dnewx = dx[y]/dy[y]*fraction;
<a name="l00263"></a>00263           dnewy = fraction;
<a name="l00264"></a>00264           <span class="keywordflow">break</span>;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266         <span class="keywordflow">case</span> 3:
<a name="l00267"></a>00267           dnewx = - fraction;
<a name="l00268"></a>00268           dnewy = - dy[y]/dx[y]*fraction;
<a name="l00269"></a>00269           <span class="keywordflow">break</span>;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271         <span class="keywordflow">default</span>:
<a name="l00272"></a>00272           vcl_abort();
<a name="l00273"></a>00273           <span class="comment">//vcl_cerr &lt;&lt; &quot;*** ERROR ON SWITCH IN NMS ***\n&quot;;</span>
<a name="l00274"></a>00274         }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276         <span class="comment">// Now store the edge data, re-use dx_[][] and dy_[][]</span>
<a name="l00277"></a>00277         <span class="comment">// for sub-pixel locations (don&#39;t worry about the junk</span>
<a name="l00278"></a>00278         <span class="comment">// that is already in them). Use any edgels that get</span>
<a name="l00279"></a>00279         <span class="comment">// non-maximal suppression to bootstrap the image</span>
<a name="l00280"></a>00280         <span class="comment">// thresholds. The &gt;= is used rather than &gt; for reasons</span>
<a name="l00281"></a>00281         <span class="comment">// involving non-generic images. Should this be interpolated</span>
<a name="l00282"></a>00282         <span class="comment">// height  = g1[y] + frac*(h2-h1)/4 ?</span>
<a name="l00283"></a>00283         <span class="keywordflow">if</span> ( g1[y]&gt;=h1 &amp;&amp; g1[y]&gt;=h2 &amp;&amp; vcl_fabs(dnewx)&lt;=0.5 &amp;&amp; vcl_fabs(dnewy)&lt;=0.5 )
<a name="l00284"></a>00284         {
<a name="l00285"></a>00285           <span class="keywordflow">if</span> ( g1[y]*<a class="code" href="osl__edge__detector_8cxx.html#a51d0dbc28d8dc4e3c9fa3217f6f9b424">ALPHA</a> &gt; <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a> )
<a name="l00286"></a>00286             <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] = <a class="code" href="osl__edge__detector_8cxx.html#a51d0dbc28d8dc4e3c9fa3217f6f9b424">ALPHA</a> * g1[y]; <span class="comment">// Use an ALPHA% bound</span>
<a name="l00287"></a>00287           <span class="comment">// thresh_ image starts off as being equal to low_</span>
<a name="l00288"></a>00288           <span class="comment">// else</span>
<a name="l00289"></a>00289           <span class="comment">//   thresh_[x][y] = low_;</span>
<a name="l00290"></a>00290           <a class="code" href="structosl__edge__detector.html#a180a69e6807aab2489045c9e07e7fce8" title="Thickens the threshold image around each good pixel to take account for the smoothing kernel (almost ...">Thicken_threshold</a>(x,y);
<a name="l00291"></a>00291         }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         <span class="comment">// + 0.5 is to account for targetjr display offset</span>
<a name="l00294"></a>00294         <span class="keywordflow">if</span> ( (vcl_fabs(dnewx)&lt;=0.5) &amp;&amp; (vcl_fabs(dnewy)&lt;=0.5) ) {
<a name="l00295"></a>00295           dx[y] = x + dnewx + 0.5f;
<a name="l00296"></a>00296           dy[y] = y + dnewy + 0.5f;
<a name="l00297"></a>00297         }
<a name="l00298"></a>00298         <span class="keywordflow">else</span> {
<a name="l00299"></a>00299           dx[y] = x + 0.5f;
<a name="l00300"></a>00300           dy[y] = y + 0.5f;
<a name="l00301"></a>00301         }
<a name="l00302"></a>00302         <a class="code" href="structosl__edge__detector.html#ae46dd0604cc4bf41a9373ceb61ce0695">theta_</a>[x][y] = theta;
<a name="l00303"></a>00303       }
<a name="l00304"></a>00304       <span class="comment">// For consistency assign these values even though the</span>
<a name="l00305"></a>00305       <span class="comment">// edge is below strength.</span>
<a name="l00306"></a>00306       <span class="keywordflow">else</span> {
<a name="l00307"></a>00307         dx[y] = x + 0.5f;
<a name="l00308"></a>00308         dy[y] = y + 0.5f;
<a name="l00309"></a>00309       }
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311   }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="comment">// Clean up around the border to ensure consistency in the dx_ and dy_ values.</span>
<a name="l00314"></a>00314   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x) {
<a name="l00315"></a>00315     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=0; y&lt;=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; ++y) {
<a name="l00316"></a>00316       <a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>[x][y] = x + 0.5f;
<a name="l00317"></a>00317       <a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>[x][y] = y + 0.5f;
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>-<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>-1; y&lt;int(<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>); ++y)
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       <a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>[x][y] = x + 0.5f;
<a name="l00322"></a>00322       <a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>[x][y] = y + 0.5f;
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324   }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>+1; y+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>+1&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y)
<a name="l00327"></a>00327   {
<a name="l00328"></a>00328     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; ++x)  {
<a name="l00329"></a>00329       <a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>[x][y] = x + 0.5f;
<a name="l00330"></a>00330       <a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>[x][y] = y + 0.5f;
<a name="l00331"></a>00331     }
<a name="l00332"></a>00332     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=xsize_-<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>-1; x&lt;int(xsize_); ++x)
<a name="l00333"></a>00333     {
<a name="l00334"></a>00334       <a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>[x][y] = x + 0.5f;
<a name="l00335"></a>00335       <a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>[x][y] = y + 0.5f;
<a name="l00336"></a>00336     }
<a name="l00337"></a>00337   }
<a name="l00338"></a>00338 }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00342"></a>00342 <span class="comment">//:</span>
<a name="l00343"></a>00343 <span class="comment">// Thickens the threshold image around each good pixel to take account for</span>
<a name="l00344"></a>00344 <span class="comment">// the smoothing kernel (almost a dilation with a square structuring element).</span>
<a name="l00345"></a>00345 <span class="comment">//</span>
<a name="l00346"></a><a class="code" href="structosl__edge__detector.html#a180a69e6807aab2489045c9e07e7fce8">00346</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#a180a69e6807aab2489045c9e07e7fce8" title="Thickens the threshold image around each good pixel to take account for the smoothing kernel (almost ...">osl_edge_detector::Thicken_threshold</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348   <span class="comment">// Experimental change 13 Apr 1995 by CAR</span>
<a name="l00349"></a>00349   <span class="keywordtype">int</span> width = <a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>;
<a name="l00350"></a>00350   <span class="comment">//    int width = 0;</span>
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=x-width; i&lt;=x+width; ++i)
<a name="l00353"></a>00353     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=y-width; j&lt;=y+width; ++j)  {
<a name="l00354"></a>00354 
<a name="l00355"></a>00355       <a class="code" href="structosl__edge__detector.html#ad01678e13e38206be7dd5b17e6575413">dist_</a>[i][j] = 0;
<a name="l00356"></a>00356       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[i][j] != <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a> )
<a name="l00357"></a>00357         <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[i][j] = vcl_min(<a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y], <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[i][j]);
<a name="l00358"></a>00358       <span class="keywordflow">else</span>
<a name="l00359"></a>00359         <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[i][j] = <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y];
<a name="l00360"></a>00360     }
<a name="l00361"></a>00361 }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00365"></a>00365 <span class="comment">//:</span>
<a name="l00366"></a>00366 <span class="comment">// Takes the thresh_ image that contains threshold values near to where</span>
<a name="l00367"></a>00367 <span class="comment">// non-maximal suppression succeeded, and zero elsewhere, and extend the</span>
<a name="l00368"></a>00368 <span class="comment">// values to all areas of the image. This is done using chamfer masks so that</span>
<a name="l00369"></a>00369 <span class="comment">// the final threshold assigned at any one point (ie. a point that was</span>
<a name="l00370"></a>00370 <span class="comment">// initially zero) is functionally dependent on the strengths of the</span>
<a name="l00371"></a>00371 <span class="comment">// nearest good edges. At present we linearly interpolate between the two</span>
<a name="l00372"></a>00372 <span class="comment">// (approximately) closest edges.</span>
<a name="l00373"></a>00373 <span class="comment">//</span>
<a name="l00374"></a>00374 <span class="comment">// Try to do the same process using Delauney triangulation (CAR, March 1995), in</span>
<a name="l00375"></a>00375 <span class="comment">// an attempt to image the efficiency from a memory management point of view.</span>
<a name="l00376"></a>00376 <span class="comment">// However, the triangulation becomes so complex that the computation time</span>
<a name="l00377"></a>00377 <span class="comment">// becomes incredibly long. Therefore putting up with the Chamfer method for</span>
<a name="l00378"></a>00378 <span class="comment">// the moment.</span>
<a name="l00379"></a>00379 <span class="comment">//</span>
<a name="l00380"></a>00380 <span class="comment">// The histogram calculation was added to support</span>
<a name="l00381"></a>00381 <span class="comment">// edgel change detection-JLM May 1995</span>
<a name="l00382"></a>00382 <span class="comment">//</span>
<a name="l00383"></a><a class="code" href="structosl__edge__detector.html#afec62c580e84d0ab8cb2c7eb52f15720">00383</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#afec62c580e84d0ab8cb2c7eb52f15720" title="Takes the thresh_ image that contains threshold values near to where non-maximal suppression succeede...">osl_edge_detector::Set_thresholds</a>()
<a name="l00384"></a>00384 {
<a name="l00385"></a>00385   <span class="keywordtype">int</span>** fdist = <a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">Make_int_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00386"></a>00386   <span class="keywordtype">int</span>** bdist = <a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">Make_int_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00387"></a>00387   <span class="keywordtype">int</span>**a1dist = <a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">Make_int_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00388"></a>00388   <span class="keywordtype">int</span>**a2dist = <a class="code" href="osl__edge__detector_8cxx.html#a6029809e60686042b8a54b454ef3bd12">Make_int_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00389"></a>00389   <a class="code" href="osl__canny__base_8cxx.html#a2d3b4100c3c9313d2e0aff7ea19b6e74" title="Copies image1 to image2.">osl_canny_base_copy_raw_image</a>(VCL_OVERLOAD_CAST(<span class="keywordtype">int</span> <span class="keyword">const</span>*<span class="keyword">const</span>*, <a class="code" href="structosl__edge__detector.html#ad01678e13e38206be7dd5b17e6575413">dist_</a>), fdist, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00390"></a>00390   <a class="code" href="osl__canny__base_8cxx.html#a2d3b4100c3c9313d2e0aff7ea19b6e74" title="Copies image1 to image2.">osl_canny_base_copy_raw_image</a>(VCL_OVERLOAD_CAST(<span class="keywordtype">int</span> <span class="keyword">const</span>*<span class="keyword">const</span>*, <a class="code" href="structosl__edge__detector.html#ad01678e13e38206be7dd5b17e6575413">dist_</a>), bdist, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00391"></a>00391   <a class="code" href="osl__canny__base_8cxx.html#a2d3b4100c3c9313d2e0aff7ea19b6e74" title="Copies image1 to image2.">osl_canny_base_copy_raw_image</a>(VCL_OVERLOAD_CAST(<span class="keywordtype">int</span> <span class="keyword">const</span>*<span class="keyword">const</span>*, <a class="code" href="structosl__edge__detector.html#ad01678e13e38206be7dd5b17e6575413">dist_</a>),a1dist, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00392"></a>00392   <a class="code" href="osl__canny__base_8cxx.html#a2d3b4100c3c9313d2e0aff7ea19b6e74" title="Copies image1 to image2.">osl_canny_base_copy_raw_image</a>(VCL_OVERLOAD_CAST(<span class="keywordtype">int</span> <span class="keyword">const</span>*<span class="keyword">const</span>*, <a class="code" href="structosl__edge__detector.html#ad01678e13e38206be7dd5b17e6575413">dist_</a>),a2dist, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394   <span class="keywordtype">float</span>** fth = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00395"></a>00395   <span class="keywordtype">float</span>** bth = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00396"></a>00396   <span class="keywordtype">float</span>**a1th = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00397"></a>00397   <span class="keywordtype">float</span>**a2th = <a class="code" href="osl__edge__detector_8cxx.html#aee073a58c0bba371741059a47c6d5a36">Make_float_image</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>,<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00398"></a>00398   <a class="code" href="osl__canny__base_8cxx.html#a2d3b4100c3c9313d2e0aff7ea19b6e74" title="Copies image1 to image2.">osl_canny_base_copy_raw_image</a>(VCL_OVERLOAD_CAST(<span class="keywordtype">float</span> <span class="keyword">const</span> *<span class="keyword">const</span>*, <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>), fth, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00399"></a>00399   <a class="code" href="osl__canny__base_8cxx.html#a2d3b4100c3c9313d2e0aff7ea19b6e74" title="Copies image1 to image2.">osl_canny_base_copy_raw_image</a>(VCL_OVERLOAD_CAST(<span class="keywordtype">float</span> <span class="keyword">const</span> *<span class="keyword">const</span>*, <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>), bth, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00400"></a>00400   <a class="code" href="osl__canny__base_8cxx.html#a2d3b4100c3c9313d2e0aff7ea19b6e74" title="Copies image1 to image2.">osl_canny_base_copy_raw_image</a>(VCL_OVERLOAD_CAST(<span class="keywordtype">float</span> <span class="keyword">const</span> *<span class="keyword">const</span>*, <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>),a1th, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00401"></a>00401   <a class="code" href="osl__canny__base_8cxx.html#a2d3b4100c3c9313d2e0aff7ea19b6e74" title="Copies image1 to image2.">osl_canny_base_copy_raw_image</a>(VCL_OVERLOAD_CAST(<span class="keywordtype">float</span> <span class="keyword">const</span> *<span class="keyword">const</span>*, <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>),a2th, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <a class="code" href="osl__chamfer_8cxx.html#ae75b66d9d41444ab82a95f2e0ee44d34" title="Performs a forward chamfer convolution on the dist image and associates a send image (param) that rep...">osl_chamfer_Forward</a> (<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, fdist, fth);
<a name="l00404"></a>00404   <a class="code" href="osl__chamfer_8cxx.html#ac0bf8300cfeccdaa5394ade649b0bbb3" title="Performs a backward chamfer convolution on the dist and param images.">osl_chamfer_Backward</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, bdist, bth);
<a name="l00405"></a>00405   <a class="code" href="osl__chamfer_8cxx.html#a36b6622270d71347078a422fe551f73e" title="Performs a chamfer convolution starting from (minx,maxy) on the dist image and associates a send imag...">osl_chamfer_Alt1</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, a1dist, a1th);
<a name="l00406"></a>00406   <a class="code" href="osl__chamfer_8cxx.html#a28e54fdfed38cc346473cfd54b0b224f" title="Performs a chamfer convolution starting from (maxx,miny) on the dist image and associates a send imag...">osl_chamfer_Alt2</a>(<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, a2dist, a2th);
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   <span class="comment">// The range of the effect of the smoothing kernel, including the scale factor</span>
<a name="l00409"></a>00409   <span class="comment">// we have ignored up to now for the chamfer masks</span>
<a name="l00410"></a>00410   <span class="comment">//    int range = 3*width_;</span>
<a name="l00411"></a>00411   <span class="comment">//    float max_gradient = low_;  //Commented out May 1997- JLM</span>
<a name="l00412"></a>00412   <span class="comment">//Replaced by global max_gradient_</span>
<a name="l00413"></a>00413   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x) {
<a name="l00414"></a>00414     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=0; y&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y) {
<a name="l00415"></a>00415 
<a name="l00416"></a>00416       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] == <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a> ) {
<a name="l00417"></a>00417 
<a name="l00418"></a>00418         <span class="comment">// Determine the two closest edge points.</span>
<a name="l00419"></a>00419         <span class="keywordtype">int</span> option = <a class="code" href="osl__chamfer_8cxx.html#a91935934842107a1767fef6936b6e9a3" title="Determines the minimum of five ints.">osl_Minimum4</a>(fdist[x][y],
<a name="l00420"></a>00420                                   bdist[x][y],
<a name="l00421"></a>00421                                   a1dist[x][y],
<a name="l00422"></a>00422                                   a2dist[x][y]);
<a name="l00423"></a>00423         <span class="keywordtype">float</span> num=1.0f; <span class="keywordtype">int</span> den=1; <span class="comment">// dummy initialisation values</span>
<a name="l00424"></a>00424         <span class="keywordflow">switch</span> (option) {
<a name="l00425"></a>00425         <span class="keywordflow">case</span> 1:
<a name="l00426"></a>00426         <span class="keywordflow">case</span> 2:
<a name="l00427"></a>00427           den = fdist[x][y]+bdist[x][y];
<a name="l00428"></a>00428           num = bdist[x][y]*fth[x][y]+fdist[x][y]*bth[x][y];
<a name="l00429"></a>00429           <span class="keywordflow">break</span>;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431         <span class="keywordflow">case</span> 3:
<a name="l00432"></a>00432         <span class="keywordflow">case</span> 4:
<a name="l00433"></a>00433           den = a1dist[x][y]+a2dist[x][y];
<a name="l00434"></a>00434           num = a2dist[x][y]*a1th[x][y]+a1dist[x][y]*a2th[x][y];
<a name="l00435"></a>00435           <span class="keywordflow">break</span>;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         <span class="keywordflow">default</span>:
<a name="l00438"></a>00438           vcl_abort();
<a name="l00439"></a>00439           <span class="comment">//break;</span>
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441         <span class="keywordflow">if</span> ( den != 0.0 )
<a name="l00442"></a>00442           <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] = num / den;
<a name="l00443"></a>00443         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] &lt;= <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a> )
<a name="l00444"></a>00444           <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] = <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a>;
<a name="l00445"></a>00445       }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[x][y]&gt;<a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] ) {
<a name="l00448"></a>00448         <span class="comment">//changed to max_gradient_, global - May 1997 JLM</span>
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (<a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[x][y]&gt;<a class="code" href="structosl__edge__detector.html#a4efa99e71870927b02af7a0c24427009">max_gradient_</a>)
<a name="l00450"></a>00450           <a class="code" href="structosl__edge__detector.html#a4efa99e71870927b02af7a0c24427009">max_gradient_</a>=<a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[x][y];
<a name="l00451"></a>00451         <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y] = <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[x][y];
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454   }
<a name="l00455"></a>00455   <span class="comment">// Noticed that all gradient values are used in edgel Strength Histogram - May 1997</span>
<a name="l00456"></a>00456   <span class="comment">// So defer to actual edgel chain formation.</span>
<a name="l00457"></a>00457 <span class="preprocessor">#if 0 // commented out</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="structosl__edge__detector.html#afda3669e5ed3ee098dbe80c2b3321a05">gradient_histogram_</a>)
<a name="l00459"></a>00459   {
<a name="l00460"></a>00460     ghist_ = <span class="keyword">new</span> Histogram(<a class="code" href="structosl__edge__detector.html#afc362ef495e359ca93d35ecb7456c1f3">histogram_resolution_</a>, <a class="code" href="classosl__edge__detector__params.html#abf332e45845294f1eb7007c765c18183">low_</a>, max_gradient);
<a name="l00461"></a>00461     <span class="keywordflow">for</span> (x=0; x&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x)
<a name="l00462"></a>00462       <span class="keywordflow">for</span> (y=0; y&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y)
<a name="l00463"></a>00463         <span class="comment">//ghist_-&gt;UpCount(grad_[x][y]); //All Pixels (Used since 1995)</span>
<a name="l00464"></a>00464         ghist_-&gt;UpCount(<a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y]);   <span class="comment">//Just at edgels (First check</span>
<a name="l00465"></a>00465   }                                     <span class="comment">//for significant differences)</span>
<a name="l00466"></a>00466 <span class="preprocessor">#endif</span>
<a name="l00467"></a>00467 <span class="preprocessor"></span>
<a name="l00468"></a>00468   <a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">Free_int_image</a>(fdist,xsize_);
<a name="l00469"></a>00469   <a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">Free_int_image</a>(bdist,xsize_);
<a name="l00470"></a>00470   <a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">Free_int_image</a>(a1dist,xsize_);
<a name="l00471"></a>00471   <a class="code" href="osl__edge__detector_8cxx.html#ab725d89a745ffbbed8fcd189d597d5a1">Free_int_image</a>(a2dist,xsize_);
<a name="l00472"></a>00472   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(fth,xsize_);
<a name="l00473"></a>00473   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(bth,xsize_);
<a name="l00474"></a>00474   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(a1th,xsize_);
<a name="l00475"></a>00475   <a class="code" href="osl__edge__detector_8cxx.html#ac1cb584ecccf8ac7418de9bd7ee71f66">Free_float_image</a>(a2th,xsize_);
<a name="l00476"></a>00476 }
<a name="l00477"></a>00477 
<a name="l00478"></a><a class="code" href="structosl__edge__detector__xyfloat.html">00478</a> <span class="keyword">struct </span><a class="code" href="structosl__edge__detector__xyfloat.html">osl_edge_detector_xyfloat</a>
<a name="l00479"></a>00479 {
<a name="l00480"></a><a class="code" href="structosl__edge__detector__xyfloat.html#aa16f5590b5a4511d192033647e327b05">00480</a>   <span class="keywordtype">int</span> <a class="code" href="structosl__edge__detector__xyfloat.html#aa16f5590b5a4511d192033647e327b05">x</a>;
<a name="l00481"></a><a class="code" href="structosl__edge__detector__xyfloat.html#a92bde11da4e80e8d96bf6ad01bc70833">00481</a>   <span class="keywordtype">int</span> <a class="code" href="structosl__edge__detector__xyfloat.html#a92bde11da4e80e8d96bf6ad01bc70833">y</a>;
<a name="l00482"></a><a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">00482</a>   <span class="keywordtype">float</span> <a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">thin</a>;
<a name="l00483"></a>00483 };
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="keyword">static</span> <span class="keywordtype">int</span> compare(<a class="code" href="structosl__edge__detector__xyfloat.html">osl_edge_detector_xyfloat</a>* xyf1, <a class="code" href="structosl__edge__detector__xyfloat.html">osl_edge_detector_xyfloat</a>* xyf2)
<a name="l00486"></a>00486 {
<a name="l00487"></a>00487   <span class="keywordflow">if</span> (xyf1-&gt;<a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">thin</a> &lt; xyf2-&gt;<a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">thin</a>)
<a name="l00488"></a>00488     <span class="keywordflow">return</span> -1;
<a name="l00489"></a>00489   <span class="keywordflow">if</span> (xyf1-&gt;<a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">thin</a> == xyf2-&gt;<a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">thin</a>)
<a name="l00490"></a>00490     <span class="keywordflow">return</span> 0;
<a name="l00491"></a>00491   <span class="keywordflow">return</span> 1;
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00496"></a>00496 <span class="comment">//:</span>
<a name="l00497"></a>00497 <span class="comment">// Method to thin the image using the variation of Tsai-Fu thinning used</span>
<a name="l00498"></a>00498 <span class="comment">// by Van-Duc Nguyen in Geo-Calc. This relies on computing the genus of</span>
<a name="l00499"></a>00499 <span class="comment">// an edge location, and removing it if it is not a dangling chain as has</span>
<a name="l00500"></a>00500 <span class="comment">// genus zero. We also order the edges by strength and try to remove the weaker</span>
<a name="l00501"></a>00501 <span class="comment">// ones first. This accounts for non-maximal suppression, and does it in a</span>
<a name="l00502"></a>00502 <span class="comment">// topology preserving way. Note that we are creating a vcl_list with a large</span>
<a name="l00503"></a>00503 <span class="comment">// number of elements, and then sorting it - this is likely to be quite slow.</span>
<a name="l00504"></a>00504 <span class="comment">// An alternative implementation would be better.</span>
<a name="l00505"></a>00505 <span class="comment">//</span>
<a name="l00506"></a><a class="code" href="structosl__edge__detector.html#a0b87d4c0e704f034bb40cfdd438b2332">00506</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#a0b87d4c0e704f034bb40cfdd438b2332" title="Method to thin the image using the variation of Tsai-Fu thinning used by Van-Duc Nguyen in Geo-Calc...">osl_edge_detector::Thin_edges</a>()
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508   <span class="comment">// Find all of the edgels with a strength &gt; low_</span>
<a name="l00509"></a>00509   <span class="keywordtype">bool</span> do_output = <span class="keyword">true</span>;
<a name="l00510"></a>00510 
<a name="l00511"></a>00511   vcl_cerr &lt;&lt; __FILE__ <span class="stringliteral">&quot;: Fast Sort\n&quot;</span>;
<a name="l00512"></a>00512   <a class="code" href="structosl__edge__detector__xyfloat.html">osl_edge_detector_xyfloat</a>* edgel_array = <span class="keyword">new</span> <a class="code" href="structosl__edge__detector__xyfloat.html">osl_edge_detector_xyfloat</a>[<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a> * <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>];
<a name="l00513"></a>00513   <span class="keywordtype">int</span> count = 1;     <span class="comment">// count set to dummy, nonzero value</span>
<a name="l00514"></a>00514   <span class="keywordflow">while</span> ( count!=0 ) <span class="comment">//  Thin until no Pixels are removed</span>
<a name="l00515"></a>00515   {
<a name="l00516"></a>00516     count = 0;
<a name="l00517"></a>00517     <span class="keywordtype">int</span> edgel_array_len = 0;
<a name="l00518"></a>00518     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; x+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x)
<a name="l00519"></a>00519       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; y+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y)
<a name="l00520"></a>00520         <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] )
<a name="l00521"></a>00521         {
<a name="l00522"></a>00522           edgel_array[edgel_array_len].<a class="code" href="structosl__edge__detector__xyfloat.html#aa16f5590b5a4511d192033647e327b05">x</a> = x;
<a name="l00523"></a>00523           edgel_array[edgel_array_len].<a class="code" href="structosl__edge__detector__xyfloat.html#a92bde11da4e80e8d96bf6ad01bc70833">y</a> = y;
<a name="l00524"></a>00524           edgel_array[edgel_array_len].<a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">thin</a> = <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y];
<a name="l00525"></a>00525           edgel_array_len++;
<a name="l00526"></a>00526         }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528     <span class="comment">// Now sort the list; this could be slow if we have a lot of potential.</span>
<a name="l00529"></a>00529     <span class="comment">// edges - surely we have to do number of elements (not -1)?</span>
<a name="l00530"></a>00530     <span class="comment">//      qsort(edgel_array, edgel_array_len-1, sizeof(osl_edge_detector_xyfloat), &amp;compare);</span>
<a name="l00531"></a>00531     vcl_qsort(edgel_array,
<a name="l00532"></a>00532               edgel_array_len,
<a name="l00533"></a>00533               <span class="keyword">sizeof</span>(<a class="code" href="structosl__edge__detector__xyfloat.html">osl_edge_detector_xyfloat</a>),
<a name="l00534"></a>00534               (<span class="keywordtype">int</span> (*)(<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *))&amp;compare);
<a name="l00535"></a>00535 
<a name="l00536"></a>00536     <span class="comment">// To assist in setting the thresholds:</span>
<a name="l00537"></a>00537     <span class="keywordflow">if</span> (  do_output &amp;&amp; (edgel_array_len &gt; 0) ) {
<a name="l00538"></a>00538 
<a name="l00539"></a>00539       vcl_cerr &lt;&lt; <span class="stringliteral">&quot;edgel strengths range from &quot;</span>
<a name="l00540"></a>00540                &lt;&lt; edgel_array[0].<a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">thin</a> &lt;&lt; <span class="stringliteral">&quot; to &quot;</span>
<a name="l00541"></a>00541                &lt;&lt; edgel_array[edgel_array_len-1].<a class="code" href="structosl__edge__detector__xyfloat.html#abfd12d8746c305780b60aa15c6a429b5">thin</a> &lt;&lt; vcl_endl;
<a name="l00542"></a>00542       do_output = <span class="keyword">false</span>;
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     <span class="comment">// Do the thinning taking the weakest edges first and works</span>
<a name="l00546"></a>00546     <span class="comment">// up through the list strengthwise.</span>
<a name="l00547"></a>00547     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pos=0; pos&lt;edgel_array_len; ++pos)
<a name="l00548"></a>00548     {
<a name="l00549"></a>00549       <span class="keywordtype">int</span> x = edgel_array[pos].<a class="code" href="structosl__edge__detector__xyfloat.html#aa16f5590b5a4511d192033647e327b05">x</a>;
<a name="l00550"></a>00550       <span class="keywordtype">int</span> y = edgel_array[pos].<a class="code" href="structosl__edge__detector__xyfloat.html#a92bde11da4e80e8d96bf6ad01bc70833">y</a>;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552       <span class="keywordtype">int</span> a = ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x-1][y-1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x-1][y-1] ) ? 1 : 0;
<a name="l00553"></a>00553       <span class="keywordtype">int</span> b = ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x  ][y-1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x  ][y-1] ) ? 1 : 0;
<a name="l00554"></a>00554       <span class="keywordtype">int</span> c = ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x+1][y-1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x+1][y-1] ) ? 1 : 0;
<a name="l00555"></a>00555       <span class="keywordtype">int</span> d = ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x+1][y  ] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x+1][y  ] ) ? 1 : 0;
<a name="l00556"></a>00556       <span class="keywordtype">int</span> e = ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x+1][y+1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x+1][y+1] ) ? 1 : 0;
<a name="l00557"></a>00557       <span class="keywordtype">int</span> f = ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x  ][y+1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x  ][y+1] ) ? 1 : 0;
<a name="l00558"></a>00558       <span class="keywordtype">int</span> g = ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x-1][y+1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x-1][y+1] ) ? 1 : 0;
<a name="l00559"></a>00559       <span class="keywordtype">int</span> h = ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x-1][y  ] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x-1][y  ] ) ? 1 : 0;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561       <span class="keywordtype">int</span> genus = a+b+c+d+e+f+g+h;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563       <span class="comment">// Continue if the pixel is not dangling.</span>
<a name="l00564"></a>00564       <span class="keywordflow">if</span> ( (genus!=1) &amp;&amp; (genus!=8) ) {
<a name="l00565"></a>00565 
<a name="l00566"></a>00566         genus += h*a*b+b*c*d+d*e*f+f*g*h
<a name="l00567"></a>00567                - a*b-b*c-c*d-d*e-e*f-f*g
<a name="l00568"></a>00568                - g*h-h*a-h*b-b*d-d*f-f*h-1;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         <span class="comment">// If the genus is zero delete the edge</span>
<a name="l00571"></a>00571         <span class="keywordflow">if</span> ( genus == 0 ) {
<a name="l00572"></a>00572           count++;
<a name="l00573"></a>00573           <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y] = 0.0;
<a name="l00574"></a>00574         }
<a name="l00575"></a>00575       }
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577   }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="keyword">delete</span> [] edgel_array;
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00584"></a>00584 <span class="comment">//:</span>
<a name="l00585"></a>00585 <span class="comment">// Finds all pixels that are surrounded by four edgels, but which are</span>
<a name="l00586"></a>00586 <span class="comment">// themselves not edgels. These `holes&#39; cause the construction of complex</span>
<a name="l00587"></a>00587 <span class="comment">// topological descriptions. To simplify matters, we raise the thin_ value</span>
<a name="l00588"></a>00588 <span class="comment">// of the central pixel and so force it to be an edgel.</span>
<a name="l00589"></a>00589 <span class="comment">//</span>
<a name="l00590"></a><a class="code" href="structosl__edge__detector.html#ae78b78bfb888ec7e4c808d3e049287dc">00590</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#ae78b78bfb888ec7e4c808d3e049287dc" title="Finds all pixels that are surrounded by four edgels, but which are themselves not edgels...">osl_edge_detector::Fill_holes</a>()
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592   <span class="comment">// Find all of the edgels with a strength &lt;= thresh_</span>
<a name="l00593"></a>00593   <span class="keywordtype">float</span> SMALL = 0.0001f;
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; x+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x)
<a name="l00596"></a>00596     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; y+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y)
<a name="l00597"></a>00597       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y] &lt;= <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] )
<a name="l00598"></a>00598       {
<a name="l00599"></a>00599         <span class="keywordtype">int</span> count = 0;
<a name="l00600"></a>00600         <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x  ][y-1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x  ][y-1] ) count++;
<a name="l00601"></a>00601         <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x  ][y+1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x  ][y+1] ) count++;
<a name="l00602"></a>00602         <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x+1][y  ] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x+1][y  ] ) count++;
<a name="l00603"></a>00603         <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x-1][y  ] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x-1][y  ] ) count++;
<a name="l00604"></a>00604 
<a name="l00605"></a>00605         <span class="keywordflow">if</span> ( count == 4 )
<a name="l00606"></a>00606           <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y] = <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] + SMALL;
<a name="l00607"></a>00607       }
<a name="l00608"></a>00608 }
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="comment">// see osl_canny_ox.cxx</span>
<a name="l00614"></a>00614 <span class="keyword">extern</span> <a class="code" href="classosl__vertex.html">osl_Vertex</a> *<a class="code" href="osl__canny__ox_8cxx.html#af1c955c27d8339d65e22cedbc788f77a" title="Returns the first osl_Vertex* in l which matches (i.e. compares equal to) v.">osl_find</a>(vcl_list&lt;osl_Vertex*&gt; <span class="keyword">const</span> *l, <a class="code" href="classosl__vertex.html">osl_Vertex</a> <span class="keyword">const</span> &amp;v);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 <span class="comment">//:</span>
<a name="l00617"></a>00617 <span class="comment">// Follow all edgel chains that have pixel values above their corresponding</span>
<a name="l00618"></a>00618 <span class="comment">// threshold values (thin_[x][y] &gt; thresh_[x][y]).</span>
<a name="l00619"></a>00619 <span class="comment">//</span>
<a name="l00620"></a><a class="code" href="structosl__edge__detector.html#a67f72b214883fe4332c43ff73803e74e">00620</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#a67f72b214883fe4332c43ff73803e74e" title="Follow all edgel chains that have pixel values above their corresponding threshold values (thin_[x][y...">osl_edge_detector::Follow_curves</a>(vcl_list&lt;osl_edge*&gt; *edges)
<a name="l00621"></a>00621 {
<a name="l00622"></a>00622   <span class="comment">//  //Added May 1997 to restrict histogram to actual detected edgels -JLM</span>
<a name="l00623"></a>00623   <span class="comment">//  if (gradient_histogram_)</span>
<a name="l00624"></a>00624   <span class="comment">//    ghist_ = new Histogram(histogram_resolution_, low_, max_gradient_);</span>
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   vcl_list&lt;int&gt; xcoords,ycoords;
<a name="l00627"></a>00627   vcl_list&lt;float&gt; grad;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <a class="code" href="structosl__edge__detector.html#a731b6b3b313e8f15274993e60a8038c9">chain_no_</a> = 10;  <span class="comment">// Must be set to a number &gt;= 1</span>
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <span class="comment">// Find an edgel point and start to follow it.</span>
<a name="l00632"></a>00632   edges-&gt;clear();
<a name="l00633"></a>00633   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; x+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x)
<a name="l00634"></a>00634   {
<a name="l00635"></a>00635     <span class="keywordtype">float</span> *thin = <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x];
<a name="l00636"></a>00636     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; y+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y)
<a name="l00637"></a>00637     {
<a name="l00638"></a>00638       <span class="keywordflow">if</span> ( (thin[y]&lt;=<a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y]) || <a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a>[x][y] )
<a name="l00639"></a>00639         <span class="keywordflow">continue</span>;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641       <span class="comment">// Set the following variable [what a pointless comment]</span>
<a name="l00642"></a>00642       <a class="code" href="structosl__edge__detector.html#a731b6b3b313e8f15274993e60a8038c9">chain_no_</a>++;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644       <span class="comment">// clear lists before following</span>
<a name="l00645"></a>00645       xcoords.clear();
<a name="l00646"></a>00646       ycoords.clear();
<a name="l00647"></a>00647       grad.clear();
<a name="l00648"></a>00648 
<a name="l00649"></a>00649       <a class="code" href="structosl__edge__detector.html#ab1e34cc187a83008f521655e39ec0d73" title="Following routine looking for connectiveness of edgel chains, and accounts for single pixel gaps in t...">Follow</a>(x,y,&amp;xcoords,&amp;ycoords,&amp;grad,0);
<a name="l00650"></a>00650 
<a name="l00651"></a>00651       <span class="comment">// We may have picked up the edgel chain somewhere</span>
<a name="l00652"></a>00652       <span class="comment">// away from its ends. Therefore, reverse the list</span>
<a name="l00653"></a>00653       <span class="comment">// and try to follow again.</span>
<a name="l00654"></a>00654       xcoords.reverse();  ycoords.reverse();  grad.reverse();
<a name="l00655"></a>00655       <a class="code" href="structosl__edge__detector.html#ab1e34cc187a83008f521655e39ec0d73" title="Following routine looking for connectiveness of edgel chains, and accounts for single pixel gaps in t...">Follow</a>(x,y,&amp;xcoords,&amp;ycoords,&amp;grad,1);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657       <span class="comment">// Check that we have at least two endpoints to</span>
<a name="l00658"></a>00658       <span class="comment">// the list, otherwise go to next loop</span>
<a name="l00659"></a>00659       <span class="keywordflow">if</span> ( xcoords.size() &lt; 2 )
<a name="l00660"></a>00660         <span class="comment">// vcl_cerr &lt;&lt; &quot;short list found in Final_follow\n&quot;;</span>
<a name="l00661"></a>00661         <span class="keywordflow">continue</span>;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663       <span class="keywordtype">int</span> count=0; <span class="comment">// isn&#39;t this just &quot;count = grad.size()&quot; ?</span>
<a name="l00664"></a>00664       <span class="keywordflow">for</span> (vcl_list&lt;float&gt;::iterator i=grad.begin(); i!=grad.end(); ++i)
<a name="l00665"></a>00665         count++;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667       <span class="comment">// If the count is less than two we cannot accept</span>
<a name="l00668"></a>00668       <span class="comment">// the edgelchain. Smallest chain must either be `ee&#39;,</span>
<a name="l00669"></a>00669       <span class="comment">// `je&#39;, `ej&#39; or `jj&#39; (for `e&#39;dge and `j&#39;unction)</span>
<a name="l00670"></a>00670       <span class="keywordflow">if</span> ( count &lt; 2 )
<a name="l00671"></a>00671         <span class="keywordflow">continue</span>;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673       <span class="comment">// Create an osl_edgel_chain</span>
<a name="l00674"></a>00674       <a class="code" href="structosl__edgel__chain.html">osl_edgel_chain</a> *dc = <span class="keyword">new</span> <a class="code" href="structosl__edgel__chain.html">osl_edgel_chain</a>(count);
<a name="l00675"></a>00675       <span class="keywordtype">float</span> *px = dc-&gt;<a class="code" href="structosl__edgel__chain.html#a4b0df607268feda44c146622d5c9d143">GetX</a>();
<a name="l00676"></a>00676       <span class="keywordtype">float</span> *py = dc-&gt;<a class="code" href="structosl__edgel__chain.html#adf08daad9f3e495be41ce1a38db8f1a5">GetY</a>();
<a name="l00677"></a>00677       <span class="keywordtype">float</span> *pg = dc-&gt;<a class="code" href="structosl__edgel__chain.html#ab5a6c98aa0e3f90b58a50eaa1a8ab63f">GetGrad</a>();
<a name="l00678"></a>00678       <span class="keywordtype">float</span> *pt = dc-&gt;<a class="code" href="structosl__edgel__chain.html#aa1bd99771f81dd3c4938339aaae22096">GetTheta</a>();
<a name="l00679"></a>00679 
<a name="l00680"></a>00680       <span class="comment">// Write the points to the osl_edgel_chain</span>
<a name="l00681"></a>00681       <span class="keywordflow">while</span> (count) {
<a name="l00682"></a>00682         <span class="keywordtype">int</span> tmpx = xcoords.front(); xcoords.pop_front();
<a name="l00683"></a>00683         <span class="keywordtype">int</span> tmpy = ycoords.front(); ycoords.pop_front();
<a name="l00684"></a>00684         <span class="keywordtype">float</span> val = grad.front(); grad.pop_front();
<a name="l00685"></a>00685         count--;
<a name="l00686"></a>00686 
<a name="l00687"></a>00687         <span class="comment">// If we are not at a junction use sub-pixel value.</span>
<a name="l00688"></a>00688         <span class="keywordflow">if</span> ( val != <a class="code" href="structosl__edge__detector.html#a50af95464dfb7731c9ae26db2bc4ff70">jval_</a> ) {
<a name="l00689"></a>00689           *(px++) = <a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>[tmpx][tmpy] + <a class="code" href="structosl__edge__detector.html#a5e9e2ef0045946128f5c565f429d1efd">xstart_</a>;
<a name="l00690"></a>00690           *(py++) = <a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>[tmpx][tmpy] + <a class="code" href="structosl__edge__detector.html#a6d5d9183a13486dd2c5d599d8306837d">ystart_</a>;
<a name="l00691"></a>00691           *(pg++) = val;
<a name="l00692"></a>00692           <span class="comment">//     if (ghist_)</span>
<a name="l00693"></a>00693           <span class="comment">//       ghist_-&gt;UpCount(val); //Added edgel histogram here -May 1997</span>
<a name="l00694"></a>00694         }
<a name="l00695"></a>00695         <span class="keywordflow">else</span> {
<a name="l00696"></a>00696           *(px++) = <span class="keywordtype">float</span>(tmpx + <a class="code" href="structosl__edge__detector.html#a5e9e2ef0045946128f5c565f429d1efd">xstart_</a>);
<a name="l00697"></a>00697           *(py++) = <span class="keywordtype">float</span>(tmpy + <a class="code" href="structosl__edge__detector.html#a6d5d9183a13486dd2c5d599d8306837d">ystart_</a>);
<a name="l00698"></a>00698           *(pg++) = 0.0f;   <span class="comment">// Mark the gradient as zero at a junction</span>
<a name="l00699"></a>00699         }
<a name="l00700"></a>00700         <span class="keywordflow">if</span> (<a class="code" href="structosl__edge__detector.html#ae46dd0604cc4bf41a9373ceb61ce0695">theta_</a>[tmpx][tmpy] == <a class="code" href="osl__canny__rothwell_8cxx.html#a326e0e8c24ba392f076a5669b2d46db5">DUMMYTHETA</a>) {
<a name="l00701"></a>00701           <span class="keyword">const</span> <span class="keywordtype">float</span> k = float(vnl_math::deg_per_rad);
<a name="l00702"></a>00702           <a class="code" href="structosl__edge__detector.html#ae46dd0604cc4bf41a9373ceb61ce0695">theta_</a>[tmpx][tmpy]  = k*(float)vcl_atan2(<a class="code" href="structosl__edge__detector.html#a494989e08569309dcba74640c4ff1d00">dy_</a>[tmpx][y],<a class="code" href="structosl__edge__detector.html#a99469cdd9184d2b0d6a88820106e1e7b">dx_</a>[tmpx][y]);
<a name="l00703"></a>00703         }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         *(pt++) = <a class="code" href="structosl__edge__detector.html#ae46dd0604cc4bf41a9373ceb61ce0695">theta_</a>[tmpx][tmpy];
<a name="l00706"></a>00706       }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708       <span class="comment">// Just check whether we have created a trivial edgechain</span>
<a name="l00709"></a>00709       <span class="comment">// (can happen due to the presence of dummy points)</span>
<a name="l00710"></a>00710       <span class="keywordflow">if</span> ( (dc-&gt;<a class="code" href="structosl__edgel__chain.html#a5f9b70b409cdeb1ed7dfa6c895a70f9b">size</a>()==2) &amp;&amp;
<a name="l00711"></a>00711            (dc-&gt;<a class="code" href="structosl__edgel__chain.html#a4b0df607268feda44c146622d5c9d143">GetX</a>(0)==dc-&gt;<a class="code" href="structosl__edgel__chain.html#a4b0df607268feda44c146622d5c9d143">GetX</a>(1)) &amp;&amp;
<a name="l00712"></a>00712            (dc-&gt;<a class="code" href="structosl__edgel__chain.html#adf08daad9f3e495be41ce1a38db8f1a5">GetY</a>(0)==dc-&gt;<a class="code" href="structosl__edgel__chain.html#adf08daad9f3e495be41ce1a38db8f1a5">GetY</a>(1)) ) {
<a name="l00713"></a>00713         <span class="keyword">delete</span> dc;
<a name="l00714"></a>00714         <span class="keywordflow">continue</span>;
<a name="l00715"></a>00715       }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( dc-&gt;<a class="code" href="structosl__edgel__chain.html#a5f9b70b409cdeb1ed7dfa6c895a70f9b">size</a>() &gt; 1 ) {
<a name="l00718"></a>00718         <span class="comment">// Create an edge for the image topology</span>
<a name="l00719"></a>00719         <a class="code" href="classosl__vertex.html">osl_Vertex</a> *v1 = <span class="keyword">new</span> <a class="code" href="osl__vertex_8h.html#a9feda5bab497658648b7ad9fe3a325da">osl_Vertex</a>(dc-&gt;<a class="code" href="structosl__edgel__chain.html#a4b0df607268feda44c146622d5c9d143">GetX</a>(0),dc-&gt;<a class="code" href="structosl__edgel__chain.html#adf08daad9f3e495be41ce1a38db8f1a5">GetY</a>(0));
<a name="l00720"></a>00720         v1-&gt;<a class="code" href="structosl__topology__base.html#ab217f31dc2d536b8d2b9ed856a60d04e">SetId</a>(<a class="code" href="structosl__edge__detector.html#a94028ec9803038c1229240931da3a9c7">vertidcount_</a>++);
<a name="l00721"></a>00721         <a class="code" href="classosl__vertex.html">osl_Vertex</a> *v2 = <span class="keyword">new</span> <a class="code" href="osl__vertex_8h.html#a9feda5bab497658648b7ad9fe3a325da">osl_Vertex</a>(dc-&gt;<a class="code" href="structosl__edgel__chain.html#a4b0df607268feda44c146622d5c9d143">GetX</a>(dc-&gt;<a class="code" href="structosl__edgel__chain.html#a5f9b70b409cdeb1ed7dfa6c895a70f9b">size</a>()-1),dc-&gt;<a class="code" href="structosl__edgel__chain.html#adf08daad9f3e495be41ce1a38db8f1a5">GetY</a>(dc-&gt;<a class="code" href="structosl__edgel__chain.html#a5f9b70b409cdeb1ed7dfa6c895a70f9b">size</a>()-1));
<a name="l00722"></a>00722         v2-&gt;<a class="code" href="structosl__topology__base.html#ab217f31dc2d536b8d2b9ed856a60d04e">SetId</a>(<a class="code" href="structosl__edge__detector.html#a94028ec9803038c1229240931da3a9c7">vertidcount_</a>++);
<a name="l00723"></a>00723         <span class="comment">// Check whether each vertex is a junction</span>
<a name="l00724"></a>00724         <a class="code" href="classosl__vertex.html">osl_Vertex</a> *V1 = <a class="code" href="osl__canny__ox_8cxx.html#af1c955c27d8339d65e22cedbc788f77a" title="Returns the first osl_Vertex* in l which matches (i.e. compares equal to) v.">osl_find</a>(<a class="code" href="structosl__edge__detector.html#ac0bcf90a8702a10781b3aa210de56c69">vlist_</a>, *v1);
<a name="l00725"></a>00725         <a class="code" href="classosl__vertex.html">osl_Vertex</a> *V2 = <a class="code" href="osl__canny__ox_8cxx.html#af1c955c27d8339d65e22cedbc788f77a" title="Returns the first osl_Vertex* in l which matches (i.e. compares equal to) v.">osl_find</a>(<a class="code" href="structosl__edge__detector.html#ac0bcf90a8702a10781b3aa210de56c69">vlist_</a>, *v2);
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         <span class="comment">// If neither are junctions we may have formed a single isolated</span>
<a name="l00728"></a>00728         <span class="comment">// chain that should have common vertex endpoints.</span>
<a name="l00729"></a>00729         <span class="keywordtype">int</span> single_chain = <span class="keyword">false</span>;
<a name="l00730"></a>00730         <span class="keywordflow">if</span> ( !V1 &amp;&amp; !V2 ) {
<a name="l00731"></a>00731           <span class="keywordtype">float</span> dx = dc-&gt;<a class="code" href="structosl__edgel__chain.html#a4b0df607268feda44c146622d5c9d143">GetX</a>(0) - dc-&gt;<a class="code" href="structosl__edgel__chain.html#a4b0df607268feda44c146622d5c9d143">GetX</a>(dc-&gt;<a class="code" href="structosl__edgel__chain.html#a5f9b70b409cdeb1ed7dfa6c895a70f9b">size</a>()-1);
<a name="l00732"></a>00732           <span class="keywordtype">float</span> dy = dc-&gt;<a class="code" href="structosl__edgel__chain.html#adf08daad9f3e495be41ce1a38db8f1a5">GetY</a>(0) - dc-&gt;<a class="code" href="structosl__edgel__chain.html#adf08daad9f3e495be41ce1a38db8f1a5">GetY</a>(dc-&gt;<a class="code" href="structosl__edgel__chain.html#a5f9b70b409cdeb1ed7dfa6c895a70f9b">size</a>()-1);
<a name="l00733"></a>00733           <span class="keywordflow">if</span> ( dx*dx+dy*dy&lt;4 )  { <span class="comment">//  ie. dist &lt; 2 pixels it is closed</span>
<a name="l00734"></a>00734             <a class="code" href="osl__reorder__chain_8cxx.html#a0864e6ecc3dd72532cf95c37338b9dc5" title="Takes a DigitalCurve that is assumed to form a closed loop and finds the largest corner in the chain...">osl_reorder_chain</a>(dc);
<a name="l00735"></a>00735             <a class="code" href="osl__hacks_8h.html#a176adfaff32ff0ae36fae33a2afbd42f">osl_IUDelete</a>(v1);
<a name="l00736"></a>00736             <a class="code" href="osl__hacks_8h.html#a176adfaff32ff0ae36fae33a2afbd42f">osl_IUDelete</a>(v2);
<a name="l00737"></a>00737             v1 = <span class="keyword">new</span> <a class="code" href="osl__vertex_8h.html#a9feda5bab497658648b7ad9fe3a325da">osl_Vertex</a>(dc-&gt;<a class="code" href="structosl__edgel__chain.html#a4b0df607268feda44c146622d5c9d143">GetX</a>(0),dc-&gt;<a class="code" href="structosl__edgel__chain.html#adf08daad9f3e495be41ce1a38db8f1a5">GetY</a>(0));
<a name="l00738"></a>00738             v1-&gt;<a class="code" href="structosl__topology__base.html#ab217f31dc2d536b8d2b9ed856a60d04e">SetId</a>(<a class="code" href="structosl__edge__detector.html#a94028ec9803038c1229240931da3a9c7">vertidcount_</a>++);
<a name="l00739"></a>00739             V1 = v1;  V2 = v1;
<a name="l00740"></a>00740             single_chain = <span class="keyword">true</span>;
<a name="l00741"></a>00741           }
<a name="l00742"></a>00742         }
<a name="l00743"></a>00743         <span class="keywordflow">if</span> ( !single_chain ) {
<a name="l00744"></a>00744           <span class="keywordflow">if</span> ( !V1 )
<a name="l00745"></a>00745             V1 = v1;
<a name="l00746"></a>00746           <span class="keywordflow">else</span>
<a name="l00747"></a>00747           { <a class="code" href="osl__hacks_8h.html#a176adfaff32ff0ae36fae33a2afbd42f">osl_IUDelete</a>(v1); }
<a name="l00748"></a>00748           <span class="keywordflow">if</span> ( !V2 )
<a name="l00749"></a>00749             V2 = v2;
<a name="l00750"></a>00750           <span class="keywordflow">else</span>
<a name="l00751"></a>00751           { <a class="code" href="osl__hacks_8h.html#a176adfaff32ff0ae36fae33a2afbd42f">osl_IUDelete</a>(v2); }
<a name="l00752"></a>00752         }
<a name="l00753"></a>00753         <span class="comment">//edge = new osl_edge(V1,V2);</span>
<a name="l00754"></a>00754 
<a name="l00755"></a>00755         <span class="comment">// Note that the edge can start and end in the same place.</span>
<a name="l00756"></a>00756         <span class="comment">// However, if this is so the DigitalCurve has positive length</span>
<a name="l00757"></a>00757         <span class="comment">//dc-&gt;SetStart(dc-&gt;GetX(0), dc-&gt;GetY(0));</span>
<a name="l00758"></a>00758         <span class="comment">//dc-&gt;SetEnd(dc-&gt;GetX(dc-&gt;size()-1), dc-&gt;GetY(dc-&gt;size()-1));</span>
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         <span class="comment">//edge-&gt;SetCurve(dc);</span>
<a name="l00761"></a>00761         edges-&gt;push_front(<span class="keyword">new</span> <a class="code" href="classosl__edge.html">osl_edge</a>(*dc, V1, V2));
<a name="l00762"></a>00762         <span class="keyword">delete</span> dc;
<a name="l00763"></a>00763       }
<a name="l00764"></a>00764     }
<a name="l00765"></a>00765   }
<a name="l00766"></a>00766 }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00769"></a>00769 <span class="comment">//:</span>
<a name="l00770"></a>00770 <span class="comment">// Following routine looking for connectiveness of edgel chains, and</span>
<a name="l00771"></a>00771 <span class="comment">// accounts for single pixel gaps in the chains.</span>
<a name="l00772"></a>00772 <span class="comment">//</span>
<a name="l00773"></a><a class="code" href="structosl__edge__detector.html#ab1e34cc187a83008f521655e39ec0d73">00773</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#ab1e34cc187a83008f521655e39ec0d73" title="Following routine looking for connectiveness of edgel chains, and accounts for single pixel gaps in t...">osl_edge_detector::Follow</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y,
<a name="l00774"></a>00774                                vcl_list&lt;int&gt; *xc,
<a name="l00775"></a>00775                                vcl_list&lt;int&gt; *yc,
<a name="l00776"></a>00776                                vcl_list&lt;float&gt; *grad,
<a name="l00777"></a>00777                                <span class="keywordtype">int</span> reverse)
<a name="l00778"></a>00778 {
<a name="l00779"></a>00779   <span class="comment">// Make sure that we do not overun the border of the image</span>
<a name="l00780"></a>00780   assert( x&gt;0 &amp;&amp; y&gt;0 );
<a name="l00781"></a>00781   assert( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)x+1&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a> );
<a name="l00782"></a>00782   assert( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)y+1&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a> );
<a name="l00783"></a>00783 
<a name="l00784"></a>00784   <span class="comment">// Add the current point to the coordinate lists, and delete from</span>
<a name="l00785"></a>00785   <span class="comment">// the edge image</span>
<a name="l00786"></a>00786   <span class="keywordflow">if</span> (!reverse) {
<a name="l00787"></a>00787     xc-&gt;push_front(x);
<a name="l00788"></a>00788     yc-&gt;push_front(y);
<a name="l00789"></a>00789     grad-&gt;push_front(<a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y]);
<a name="l00790"></a>00790   }
<a name="l00791"></a>00791   <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y] = 0.0;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   <span class="comment">// The order of traversal is (x axis to the right and y axis down) :</span>
<a name="l00794"></a>00794   <span class="comment">//    5 0 4</span>
<a name="l00795"></a>00795   <span class="comment">//    1 * 3</span>
<a name="l00796"></a>00796   <span class="comment">//    6 2 7</span>
<a name="l00797"></a>00797   <span class="comment">// Have to be careful with the ; in the following macros. Don&#39;t</span>
<a name="l00798"></a>00798   <span class="comment">// emacs indent this function!</span>
<a name="l00799"></a>00799   <span class="keywordflow">if</span> (<span class="keyword">false</span>) { }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   <span class="comment">// Now recursively look for connected eight-neighbours.</span>
<a name="l00802"></a>00802 <span class="preprocessor">#define smoo(a, b) \</span>
<a name="l00803"></a>00803 <span class="preprocessor">  else if ( (thin_[a][b]&gt;thresh_[a][b]) &amp;&amp; (junction_[a][b]==0) ) \</span>
<a name="l00804"></a>00804 <span class="preprocessor">    Follow(a, b, xc,yc, grad, 0);</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>  <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x  , y-1)
<a name="l00806"></a>00806   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y  )
<a name="l00807"></a>00807   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x  , y+1)
<a name="l00808"></a>00808   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y  )
<a name="l00809"></a>00809   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y-1)
<a name="l00810"></a>00810   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y-1)
<a name="l00811"></a>00811   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y+1)
<a name="l00812"></a>00812   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y+1)
<a name="l00813"></a>00813 <span class="preprocessor">#undef smoo</span>
<a name="l00814"></a>00814 <span class="preprocessor"></span>
<a name="l00815"></a>00815   <span class="comment">// Else see if there is a junction nearby, and record it. The chain_no_</span>
<a name="l00816"></a>00816   <span class="comment">// variable is used to prevent the same junction being inserted at both</span>
<a name="l00817"></a>00817   <span class="comment">// ends of the edgel chains when reversal occurs next to the junction</span>
<a name="l00818"></a>00818   <span class="comment">// (in that case there will only be two stored points: the edge and the junction)</span>
<a name="l00819"></a>00819 <span class="preprocessor">#define smoo(a, b) \</span>
<a name="l00820"></a>00820 <span class="preprocessor">  else if ( junction_[a][b] &amp;&amp; ((xc-&gt;size()&gt;2) || (junction_[a][b]!=chain_no_)) ) { \</span>
<a name="l00821"></a>00821 <span class="preprocessor">    xc-&gt;push_front(jx_[a][b]); \</span>
<a name="l00822"></a>00822 <span class="preprocessor">    yc-&gt;push_front(jy_[a][b]); \</span>
<a name="l00823"></a>00823 <span class="preprocessor">    grad-&gt;push_front(jval_); \</span>
<a name="l00824"></a>00824 <span class="preprocessor">    junction_[a][b] = chain_no_; \</span>
<a name="l00825"></a>00825 <span class="preprocessor">  }</span>
<a name="l00826"></a>00826 <span class="preprocessor"></span>  <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x  , y-1)
<a name="l00827"></a>00827   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y  )
<a name="l00828"></a>00828   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x  , y+1)
<a name="l00829"></a>00829   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y  )
<a name="l00830"></a>00830   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y-1)
<a name="l00831"></a>00831   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y-1)
<a name="l00832"></a>00832   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y+1)
<a name="l00833"></a>00833   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y+1)
<a name="l00834"></a>00834 <span class="preprocessor">#undef smoo</span>
<a name="l00835"></a>00835 <span class="preprocessor"></span>  <span class="keywordflow">else</span> {
<a name="l00836"></a>00836     <span class="comment">// ? FIXME</span>
<a name="l00837"></a>00837   }
<a name="l00838"></a>00838 }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00842"></a>00842 <span class="comment">//</span>
<a name="l00843"></a>00843 <span class="comment">//: Searches for the junctions in the image.</span>
<a name="l00844"></a>00844 <span class="comment">//</span>
<a name="l00845"></a><a class="code" href="structosl__edge__detector.html#a8e5a4bbdfc30715b3fd0637bec847f10">00845</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#a8e5a4bbdfc30715b3fd0637bec847f10" title="Searches for the junctions in the image.">osl_edge_detector::Find_junctions</a>()
<a name="l00846"></a>00846 {
<a name="l00847"></a>00847   <span class="comment">// Reset the junction variables</span>
<a name="l00848"></a>00848   <a class="code" href="structosl__edge__detector.html#a23afd0a690902373263afe692f28519d">xjunc_</a>-&gt;clear();
<a name="l00849"></a>00849   <a class="code" href="structosl__edge__detector.html#aeafecb04aa65c76e14e3c4c01227f226">yjunc_</a>-&gt;clear();
<a name="l00850"></a>00850   <a class="code" href="osl__canny__base_8cxx.html#a459c3cb98a41361d67fb55d1b32d764d" title="Initialise an m*n array of Ts with value.">osl_canny_base_fill_raw_image</a>(<a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a>, <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>, <a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>, 0);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; x+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x)
<a name="l00853"></a>00853     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; y+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y)
<a name="l00854"></a>00854     {
<a name="l00855"></a>00855       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x][y] &lt;= <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x][y] )
<a name="l00856"></a>00856         <span class="keywordflow">continue</span>;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858       <span class="keywordtype">int</span> count = 0;
<a name="l00859"></a>00859       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x-1][y-1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x-1][y-1] )  count++;
<a name="l00860"></a>00860       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x  ][y-1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x  ][y-1] )  count++;
<a name="l00861"></a>00861       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x+1][y-1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x+1][y-1] )  count++;
<a name="l00862"></a>00862       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x+1][y  ] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x+1][y  ] )  count++;
<a name="l00863"></a>00863       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x+1][y+1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x+1][y+1] )  count++;
<a name="l00864"></a>00864       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x  ][y+1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x  ][y+1] )  count++;
<a name="l00865"></a>00865       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x-1][y+1] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x-1][y+1] )  count++;
<a name="l00866"></a>00866       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#aa89de50101c713eea75a844caf40f9b9">thin_</a>[x-1][y  ] &gt; <a class="code" href="structosl__edge__detector.html#a22c0e2163280743d22f8b5c09fdee589">thresh_</a>[x-1][y  ] )  count++;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868       <span class="keywordflow">if</span> ( count &gt; 2 ) {
<a name="l00869"></a>00869         <a class="code" href="structosl__edge__detector.html#a23afd0a690902373263afe692f28519d">xjunc_</a>-&gt;push_front(x);
<a name="l00870"></a>00870         <a class="code" href="structosl__edge__detector.html#aeafecb04aa65c76e14e3c4c01227f226">yjunc_</a>-&gt;push_front(y);
<a name="l00871"></a>00871         <a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a>[x][y] = 1;
<a name="l00872"></a>00872       }
<a name="l00873"></a>00873     }
<a name="l00874"></a>00874 }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00878"></a>00878 <span class="comment">//</span>
<a name="l00879"></a>00879 <span class="comment">//: Locate junction clusters using the following method of hysteresis.</span>
<a name="l00880"></a>00880 <span class="comment">//</span>
<a name="l00881"></a>00881 <span class="comment">//</span>
<a name="l00882"></a><a class="code" href="structosl__edge__detector.html#a10b31ac31c24f524457820e3edc344f0">00882</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#a10b31ac31c24f524457820e3edc344f0" title="Locate junction clusters using the following method of hysteresis.">osl_edge_detector::Find_junction_clusters</a>()
<a name="l00883"></a>00883 {
<a name="l00884"></a>00884   vcl_list&lt;int&gt; xcoords,ycoords,xvertices,yvertices,xjunc,yjunc;
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   <span class="comment">// Find a junction and follow</span>
<a name="l00887"></a>00887   xvertices.clear();
<a name="l00888"></a>00888   yvertices.clear();
<a name="l00889"></a>00889   xjunc.clear();
<a name="l00890"></a>00890   yjunc.clear();
<a name="l00891"></a>00891   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; x+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>; ++x)
<a name="l00892"></a>00892   {
<a name="l00893"></a>00893     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>; y+<a class="code" href="structosl__edge__detector.html#af36bb9f3221a2d29b03c092a1f9a89eb">width_</a>&lt;<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; ++y)
<a name="l00894"></a>00894     {
<a name="l00895"></a>00895       <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a>[x][y] )
<a name="l00896"></a>00896       {
<a name="l00897"></a>00897         <span class="comment">// Each cluster is written to (xcoords,ycooords)</span>
<a name="l00898"></a>00898         xcoords.clear();  ycoords.clear();
<a name="l00899"></a>00899         <a class="code" href="structosl__edge__detector.html#a4933ae49aca8978e1c27d9cb6e95611a" title="Following routine looking for searching out junction clusters.">Follow_junctions</a>(x,y,&amp;xcoords,&amp;ycoords);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901         <span class="comment">// Find the `centre&#39; of the cluster. Look at the method</span>
<a name="l00902"></a>00902         <span class="comment">// Cluster_centre to see how `centre&#39; is defined.</span>
<a name="l00903"></a>00903         <span class="keywordtype">int</span> x0, y0;
<a name="l00904"></a>00904         <a class="code" href="structosl__edge__detector.html#a951b8ed622877dc42b2d5f84d1ca7508" title="Finds which member of the lists lies closest to the centre of the list.">Cluster_centre</a>(xcoords,ycoords,x0,y0);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906         <span class="comment">// Add both the junctions and the new cluster centre to</span>
<a name="l00907"></a>00907         <span class="comment">// the main lists</span>
<a name="l00908"></a>00908         xvertices.push_front(x0);
<a name="l00909"></a>00909         yvertices.push_front(y0);
<a name="l00910"></a>00910         xjunc.insert(xjunc.begin(), xcoords.begin(), xcoords.end()); <span class="comment">//xjunc.prepend(xcoords);</span>
<a name="l00911"></a>00911         yjunc.insert(yjunc.begin(), ycoords.begin(), ycoords.end()); <span class="comment">//yjunc.prepend(ycoords);</span>
<a name="l00912"></a>00912       }
<a name="l00913"></a>00913     }
<a name="l00914"></a>00914   }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916   <span class="comment">// Reset the junction image - this is order dependent because</span>
<a name="l00917"></a>00917   <span class="comment">// the cluster centres appear in both lists</span>
<a name="l00918"></a>00918   <span class="comment">// xjunc.reset();  yjunc.reset();</span>
<a name="l00919"></a>00919   <span class="keywordflow">while</span> ( xjunc.size() ) {
<a name="l00920"></a>00920     <a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a>[xjunc.front()][yjunc.front()] = 1;
<a name="l00921"></a>00921     xjunc.pop_front();
<a name="l00922"></a>00922     yjunc.pop_front();
<a name="l00923"></a>00923   }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   <span class="comment">// Construct the list of junction cluster centres</span>
<a name="l00926"></a>00926   <a class="code" href="structosl__edge__detector.html#ac0bcf90a8702a10781b3aa210de56c69">vlist_</a>-&gt;clear();
<a name="l00927"></a>00927   <span class="keywordflow">for</span> (vcl_list&lt;int&gt;::iterator i=xvertices.begin(), j=yvertices.begin();
<a name="l00928"></a>00928        i!=xvertices.end() &amp;&amp; j!=yvertices.end();
<a name="l00929"></a>00929        ++i, ++j) {
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     <a class="code" href="classosl__vertex.html">osl_Vertex</a> *<a class="codeRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a> = <span class="keyword">new</span> <a class="code" href="osl__vertex_8h.html#a9feda5bab497658648b7ad9fe3a325da">osl_Vertex</a>( <span class="keywordtype">float</span>((*i)<span class="comment">/*xvertices.value()*/</span>+<a class="code" href="structosl__edge__detector.html#a5e9e2ef0045946128f5c565f429d1efd">xstart_</a>),
<a name="l00932"></a>00932                                     <span class="keywordtype">float</span>((*j)<span class="comment">/*yvertices.value()*/</span>+<a class="code" href="structosl__edge__detector.html#a6d5d9183a13486dd2c5d599d8306837d">ystart_</a>));
<a name="l00933"></a>00933     <a class="code" href="structosl__edge__detector.html#ac0bcf90a8702a10781b3aa210de56c69">vlist_</a>-&gt;push_front(v);
<a name="l00934"></a>00934     <a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a>[(*i)<span class="comment">/*xvertices.value()*/</span>][(*j)<span class="comment">/*yvertices.value()*/</span>] = 2;
<a name="l00935"></a>00935   }
<a name="l00936"></a>00936 
<a name="l00937"></a>00937   xvertices.clear();
<a name="l00938"></a>00938   yvertices.clear();
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 
<a name="l00942"></a>00942 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00943"></a>00943 <span class="comment">//</span>
<a name="l00944"></a>00944 <span class="comment">//: Following routine looking for searching out junction clusters.</span>
<a name="l00945"></a>00945 <span class="comment">//</span>
<a name="l00946"></a><a class="code" href="structosl__edge__detector.html#a4933ae49aca8978e1c27d9cb6e95611a">00946</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#a4933ae49aca8978e1c27d9cb6e95611a" title="Following routine looking for searching out junction clusters.">osl_edge_detector::Follow_junctions</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, vcl_list&lt;int&gt; *xc, vcl_list&lt;int&gt; *yc)
<a name="l00947"></a>00947 {
<a name="l00948"></a>00948   <span class="comment">// Add the current junction to the coordinate lists, and delete from</span>
<a name="l00949"></a>00949   <span class="comment">// the junction image</span>
<a name="l00950"></a>00950   xc-&gt;push_front(x);
<a name="l00951"></a>00951   yc-&gt;push_front(y);
<a name="l00952"></a>00952   <a class="code" href="structosl__edge__detector.html#a0a42d7de2904bca23e8d18693ed4a8ef">junction_</a>[x][y] = 0;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   <span class="comment">// Now recursively look for connected eight-neighbours</span>
<a name="l00955"></a>00955   <span class="comment">//    5 0 4</span>
<a name="l00956"></a>00956   <span class="comment">//    1 * 3</span>
<a name="l00957"></a>00957   <span class="comment">//    6 2 7</span>
<a name="l00958"></a>00958 <span class="preprocessor">#define smoo(a, b) \</span>
<a name="l00959"></a>00959 <span class="preprocessor">  if ( junction_[a][b] ) Follow_junctions(a,b, xc,yc);</span>
<a name="l00960"></a>00960 <span class="preprocessor"></span>  <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x  , y-1)
<a name="l00961"></a>00961   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y  )
<a name="l00962"></a>00962   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x  , y+1)
<a name="l00963"></a>00963   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y  )
<a name="l00964"></a>00964   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y-1)
<a name="l00965"></a>00965   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y-1)
<a name="l00966"></a>00966   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x-1, y+1)
<a name="l00967"></a>00967   <a class="code" href="osl__canny__ox_8cxx.html#a1f2da15f1ecae05d77b46527b9f0a393">smoo</a>(x+1, y+1)
<a name="l00968"></a>00968 <span class="preprocessor">#undef smoo</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span>}
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00973"></a>00973 <span class="comment">//</span>
<a name="l00974"></a>00974 <span class="comment">//: Finds which member of the lists lies closest to the centre of the list.</span>
<a name="l00975"></a>00975 <span class="comment">//</span>
<a name="l00976"></a>00976 <span class="comment">//</span>
<a name="l00977"></a><a class="code" href="structosl__edge__detector.html#a951b8ed622877dc42b2d5f84d1ca7508">00977</a> <span class="keywordtype">void</span> <a class="code" href="structosl__edge__detector.html#a951b8ed622877dc42b2d5f84d1ca7508" title="Finds which member of the lists lies closest to the centre of the list.">osl_edge_detector::Cluster_centre</a>(vcl_list&lt;int&gt; &amp;xc,
<a name="l00978"></a>00978                                        vcl_list&lt;int&gt; &amp;yc,
<a name="l00979"></a>00979                                        <span class="keywordtype">int</span> &amp;x0,
<a name="l00980"></a>00980                                        <span class="keywordtype">int</span> &amp;y0)
<a name="l00981"></a>00981 {
<a name="l00982"></a>00982   <span class="keywordflow">if</span> ( xc.empty() )
<a name="l00983"></a>00983     <span class="keywordflow">return</span>;
<a name="l00984"></a>00984 
<a name="l00985"></a>00985 <span class="preprocessor">#if 0 // commented out</span>
<a name="l00986"></a>00986 <span class="preprocessor"></span>  <span class="comment">// First find the CofG</span>
<a name="l00987"></a>00987   <span class="keywordtype">double</span> x=0.0,y=0.0;
<a name="l00988"></a>00988   <span class="keywordflow">for</span> (xc.reset(),yc.reset(); xc.next(),yc.next(); )
<a name="l00989"></a>00989   {
<a name="l00990"></a>00990     x += xc.value();  y += yc.value();
<a name="l00991"></a>00991   }
<a name="l00992"></a>00992   x /= xc.size();  y /= yc.size();
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   <span class="comment">// Now find the point closest to the CofG</span>
<a name="l00995"></a>00995   <span class="keywordtype">float</span> dist,newdist;
<a name="l00996"></a>00996   dist = <a class="code" href="structosl__edge__detector.html#a9fdcc0fd289bbfe140a00ce9b977a52b">xsize_</a>*<a class="code" href="structosl__edge__detector.html#adb0d9834195270b17574d293e5557710">ysize_</a>; <span class="comment">// A number larger than the image size</span>
<a name="l00997"></a>00997   <span class="keywordflow">for</span> (xc.reset(),yc.reset(); xc.next(),yc.next(); )
<a name="l00998"></a>00998     <span class="keywordflow">if</span> ( (newdist=hypot(x-xc.value(),y-yc.value())) &lt; dist )
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000       x0 = xc.value();  y0 = yc.value();
<a name="l01001"></a>01001       dist = newdist;
<a name="l01002"></a>01002     }
<a name="l01003"></a>01003 <span class="preprocessor">#endif</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span>
<a name="l01005"></a>01005   <span class="keyword">typedef</span> vcl_list&lt;int&gt;::iterator it;
<a name="l01006"></a>01006 
<a name="l01007"></a>01007   <span class="comment">// Define the centre as the point with the highest gradient value.</span>
<a name="l01008"></a>01008   <span class="keywordtype">float</span> grad = -1.0;  <span class="comment">// Negative is smaller than the smallest norm of gradient</span>
<a name="l01009"></a>01009   <span class="keywordflow">for</span> (it i=xc.begin(),j=yc.begin(); i!=xc.end() &amp;&amp; j!=yc.end(); ++i, ++j)
<a name="l01010"></a>01010     <span class="comment">//xc.reset(),yc.reset(); xc.next(),yc.next(); )</span>
<a name="l01011"></a>01011     <span class="keywordflow">if</span> ( <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[(*i)<span class="comment">/*xc.value()*/</span>][(*j)<span class="comment">/*yc.value()*/</span>] &gt; grad ) {
<a name="l01012"></a>01012       grad = <a class="code" href="structosl__edge__detector.html#ae77bfe367f8517de7b75dc1ee039732e">grad_</a>[(*i)<span class="comment">/*xc.value()*/</span>][(*j)<span class="comment">/*yc.value()*/</span>];
<a name="l01013"></a>01013       x0 = (*i);<span class="comment">//xc.value();</span>
<a name="l01014"></a>01014       y0 = (*j);<span class="comment">//yc.value();</span>
<a name="l01015"></a>01015     }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017   <span class="comment">// Set up the (jx_,jy_) arrays to point to the cluster centre</span>
<a name="l01018"></a>01018   <span class="keywordflow">for</span> (it i=xc.begin(), j=yc.begin(); i!=xc.end() &amp;&amp; j!=yc.end(); ++i, ++j) {
<a name="l01019"></a>01019     <span class="comment">//xc.reset(),yc.reset(); xc.next(),yc.next(); )  {</span>
<a name="l01020"></a>01020     <a class="code" href="structosl__edge__detector.html#a7936dd773024f85eea9f2e4979381e69">jx_</a>[(*i)<span class="comment">/*xc.value()*/</span>][(*j)<span class="comment">/*yc.value()*/</span>] = x0;
<a name="l01021"></a>01021     <a class="code" href="structosl__edge__detector.html#abfe074de640c9e225d91b97589265d9e">jy_</a>[(*i)<span class="comment">/*xc.value()*/</span>][(*j)<span class="comment">/*yc.value()*/</span>] = y0;
<a name="l01022"></a>01022   }
<a name="l01023"></a>01023 }
<a name="l01024"></a>01024 
<a name="l01025"></a>01025 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l01026"></a>01026 
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:37:11 for contrib/oxl/osl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
