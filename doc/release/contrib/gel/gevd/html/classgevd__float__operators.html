<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>gevd_float_operators Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">gevd_float_operators Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="gevd_float_operators" -->
<p><code>#include &lt;<a class="el" href="gevd__float__operators_8h_source.html">gevd_float_operators.h</a>&gt;</code></p>

<p><a href="classgevd__float__operators-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#af2fc7c1baa1bdb68c63ac8d357660911">Convolve</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;from, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;kernel, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves <em>from</em> image with 2D filter and stores values in <em>to</em> image.  <a href="#af2fc7c1baa1bdb68c63ac8d357660911"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#add5ae082710726af0380e5da09013fd7">Read2dKernel</a> (const char *filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 2D kernel from a <a href="file:">file:</a> width height k_x_y ....  <a href="#add5ae082710726af0380e5da09013fd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a4e01bb773230ca5a199f97fb7bb5cc59">Convolve</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;from, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to, const float *xkernel, const int xradius, const bool xevenp, const float *ykernel, const int yradius, const bool yevenp, const bool xwrap=false, const bool ywrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves <em>from</em> image with two separable filters, along directions x and y, and stores values in <em>to</em> image.  <a href="#a4e01bb773230ca5a199f97fb7bb5cc59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a3757960bc53f657be354fee4e9b82a1a">Convolve</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;from, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to, const float *xkernel, const int xradius, const bool xevenp, const int yradius, const bool xwrap=false, const bool ywrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves <em>from</em> image with a filter along x, and a running sum along y-axis, then stores values in <em>to</em> image.  <a href="#a3757960bc53f657be354fee4e9b82a1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ae2a517f61b742ad7d7c890822a8d92b5">Convolve</a> (const float *from, float *&amp;to, const int len, const float *kernel, const int radius, const bool evenp, const bool wrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a linear array of data, wrapping at the 2 ends.  <a href="#ae2a517f61b742ad7d7c890822a8d92b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a5b3d459069aa4f968a505afd5e6202a6">RunningSum</a> (float *from, float *&amp;to, const int len, const int radius, const bool wrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For large smoothing sigma, use running sum to avoid floating multiplications.  <a href="#a5b3d459069aa4f968a505afd5e6202a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a4b27ef2af7b6b16c747b59a46aa97d04">Read1dKernel</a> (const char *filename, float *&amp;kernel, int &amp;radius, bool &amp;evenp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 1d odd/even kernel from a <a href="file:">file:</a> width k_i ....  <a href="#a4b27ef2af7b6b16c747b59a46aa97d04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#added6496fa5354411cb229dffe638145">Gaussian</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;img, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;smooth, const float sigma=1.0f, const bool xwrap=false, const bool ywrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves the <em>from</em> image with a 2D Gaussian filter with standard deviation <em>sigma</em>.  <a href="#added6496fa5354411cb229dffe638145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a0b972627bb1b687c8cebd96a2a15d071">Find1dGaussianKernel</a> (const float sigma, float *&amp;kernel, int &amp;radius, const float fuzz=0.02f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kernel array for Gaussian with given standard deviation <em>sigma</em> [pixel], and cutoff at min/max = <em>fuzz</em>.  <a href="#a0b972627bb1b687c8cebd96a2a15d071"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ab97b63b5f25560f7c37ad52b77bd4e76">Gradient</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;smooth, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;mag, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;dirx, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;diry, const bool xwrap=false, const bool ywrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the intensity surface.  <a href="#ab97b63b5f25560f7c37ad52b77bd4e76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#af8d139c37b132338ab6507987c5f4024">Slope</a> (float *from, float *&amp;to, const int len, const bool wrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute slope or first-difference, in linear/circular array.  <a href="#af8d139c37b132338ab6507987c5f4024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a24f953cbb7eb314935cdd6bdf6031c21">Hessian</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;smooth, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;mag, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;dirx, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;diry, const bool xwrap=false, const bool ywrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hessian of the intensity surface.  <a href="#a24f953cbb7eb314935cdd6bdf6031c21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a868c1ed255c394cac224be4679d1ec2e">Laplacian</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;smooth, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;mag, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;dirx, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;diry, const bool xwrap=false, const bool ywrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Laplacian of the intensity surface.  <a href="#a868c1ed255c394cac224be4679d1ec2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a6a05a2886bca632e8235d2f60beed242">Curvature</a> (float *from, float *&amp;to, const int len, const bool wrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute curvature, or 2nd-difference in linear/circular array.  <a href="#a6a05a2886bca632e8235d2f60beed242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a635853488300d1f14e3b87c592317541">Orientation</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;smooth, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;theta, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;coherence, const int frame=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the local orientation at each pixel in the image, and returns 2 images: twice the angle, and coherence measure (0,1).  <a href="#a635853488300d1f14e3b87c592317541"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a70e601f9fb928c16596b86d482578a02">NonMaximumSuppression</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;magnitude, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;directionx, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;directiony, const float threshold, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;contour, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;direction, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;locationx, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;locationy, const bool xwrap=false, const bool ywrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect contour pixels as strict local maxima, and interpolate the strength/location with a parabola through 3 points.  <a href="#a70e601f9fb928c16596b86d482578a02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a38673fb3f050d8bb05502d2cda1b2a66">NonMaximumSuppression</a> (const float *from, const int len, const float threshold, int *&amp;index, float *&amp;mag, float *&amp;locs, const bool wrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect local maxima in linear/circular array.  <a href="#a38673fb3f050d8bb05502d2cda1b2a66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aa22020b5e6a82580712de8292d291a87">InterpolateParabola</a> (float y1, float y0, float y2, float &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a parabola through 3 points with strict local max/min.  <a href="#aa22020b5e6a82580712de8292d291a87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aabcc959328a4e102125ddb1ff329c8f4">BilinearInterpolate</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;img, float x, float y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the float value of pixel (x, y) in float buffer, using bilinear interpolation.  <a href="#aabcc959328a4e102125ddb1ff329c8f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#af5f14d8c6f2870d3d57103a900206c06">SupportAngle</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;dirx, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;diry, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;magnitude, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;<a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__vector__fixed__ref_8h.html#a0a73c08cb73355598c69dfa10add389a">angle</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find angle of the line of support, in degrees.  <a href="#af5f14d8c6f2870d3d57103a900206c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ae89d06e33fa86aa6b90a4c5c86072de9">SurfaceNormal</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;range, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;normal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local surface normal at all pixels in the range z(x,y) image.  <a href="#ae89d06e33fa86aa6b90a4c5c86072de9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a2076a04a9ba4d23f547bd9f7e396655b">SurfaceCurvature</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;normal, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;curvature)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local gaussian curvature at all pixels from the local surface normals, previously computed from the range z(x,y) image.  <a href="#a2076a04a9ba4d23f547bd9f7e396655b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a60fca4d67f903c1ec5c9ce04d70080ef">SurfaceNormalD</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;range, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;normal, float no_value, float pixel_distance=1.0f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classgevd__float__operators.html#ae89d06e33fa86aa6b90a4c5c86072de9" title="Find local surface normal at all pixels in the range z(x,y) image.">gevd_float_operators::SurfaceNormal</a> with two exceptions.  <a href="#a60fca4d67f903c1ec5c9ce04d70080ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#af6483b7c665252ff627859bc1fbd403e">SurfaceCurvatureD</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;normal, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;surface, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;curvature, float dflt, float pixel_distance=1.0f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the maximum curvature at all pixels from the local surface normals, previously computed from the range z(x,y) image.  <a href="#af6483b7c665252ff627859bc1fbd403e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ab331874ed8ed644cd04a09675b2155d3">ShrinkBy2</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;cfrom, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to, const float burt_ka=0.359375f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the <em>from</em> image by 2 and stores into <em>to</em> image, using Burt-Adelson reduction algorithm.  <a href="#ab331874ed8ed644cd04a09675b2155d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a10a16da10d026797d5a0f48045846c98">ExpandBy2</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;cfrom, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to, const float burt_ka=0.359375f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the <em>from</em> image by 2 and store into <em>to</em> image, using Burt-Adelson expansion algorithm.  <a href="#a10a16da10d026797d5a0f48045846c98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a676f18190a31b96019d581aa4f044830">ShrinkBy2_D</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;from, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to, float no_value, float burt_ka=0.359375f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the <em>from</em> image by 2 and stores into <em>to</em> image.  <a href="#a676f18190a31b96019d581aa4f044830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a0c8b06c0c80cae6d66b6d721c73dbed0">Pyramid</a> (const float *from, const int <a class="elRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/vgl__vector__3d_8h.html#a31c7db8164e71d411a1a821525102dc3">length</a>, float *&amp;to, int &amp;nlevels, int trim=0, const float burt_ka=0.359375f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the pyramid by shrinking data sequence by 2, nlevels-1 times, and return final shrunk length, and reset number of levels in pyramid.  <a href="#a0c8b06c0c80cae6d66b6d721c73dbed0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aa28f010f44e1b4b01efc54ee35585642">ShrinkBy2</a> (const float *from, const int <a class="elRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/vgl__vector__3d_8h.html#a31c7db8164e71d411a1a821525102dc3">length</a>, float *&amp;to, const float burt_ka=0.359375f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a3e7a0d96d6241af66b2cb312c253591f">WaveletTransform</a> (float *array, const int n, const bool forwardp, int nlevels, const int waveletno=4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the forward/inverse wavelet transform of a 1d array of data.  <a href="#a3e7a0d96d6241af66b2cb312c253591f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a6852b582f1079b5da0dd8206c6fb9d4c">WaveletTransformByBlock</a> (float *array, const int *dims, const int ndim, const bool forwardp, int nlevels, const int waveletno=4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">n-dimensional wavelet transform of an n-dimensional array.  <a href="#a6852b582f1079b5da0dd8206c6fb9d4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a1a9679591c857ea4047f23437c0df344">WaveletTransformByIndex</a> (float *array, const int *dims, const int ndim, const bool forwardp, int nlevels, const int waveletno=4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">n-dimensional wavelet transform of an n-dimensional array.  <a href="#a1a9679591c857ea4047f23437c0df344"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a971e34f6f216e9f9379ce016cee8ed47">FindWavelet</a> (const int waveletno, float *&amp;cc, float *&amp;cr, int &amp;ncof)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up and stores the wavelet pair in (<em>lo_filter</em>, <em>hi_filter</em>).  <a href="#a971e34f6f216e9f9379ce016cee8ed47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a21ca1708bc348602893345e776008060">LowHighPyramid</a> (float *highPass, float *lowPass, int n, int nlevels, const float *lo_filter, const float *hi_filter, int ncof, float *wksp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find pyramid of low/high pass components, using wavelet transform.  <a href="#a21ca1708bc348602893345e776008060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ab0dca678e4dcdb393a6a971e8a33c212">WaveletTransformByBlock</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;cfrom, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to, const bool forwardp, int nlevels, const int waveletno=4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Fast Wavelet Transform of the image.  <a href="#ab0dca678e4dcdb393a6a971e8a33c212"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a93f8a9498d7a0717efbc804226b0cdd3">WaveletTransformByIndex</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;cfrom, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to, const bool forwardp, int nlevels, const int waveletno=4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Fast Wavelet Transform of the 2d array.  <a href="#a93f8a9498d7a0717efbc804226b0cdd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#afb20d0c75a82f0bf06d5d3fcc47407e4">DeleteMixedComponents</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;wave, const int nlevels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all wavelet components, which have high frequency along both x- and y- axes.  <a href="#afb20d0c75a82f0bf06d5d3fcc47407e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a051c8e2b43da2bc756a9b27e313231e0">TruncateHighFrequencies</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;wave, const int nlevels, const float threshold=0.1f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate to 0, all wavelet components with high frequency along either x- or y- axes only, not both.  <a href="#a051c8e2b43da2bc756a9b27e313231e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a312c45d027b65a44ef077130afcb05d6">TruncateLowestFrequency</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;wave, const int nlevels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate to average value, the lowest frequency component.  <a href="#a312c45d027b65a44ef077130afcb05d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#af8e2a61bd7038ff965f92ca118bb45a1">DeleteBoundaryArtifacts</a> (float *wave, const int n, const int nlevels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete boundary artefacts in 1d-array, because its length is not a power of 2, and so wrapping will skip the last odd element.  <a href="#af8e2a61bd7038ff965f92ca118bb45a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a0447a3165f3d15670fbd3190dabe8768">DeleteBoundaryArtifacts</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;wave, const int nlevels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete boundary artefacts because the dimension of the image is not a power of 2, and so wrapping will skip the last odd element.  <a href="#a0447a3165f3d15670fbd3190dabe8768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aecb70f8c2902561fb3378f64e0d911ab">ProjectWaveOntoX</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, float *&amp;proj, const int nlevels=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Project wavelet components onto the axes.  <a href="#aecb70f8c2902561fb3378f64e0d911ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a9b42e49428db59cff14981af550a3570">ProjectWaveOntoY</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, float *&amp;proj, const int nlevels=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aaddd77814bd644b4508d8cdcfb4db786">ProjectOntoX</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, float *&amp;proj, int sizeX=0, int sizeY=0, int origX=0, int origY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the image data in ROI onto the x- and y- axes.  <a href="#aaddd77814bd644b4508d8cdcfb4db786"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#adf2fd45c45fb8cac4aa52c3846fa0345">ProjectOntoY</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, float *&amp;proj, int sizeX=0, int sizeY=0, int origX=0, int origY=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a96d1c8cbc5302231da43291b2774acc6">Correlation</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;from, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;kernel, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlate <em>from</em> image with 2D filter and stores values in <em>to</em> image.  <a href="#a96d1c8cbc5302231da43291b2774acc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a063c875ea6d09d7e2696dac393abfb17">CorrelationAlongAxis</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;from, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;kernel, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;to)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlate <em>from</em> image with 2D filter and stores values in <em>to</em> image.  <a href="#a063c875ea6d09d7e2696dac393abfb17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#af1bca5217c134c6e3f45817b4b3e00d6">Correlation</a> (const float *data, const int <a class="elRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/vgl__vector__3d_8h.html#a31c7db8164e71d411a1a821525102dc3">length</a>, const float *pattern, const int radius, const int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find correlation of given pattern to data, matching pattern[radius+i] with data[index+i].  <a href="#af1bca5217c134c6e3f45817b4b3e00d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a04c066523f25c4691b382c510e8423c1">Correlations</a> (const float *data, const int <a class="elRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/vgl__vector__3d_8h.html#a31c7db8164e71d411a1a821525102dc3">length</a>, const float *pattern, const int radius, const int index, const int search)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find correlations of given pattern to data, given maximum search from index.  <a href="#a04c066523f25c4691b382c510e8423c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a25029eae131c7bd2a59c81a0a2441630">BestCorrelation</a> (const float *data, const int <a class="elRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/vgl__vector__3d_8h.html#a31c7db8164e71d411a1a821525102dc3">length</a>, const float *pattern, const int radius, int &amp;shift, const int search)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find correlation, and return correlation and shift values.  <a href="#a25029eae131c7bd2a59c81a0a2441630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ad241c23d2cd5a66971269a9c5b1404d1">CoarseFineCorrelation</a> (const float *dataPyr, const int dlength, const float *patternPyr, const int plength, float &amp;shift, const int coarse, const int fine, const float cutoff=0, const float overlap=0.75f, float *matches=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for best correlation, from coarse to fine, starting at a priori shift, and requiring minimum overlap.  <a href="#ad241c23d2cd5a66971269a9c5b1404d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ad3bb50b5ef09bdab419ac546a0ae319f">Apply</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, float(*func)(float))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply function to all elements in buffer.  <a href="#ad3bb50b5ef09bdab419ac546a0ae319f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a04266ec9ccf094f108871485d362a4bc">AbsoluteDifference</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf1, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a5b540fb46f4ecac4e8a665d6444a3cb1">Allocate</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *space, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;model, int bits_per_pixel=0, int sizeX=0, int sizeY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new space if desired depth and sizes are not the same.  <a href="#a5b540fb46f4ecac4e8a665d6444a3cb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a824bc51a5db748afd30cdef306a5a122">SimilarBuffer</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buffer, int bits_per_pixel=0, int sizeX=0, int sizeY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new buffer similar to buf, unless dimension and precision are given.  <a href="#a824bc51a5db748afd30cdef306a5a122"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a22db8b4e97c8a5533b03e9def2458894">IsSimilarBuffer</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf1, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Two buffers are similar if they have the same dimensions, and precision (bits_per_pixel).  <a href="#a22db8b4e97c8a5533b03e9def2458894"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a986b231ac5cbeb45ba93eff891a8fab7">Extract</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, int sizeX=0, int sizeY=0, int origX=0, int origY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from buf, a float sub-buffer with dimensions (sizeX, sizeY), from top-left corner (origX, origY).  <a href="#a986b231ac5cbeb45ba93eff891a8fab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a59ce32ff7bc0c2452e520e0559320784">Update</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;old_buf, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;new_buf, int origX=0, int origY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a float sub-buffer of <em>buf</em>, from top-left corner (origX, origY), with values in <em>sub</em>.  <a href="#a59ce32ff7bc0c2452e520e0559320784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ac71a14b3007df5035badb3a3da00beae">TransposeExtract</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, int sizeX, int sizeY, int origX, int origY)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a2545c33f194fc14b46e300feebaa8c24">TransposeUpdate</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;sub, int origX, int origY)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aa4fa73649cd0e39589f0797fbf96e838">Fill</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, const float value, int sizeX=0, int sizeY=0, int origX=0, int origY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all pixels in ROI to value.  <a href="#aa4fa73649cd0e39589f0797fbf96e838"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#add2091792af36dd424740a4e79d4a237">FillFrameX</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, const float value, const int width=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all pixels in the frame region to value (default = 0).  <a href="#add2091792af36dd424740a4e79d4a237"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a1aea7d862ebd733c4f4b077bd3a42cbe">FillFrameY</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, const float value, const int width=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a66746f630157be92225cf975109c80c2">DrawFrame</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, const int loc, const float value=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all pixels on frame contour, such as buf(loc, i), to value.  <a href="#a66746f630157be92225cf975109c80c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aa162f3f9ebd2ce67ca1ce6fea3957831">PadToPowerOf2</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the buffer by repeating values at the border, so that the new buffer has dimensions being powers of 2.  <a href="#aa162f3f9ebd2ce67ca1ce6fea3957831"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ae92d0f5801ed4afeaa0725a54d764356">UnpadFromPowerOf2</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;padded, int sizeX, int sizeY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of the above operation.  <a href="#ae92d0f5801ed4afeaa0725a54d764356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a1cb5fa84664e87cb33e07b534c6c5102">Maximum</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, int sizeX=0, int sizeY=0, int origX=0, int origY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value in float buffer.  <a href="#a1cb5fa84664e87cb33e07b534c6c5102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a46c649646175bb697877d5e3495ca9a6">Minimum</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, int sizeX=0, int sizeY=0, int origX=0, int origY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum value in float buffer.  <a href="#a46c649646175bb697877d5e3495ca9a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ad543b11ef464377f7755b482f369421a">Maximum</a> (const float *data, const int <a class="elRef" doxygen="core_vgl.tag:../../../../core/vgl/html" href="../../../../core/vgl/html/vgl__vector__3d_8h.html#a31c7db8164e71d411a1a821525102dc3">length</a>, int &amp;index, float &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect maximum in 1d-array of values.  <a href="#ad543b11ef464377f7755b482f369421a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a70d3b60ced56ea57d9aa8ef6334ce491">Sum</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, int sizeX=0, int sizeY=0, int origX=0, int origY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all values in float buffer.  <a href="#a70d3b60ced56ea57d9aa8ef6334ce491"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a066c8b4d3a757fb2959ed626c35037a8">Threshold</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, float noise, int sizeX=0, int sizeY=0, int origX=0, int origY=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate all values in ROI to 0, if below noise.  <a href="#a066c8b4d3a757fb2959ed626c35037a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ae52801fb1325d8c99fb65ca778a7a1c2">TruncateToPositive</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeros out all negative values.  <a href="#ae52801fb1325d8c99fb65ca778a7a1c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ace6867c107dc7208a3a43a574dc7af57">TruncateToCeiling</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, float <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__rational_8h.html#a5c4f7fa34a49ccca2bdb0d2b388051ec">ceil</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a6b77218d91a09e772eb06485a94420fb">Absolute</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace with absolute values.  <a href="#a6b77218d91a09e772eb06485a94420fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#afb8d319f14beab9baac90478710997bd">Negate</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate all values.  <a href="#afb8d319f14beab9baac90478710997bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#affae827367c0da040c8983b5c3ef6015">Scale</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, float factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale all values by factor.  <a href="#affae827367c0da040c8983b5c3ef6015"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#ab9e71cce4ae9f19ea21b73f3248be62a">ShiftToPositive</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift to positive values, by adding 30.0000, and truncate all values to 0-60.000.  <a href="#ab9e71cce4ae9f19ea21b73f3248be62a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a37a38f714c140159dbcbc0faeede03d3">Normalize</a> (<a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;buf, const float lo, const float hi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a float buffer so that the pixel values range from <em>lo</em> to <em>hi</em>, inclusive.  <a href="#a37a38f714c140159dbcbc0faeede03d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aa935dd19f70eaa1a412f17fbd9d07876">BufferToFloat</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;from, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;floatto)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a unsigned char (8-bit) or a short (16-bit) buffer to a float buffer to avoid overflow/underflow and conversion for subsequent math computations.  <a href="#aa935dd19f70eaa1a412f17fbd9d07876"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a193e331639f6811b4a64634ae0cb9b97">FloatToBuffer</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;floatfrom, <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;to)</td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aafd62806d4cb397f07852770d168b258">SetupPipeline</a> (const float *data, const int len, const int kradius, const bool wrap, float *&amp;cache, float *&amp;pipeline)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the cache for reflection/wrapping at the borders, and the center pipeline.  <a href="#aafd62806d4cb397f07852770d168b258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a894545aa9c77e332bd3a1914fd0c0b7e">WrapAlongX</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;img)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a buffer that wraps rows/columns.  <a href="#a894545aa9c77e332bd3a1914fd0c0b7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a43649f2c4bbbda765713cd679acbd7f3">WrapAlongY</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;img)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a1271a695f2addc30aa46a826df1e2ddf">Gaussian</a> (const float x, const float sigma)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a106eeba665925277d71961746259228f">ShrinkBy2AlongX</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;cfrom, const int y, float *yline, const int len, const float ka, const float kb, const float kc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the yline by 2 along the x-axis.  <a href="#a106eeba665925277d71961746259228f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a9e0e1a97b9f7c4e9814406191054aef3">ShrinkBy2AlongX_D</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;from, int from_sizeX, int sizeX, int y, float kernel[], float no_value, float *yline, float *wline)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a smoothed and subsampled array of x values in the given row.  <a href="#a9e0e1a97b9f7c4e9814406191054aef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aba98ec8759b22b5417688d4a85df16b1">ExpandBy2AlongX</a> (const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;cfrom, const int y, float *yline, const int len, const float ka, const float kb, const float kc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the yline by 2 along the x-axis.  <a href="#aba98ec8759b22b5417688d4a85df16b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a1e66970ff8d396fc76e78cb96820bbb2">WaveletTransformStep</a> (float *array, const int n, const bool forwardp, const float *lo_filter, const float *hi_filter, const int ncof, float *wksp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution with wavelets (<em>lo_filter</em>, <em>hi_filter</em>) and gather results into consecutive blocks, with convolution of <em>lo_filter</em> (resp.  <a href="#a1e66970ff8d396fc76e78cb96820bbb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a5e93387ce99e8b1701d853f605047ee1">WaveletTransformStep</a> (float *array, const int *dims, const int ndim, const bool forwardp, const float *lo_filter, const float *hi_filter, const int ncof, float *buffer, float *wksp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a4bf3e0df3c5a298474028200cf32cd5d">CopyNdRecursive</a> (const float *from_array, const int from_size, const int *from_dims, float *to_array, const int to_size, const int *to_dims, const int ndim, const bool fullp=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively copies elements of n-dimensional arrays.  <a href="#a4bf3e0df3c5a298474028200cf32cd5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#a162fce826738f6d4378dbb900a387d47">TestWavelets</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevd__float__operators.html#aaffda229e34d61525969998234b17e9f">gevd_float_operators</a> ()</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="gevd__float__operators_8h_source.html#l00042">42</a> of file <a class="el" href="gevd__float__operators_8h_source.html">gevd_float_operators.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaffda229e34d61525969998234b17e9f"></a><!-- doxytag: member="gevd_float_operators::gevd_float_operators" ref="aaffda229e34d61525969998234b17e9f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gevd_float_operators::gevd_float_operators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6b77218d91a09e772eb06485a94420fb"></a><!-- doxytag: member="gevd_float_operators::Absolute" ref="a6b77218d91a09e772eb06485a94420fb" args="(gevd_bufferxy &amp;buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::Absolute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace with absolute values. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03835">3835</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a04266ec9ccf094f108871485d362a4bc"></a><!-- doxytag: member="gevd_float_operators::AbsoluteDifference" ref="a04266ec9ccf094f108871485d362a4bc" args="(const gevd_bufferxy &amp;buf1, const gevd_bufferxy &amp;buf2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::AbsoluteDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l04110">4110</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a5b540fb46f4ecac4e8a665d6444a3cb1"></a><!-- doxytag: member="gevd_float_operators::Allocate" ref="a5b540fb46f4ecac4e8a665d6444a3cb1" args="(gevd_bufferxy *space, const gevd_bufferxy &amp;model, int bits_per_pixel=0, int sizeX=0, int sizeY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::Allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits_per_pixel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate new space if desired depth and sizes are not the same. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03521">3521</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad3bb50b5ef09bdab419ac546a0ae319f"></a><!-- doxytag: member="gevd_float_operators::Apply" ref="ad3bb50b5ef09bdab419ac546a0ae319f" args="(gevd_bufferxy &amp;buf, float(*func)(float))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::Apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)(float)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply function to all elements in buffer. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03509">3509</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a25029eae131c7bd2a59c81a0a2441630"></a><!-- doxytag: member="gevd_float_operators::BestCorrelation" ref="a25029eae131c7bd2a59c81a0a2441630" args="(const float *data, const int length, const float *pattern, const int radius, int &amp;shift, const int search)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::BestCorrelation </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find correlation, and return correlation and shift values. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03366">3366</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aabcc959328a4e102125ddb1ff329c8f4"></a><!-- doxytag: member="gevd_float_operators::BilinearInterpolate" ref="aabcc959328a4e102125ddb1ff329c8f4" args="(const gevd_bufferxy &amp;img, float x, float y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::BilinearInterpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the float value of pixel (x, y) in float buffer, using bilinear interpolation. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01457">1457</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa935dd19f70eaa1a412f17fbd9d07876"></a><!-- doxytag: member="gevd_float_operators::BufferToFloat" ref="aa935dd19f70eaa1a412f17fbd9d07876" args="(const gevd_bufferxy &amp;from, gevd_bufferxy &amp;floatto)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::BufferToFloat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts from a unsigned char (8-bit) or a short (16-bit) buffer to a float buffer to avoid overflow/underflow and conversion for subsequent math computations. </p>
<p>O(n*m). </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03880">3880</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad241c23d2cd5a66971269a9c5b1404d1"></a><!-- doxytag: member="gevd_float_operators::CoarseFineCorrelation" ref="ad241c23d2cd5a66971269a9c5b1404d1" args="(const float *dataPyr, const int dlength, const float *patternPyr, const int plength, float &amp;shift, const int coarse, const int fine, const float cutoff=0, const float overlap=0.75f, float *matches=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::CoarseFineCorrelation </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>dataPyr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>patternPyr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>plength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>overlap</em> = <code>0.75f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>matches</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for best correlation, from coarse to fine, starting at a priori shift, and requiring minimum overlap. </p>
<p>O(n) time. Return last best correlation, and its corresponding shift. The search is cutoff early, if no maximum is found, or maximum correlation &lt;= cutoff. Accumulate match values if matches non null. Assumes data and pattern are pyramids. Compile with -DDEBUG to trace the coarse-to-fine search of the best correlation, </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03398">3398</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="af2fc7c1baa1bdb68c63ac8d357660911"></a><!-- doxytag: member="gevd_float_operators::Convolve" ref="af2fc7c1baa1bdb68c63ac8d357660911" args="(const gevd_bufferxy &amp;from, const gevd_bufferxy &amp;kernel, gevd_bufferxy *&amp;to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Convolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolves <em>from</em> image with 2D filter and stores values in <em>to</em> image. </p>
<p>O(m*n*k). The filter <em>kernel</em> has odd width and height, and is either even or odd along x- or y-axis. Assume image data is in row-major order.</p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00048">48</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a4e01bb773230ca5a199f97fb7bb5cc59"></a><!-- doxytag: member="gevd_float_operators::Convolve" ref="a4e01bb773230ca5a199f97fb7bb5cc59" args="(const gevd_bufferxy &amp;from, gevd_bufferxy *&amp;to, const float *xkernel, const int xradius, const bool xevenp, const float *ykernel, const int yradius, const bool yevenp, const bool xwrap=false, const bool ywrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Convolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>xkernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>xradius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xevenp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>ykernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>yradius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>yevenp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xwrap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ywrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolves <em>from</em> image with two separable filters, along directions x and y, and stores values in <em>to</em> image. </p>
<p>O(m*n*k). The filter <em>kernel</em> has length 2*radius + 1, and is either even or odd. Assume image data is in row-major order.</p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00229">229</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a3757960bc53f657be354fee4e9b82a1a"></a><!-- doxytag: member="gevd_float_operators::Convolve" ref="a3757960bc53f657be354fee4e9b82a1a" args="(const gevd_bufferxy &amp;from, gevd_bufferxy *&amp;to, const float *xkernel, const int xradius, const bool xevenp, const int yradius, const bool xwrap=false, const bool ywrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Convolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>xkernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>xradius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xevenp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>yradius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xwrap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ywrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolves <em>from</em> image with a filter along x, and a running sum along y-axis, then stores values in <em>to</em> image. </p>
<p>O(m*n*k). </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00379">379</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae2a517f61b742ad7d7c890822a8d92b5"></a><!-- doxytag: member="gevd_float_operators::Convolve" ref="ae2a517f61b742ad7d7c890822a8d92b5" args="(const float *from, float *&amp;to, const int len, const float *kernel, const int radius, const bool evenp, const bool wrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Convolve </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kradius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>evenp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolve a linear array of data, wrapping at the 2 ends. </p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00493">493</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a4bf3e0df3c5a298474028200cf32cd5d"></a><!-- doxytag: member="gevd_float_operators::CopyNdRecursive" ref="a4bf3e0df3c5a298474028200cf32cd5d" args="(const float *from_array, const int from_size, const int *from_dims, float *to_array, const int to_size, const int *to_dims, const int ndim, const bool fullp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::CopyNdRecursive </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>from_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>from_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>to_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>to_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>to_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fullp</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively copies elements of n-dimensional arrays. </p>
<p>Extra elements that can not fit in both arrays are not read or written. A flag fullp (default = true) is used to copy from/to a full n-dimensional array or only a sub-block of the array. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02818">2818</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a96d1c8cbc5302231da43291b2774acc6"></a><!-- doxytag: member="gevd_float_operators::Correlation" ref="a96d1c8cbc5302231da43291b2774acc6" args="(const gevd_bufferxy &amp;from, const gevd_bufferxy &amp;kernel, gevd_bufferxy *&amp;to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Correlation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Correlate <em>from</em> image with 2D filter and stores values in <em>to</em> image. </p>
<p>O(m*n*k). The filter <em>kernel</em> has odd width and height, and is either even or odd along x- or y-axis. Assume image data is in row-major order.</p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00090">90</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="af1bca5217c134c6e3f45817b4b3e00d6"></a><!-- doxytag: member="gevd_float_operators::Correlation" ref="af1bca5217c134c6e3f45817b4b3e00d6" args="(const float *data, const int length, const float *pattern, const int radius, const int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Correlation </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find correlation of given pattern to data, matching pattern[radius+i] with data[index+i]. </p>
<p>The linear correlation coefficient, also called Pearson r, is computed, O(|pattern|). Assumed pattern has length = 2*radius + 1. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03299">3299</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a063c875ea6d09d7e2696dac393abfb17"></a><!-- doxytag: member="gevd_float_operators::CorrelationAlongAxis" ref="a063c875ea6d09d7e2696dac393abfb17" args="(const gevd_bufferxy &amp;from, const gevd_bufferxy &amp;kernel, gevd_bufferxy *&amp;to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::CorrelationAlongAxis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Correlate <em>from</em> image with 2D filter and stores values in <em>to</em> image. </p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00140">140</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a04c066523f25c4691b382c510e8423c1"></a><!-- doxytag: member="gevd_float_operators::Correlations" ref="a04c066523f25c4691b382c510e8423c1" args="(const float *data, const int length, const float *pattern, const int radius, const int index, const int search)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gevd_float_operators::Correlations </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find correlations of given pattern to data, given maximum search from index. </p>
<p>O(|pattern|*shift). Returns the array of correlation values, with positive translation starting from result[search+1], and negative translation starting from result[search-1]. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03336">3336</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a6a05a2886bca632e8235d2f60beed242"></a><!-- doxytag: member="gevd_float_operators::Curvature" ref="a6a05a2886bca632e8235d2f60beed242" args="(float *from, float *&amp;to, const int len, const bool wrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Curvature </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute curvature, or 2nd-difference in linear/circular array. </p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01145">1145</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="af8e2a61bd7038ff965f92ca118bb45a1"></a><!-- doxytag: member="gevd_float_operators::DeleteBoundaryArtifacts" ref="af8e2a61bd7038ff965f92ca118bb45a1" args="(float *wave, const int n, const int nlevels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::DeleteBoundaryArtifacts </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>wave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nlevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete boundary artefacts in 1d-array, because its length is not a power of 2, and so wrapping will skip the last odd element. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03160">3160</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a0447a3165f3d15670fbd3190dabe8768"></a><!-- doxytag: member="gevd_float_operators::DeleteBoundaryArtifacts" ref="a0447a3165f3d15670fbd3190dabe8768" args="(gevd_bufferxy &amp;wave, const int nlevels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::DeleteBoundaryArtifacts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>wave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nlevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete boundary artefacts because the dimension of the image is not a power of 2, and so wrapping will skip the last odd element. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03185">3185</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="afb20d0c75a82f0bf06d5d3fcc47407e4"></a><!-- doxytag: member="gevd_float_operators::DeleteMixedComponents" ref="afb20d0c75a82f0bf06d5d3fcc47407e4" args="(gevd_bufferxy &amp;wave, const int nlevels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::DeleteMixedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>wave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nlevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete all wavelet components, which have high frequency along both x- and y- axes. </p>
<p>They are diagonal blocks, except the lowest frequency block. This will throw away high frequency point-like features. Return the number of coefficients deleted. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03083">3083</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a66746f630157be92225cf975109c80c2"></a><!-- doxytag: member="gevd_float_operators::DrawFrame" ref="a66746f630157be92225cf975109c80c2" args="(gevd_bufferxy &amp;buf, const int loc, const float value=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::DrawFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all pixels on frame contour, such as buf(loc, i), to value. </p>
<p>O(n+m). </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03656">3656</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a10a16da10d026797d5a0f48045846c98"></a><!-- doxytag: member="gevd_float_operators::ExpandBy2" ref="a10a16da10d026797d5a0f48045846c98" args="(const gevd_bufferxy &amp;cfrom, gevd_bufferxy *&amp;to, const float burt_ka=0.359375f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::ExpandBy2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>burt_ka</em> = <code>0.359375f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands the <em>from</em> image by 2 and store into <em>to</em> image, using Burt-Adelson expansion algorithm. </p>
<p>Convolution with a 5-point kernel [(0.5-ka), 0.5, 2*ka, 0.5, (0.5-ka)] ka = 0.6 maximum decorrelation, low-pass filter for image compression. ka = 0.5 linear interpolation, ka = 0.4 Gaussian filter, smoothing at tail. ka = 0.3 wider than Gaussian, for more smoothing. The image indexes are mapped with: to.ij = from.ij * 2 The image sizes are related by: to.size = from.size * 2.</p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02159">2159</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aba98ec8759b22b5417688d4a85df16b1"></a><!-- doxytag: member="gevd_float_operators::ExpandBy2AlongX" ref="aba98ec8759b22b5417688d4a85df16b1" args="(const gevd_bufferxy &amp;cfrom, const int y, float *yline, const int len, const float ka, const float kb, const float kc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::ExpandBy2AlongX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>yline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>ka</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>kc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands the yline by 2 along the x-axis. </p>
<p>Interpolation is done by convolution with pixels at integral indexes only. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02207">2207</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a986b231ac5cbeb45ba93eff891a8fab7"></a><!-- doxytag: member="gevd_float_operators::Extract" ref="a986b231ac5cbeb45ba93eff891a8fab7" args="(const gevd_bufferxy &amp;buf, int sizeX=0, int sizeY=0, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::Extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract from buf, a float sub-buffer with dimensions (sizeX, sizeY), from top-left corner (origX, origY). </p>
<p>Faster copying can be done with read/write chunks of memory. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03574">3574</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa4fa73649cd0e39589f0797fbf96e838"></a><!-- doxytag: member="gevd_float_operators::Fill" ref="aa4fa73649cd0e39589f0797fbf96e838" args="(gevd_bufferxy &amp;buf, const float value, int sizeX=0, int sizeY=0, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all pixels in ROI to value. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03604">3604</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="add2091792af36dd424740a4e79d4a237"></a><!-- doxytag: member="gevd_float_operators::FillFrameX" ref="add2091792af36dd424740a4e79d4a237" args="(gevd_bufferxy &amp;buf, const float value, const int width=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::FillFrameX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all pixels in the frame region to value (default = 0). </p>
<p>O((n+m)*width). The frame region is a rectangular band with given width, framing at two ends of x/y axes. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03624">3624</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1aea7d862ebd733c4f4b077bd3a42cbe"></a><!-- doxytag: member="gevd_float_operators::FillFrameY" ref="a1aea7d862ebd733c4f4b077bd3a42cbe" args="(gevd_bufferxy &amp;buf, const float value, const int width=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::FillFrameY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03639">3639</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a0b972627bb1b687c8cebd96a2a15d071"></a><!-- doxytag: member="gevd_float_operators::Find1dGaussianKernel" ref="a0b972627bb1b687c8cebd96a2a15d071" args="(const float sigma, float *&amp;kernel, int &amp;radius, const float fuzz=0.02f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::Find1dGaussianKernel </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>fuzz</em> = <code>0.02f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the kernel array for Gaussian with given standard deviation <em>sigma</em> [pixel], and cutoff at min/max = <em>fuzz</em>. </p>
<p>The area under the discrete Gaussian is normalized to 1. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00690">690</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a971e34f6f216e9f9379ce016cee8ed47"></a><!-- doxytag: member="gevd_float_operators::FindWavelet" ref="a971e34f6f216e9f9379ce016cee8ed47" args="(const int waveletno, float *&amp;cc, float *&amp;cr, int &amp;ncof)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::FindWavelet </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>waveletno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>lo_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>hi_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ncof</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up and stores the wavelet pair in (<em>lo_filter</em>, <em>hi_filter</em>). </p>
<p>The wavelet number is 2 for Haar wavelet, 4-20 even numbers for Daubechies wavelet, and 9-15 odd numbers for symmetric Coifman wavelets. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02458">2458</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a193e331639f6811b4a64634ae0cb9b97"></a><!-- doxytag: member="gevd_float_operators::FloatToBuffer" ref="a193e331639f6811b4a64634ae0cb9b97" args="(const gevd_bufferxy &amp;floatfrom, gevd_bufferxy &amp;to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::FloatToBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>floatfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03925">3925</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="added6496fa5354411cb229dffe638145"></a><!-- doxytag: member="gevd_float_operators::Gaussian" ref="added6496fa5354411cb229dffe638145" args="(gevd_bufferxy &amp;img, gevd_bufferxy *&amp;smooth, const float sigma=1.0f, const bool xwrap=false, const bool ywrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Gaussian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xwrap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ywrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolves the <em>from</em> image with a 2D Gaussian filter with standard deviation <em>sigma</em>. </p>
<p>O(m*n*k). The 2D convolution is decomposed into 2 1D convolutions: Gxy * I = Gy * (Gx * I). The frame with width equal to the radius of the Gaussian kernel is filled with zero. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00661">661</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1271a695f2addc30aa46a826df1e2ddf"></a><!-- doxytag: member="gevd_float_operators::Gaussian" ref="a1271a695f2addc30aa46a826df1e2ddf" args="(const float x, const float sigma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Gaussian </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00718">718</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ab97b63b5f25560f7c37ad52b77bd4e76"></a><!-- doxytag: member="gevd_float_operators::Gradient" ref="ab97b63b5f25560f7c37ad52b77bd4e76" args="(const gevd_bufferxy &amp;smooth, gevd_bufferxy *&amp;mag, gevd_bufferxy *&amp;dirx, gevd_bufferxy *&amp;diry, const bool xwrap=false, const bool ywrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>smooth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>gradx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>grady</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xwrap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ywrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the gradient of the intensity surface. </p>
<p>O(m*n). The intensity surface is assumed smoothed by a Gaussian filter, or convolved with a low-pass filter. Return at each pixel, the magnitude, the vector (dG * I), and the multiplication factor to normalize the magnitude. The product of detection |dG * I| and localization |dddG * I| of the step relative to noise is invariant to filter-size for the ideal step edge, and depends only on the shape of the step edge. As the filter size (sigma) increases by k, detection or signal-to-noise ratio increases by sqrt(k), but localization decreases by 1/sqrt(k). This invariance is consistent with the uncertainty principle. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00807">807</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a24f953cbb7eb314935cdd6bdf6031c21"></a><!-- doxytag: member="gevd_float_operators::Hessian" ref="a24f953cbb7eb314935cdd6bdf6031c21" args="(const gevd_bufferxy &amp;smooth, gevd_bufferxy *&amp;mag, gevd_bufferxy *&amp;dirx, gevd_bufferxy *&amp;diry, const bool xwrap=false, const bool ywrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>smooth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>dirx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>diry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xwrap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ywrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the Hessian of the intensity surface. </p>
<p>O(m*n). The Hessian is directional, and described by the largest absolute eigenvalue, and its corresponding eigenvector. The intensity surface is assumed smoothed by a Gaussian filter, or convolved with a low-pass filter. Return at each pixel, the largest absolute value of the two eigenvalues, the corresponding eigenvector, and the multiplication factor to normalize the magnitude. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00956">956</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa22020b5e6a82580712de8292d291a87"></a><!-- doxytag: member="gevd_float_operators::InterpolateParabola" ref="aa22020b5e6a82580712de8292d291a87" args="(float y1, float y0, float y2, float &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::InterpolateParabola </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fit a parabola through 3 points with strict local max/min. </p>
<p>Return the offset location, and value of the maximum/minimum. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01445">1445</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a22db8b4e97c8a5533b03e9def2458894"></a><!-- doxytag: member="gevd_float_operators::IsSimilarBuffer" ref="a22db8b4e97c8a5533b03e9def2458894" args="(const gevd_bufferxy &amp;buf1, const gevd_bufferxy &amp;buf2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::IsSimilarBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two buffers are similar if they have the same dimensions, and precision (bits_per_pixel). </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03559">3559</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a868c1ed255c394cac224be4679d1ec2e"></a><!-- doxytag: member="gevd_float_operators::Laplacian" ref="a868c1ed255c394cac224be4679d1ec2e" args="(const gevd_bufferxy &amp;smooth, gevd_bufferxy *&amp;mag, gevd_bufferxy *&amp;dirx, gevd_bufferxy *&amp;diry, const bool xwrap=false, const bool ywrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>smooth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>dirx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>diry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xwrap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ywrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the Laplacian of the intensity surface. </p>
<p>O(m*n). The Laplacian is rotational symmetric, and is the sum of the 2 eigenvalues/curvatures, with positive/negative sign for concave/convex. The intensity surface is assumed smoothed by a Gaussian filter, or convolved with a low-pass filter. Return at each pixel, the absolute value of the laplacian, the eigenvector corresponding to the largest absolute eigenvalue/curvature, and the multiplication factor to normalize the magnitude. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01069">1069</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a21ca1708bc348602893345e776008060"></a><!-- doxytag: member="gevd_float_operators::LowHighPyramid" ref="a21ca1708bc348602893345e776008060" args="(float *highPass, float *lowPass, int n, int nlevels, const float *lo_filter, const float *hi_filter, int ncof, float *wksp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::LowHighPyramid </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>highPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>lowPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>lo_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>hi_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>wksp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find pyramid of low/high pass components, using wavelet transform. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02649">2649</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1cb5fa84664e87cb33e07b534c6c5102"></a><!-- doxytag: member="gevd_float_operators::Maximum" ref="a1cb5fa84664e87cb33e07b534c6c5102" args="(const gevd_bufferxy &amp;buf, int sizeX=0, int sizeY=0, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Maximum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximum value in float buffer. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03673">3673</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad543b11ef464377f7755b482f369421a"></a><!-- doxytag: member="gevd_float_operators::Maximum" ref="ad543b11ef464377f7755b482f369421a" args="(const float *data, const int length, int &amp;index, float &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::Maximum </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detect maximum in 1d-array of values. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03964">3964</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a46c649646175bb697877d5e3495ca9a6"></a><!-- doxytag: member="gevd_float_operators::Minimum" ref="a46c649646175bb697877d5e3495ca9a6" args="(const gevd_bufferxy &amp;buf, int sizeX=0, int sizeY=0, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Minimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the minimum value in float buffer. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03693">3693</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="afb8d319f14beab9baac90478710997bd"></a><!-- doxytag: member="gevd_float_operators::Negate" ref="afb8d319f14beab9baac90478710997bd" args="(gevd_bufferxy &amp;buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::Negate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate all values. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03847">3847</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a70e601f9fb928c16596b86d482578a02"></a><!-- doxytag: member="gevd_float_operators::NonMaximumSuppression" ref="a70e601f9fb928c16596b86d482578a02" args="(const gevd_bufferxy &amp;magnitude, const gevd_bufferxy &amp;directionx, const gevd_bufferxy &amp;directiony, const float threshold, gevd_bufferxy *&amp;contour, gevd_bufferxy *&amp;direction, gevd_bufferxy *&amp;locationx, gevd_bufferxy *&amp;locationy, const bool xwrap=false, const bool ywrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::NonMaximumSuppression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>directionx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>directiony</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>locationx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>locationy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>xwrap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ywrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detect contour pixels as strict local maxima, and interpolate the strength/location with a parabola through 3 points. </p>
<p>The location[xy]/direction[xy] buffers no longer share the same space to avoid bogus values when the contour/junction pixels move around by +/- 1 pixel. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01294">1294</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a38673fb3f050d8bb05502d2cda1b2a66"></a><!-- doxytag: member="gevd_float_operators::NonMaximumSuppression" ref="a38673fb3f050d8bb05502d2cda1b2a66" args="(const float *from, const int len, const float threshold, int *&amp;index, float *&amp;mag, float *&amp;locs, const bool wrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::NonMaximumSuppression </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>mag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>locs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detect local maxima in linear/circular array. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01393">1393</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a37a38f714c140159dbcbc0faeede03d3"></a><!-- doxytag: member="gevd_float_operators::Normalize" ref="a37a38f714c140159dbcbc0faeede03d3" args="(gevd_bufferxy &amp;buf, const float lo, const float hi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::Normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes a float buffer so that the pixel values range from <em>lo</em> to <em>hi</em>, inclusive. </p>
<p>If the buffer has constant value, the value is mapped to <em>lo</em>. O(n*m). </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03759">3759</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a635853488300d1f14e3b87c592317541"></a><!-- doxytag: member="gevd_float_operators::Orientation" ref="a635853488300d1f14e3b87c592317541" args="(const gevd_bufferxy &amp;smooth, gevd_bufferxy *&amp;theta, gevd_bufferxy *&amp;coherence, const int frame=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>smooth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>coherence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>frame</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the local orientation at each pixel in the image, and returns 2 images: twice the angle, and coherence measure (0,1). </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01179">1179</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa162f3f9ebd2ce67ca1ce6fea3957831"></a><!-- doxytag: member="gevd_float_operators::PadToPowerOf2" ref="aa162f3f9ebd2ce67ca1ce6fea3957831" args="(gevd_bufferxy &amp;buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::PadToPowerOf2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pad the buffer by repeating values at the border, so that the new buffer has dimensions being powers of 2. </p>
<p>The original buffer is centered in the new buffer. Returns the buffer unchanged if it already has dimensions being powers of 2. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03996">3996</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aaddd77814bd644b4508d8cdcfb4db786"></a><!-- doxytag: member="gevd_float_operators::ProjectOntoX" ref="aaddd77814bd644b4508d8cdcfb4db786" args="(const gevd_bufferxy &amp;buf, float *&amp;proj, int sizeX=0, int sizeY=0, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::ProjectOntoX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Project the image data in ROI onto the x- and y- axes. </p>
<p>O(n*m). The 1d-array is returned with projections being the sum normalized by the number of elements projected. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03252">3252</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="adf2fd45c45fb8cac4aa52c3846fa0345"></a><!-- doxytag: member="gevd_float_operators::ProjectOntoY" ref="adf2fd45c45fb8cac4aa52c3846fa0345" args="(const gevd_bufferxy &amp;buf, float *&amp;proj, int sizeX=0, int sizeY=0, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::ProjectOntoY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03271">3271</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aecb70f8c2902561fb3378f64e0d911ab"></a><!-- doxytag: member="gevd_float_operators::ProjectWaveOntoX" ref="aecb70f8c2902561fb3378f64e0d911ab" args="(const gevd_bufferxy &amp;buf, float *&amp;proj, const int nlevels=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::ProjectWaveOntoX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nlevels</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Project wavelet components onto the axes. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03214">3214</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a9b42e49428db59cff14981af550a3570"></a><!-- doxytag: member="gevd_float_operators::ProjectWaveOntoY" ref="a9b42e49428db59cff14981af550a3570" args="(const gevd_bufferxy &amp;buf, float *&amp;proj, const int nlevels=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::ProjectWaveOntoY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nlevels</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03230">3230</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a0c8b06c0c80cae6d66b6d721c73dbed0"></a><!-- doxytag: member="gevd_float_operators::Pyramid" ref="a0c8b06c0c80cae6d66b6d721c73dbed0" args="(const float *from, const int length, float *&amp;to, int &amp;nlevels, int trim=0, const float burt_ka=0.359375f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::Pyramid </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>pyramid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trim</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>burt_ka</em> = <code>0.359375f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the pyramid by shrinking data sequence by 2, nlevels-1 times, and return final shrunk length, and reset number of levels in pyramid. </p>
<p>O(n) time. Coarse to fine is stored from left to right. The left and right trim borders are set to 0. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02239">2239</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a4b27ef2af7b6b16c747b59a46aa97d04"></a><!-- doxytag: member="gevd_float_operators::Read1dKernel" ref="a4b27ef2af7b6b16c747b59a46aa97d04" args="(const char *filename, float *&amp;kernel, int &amp;radius, bool &amp;evenp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::Read1dKernel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>evenp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read 1d odd/even kernel from a <a href="file:">file:</a> width k_i .... </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00622">622</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="add5ae082710726af0380e5da09013fd7"></a><!-- doxytag: member="gevd_float_operators::Read2dKernel" ref="add5ae082710726af0380e5da09013fd7" args="(const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::Read2dKernel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read 2D kernel from a <a href="file:">file:</a> width height k_x_y .... </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00205">205</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a5b3d459069aa4f968a505afd5e6202a6"></a><!-- doxytag: member="gevd_float_operators::RunningSum" ref="a5b3d459069aa4f968a505afd5e6202a6" args="(float *from, float *&amp;to, const int len, const int radius, const bool wrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::RunningSum </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kradius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For large smoothing sigma, use running sum to avoid floating multiplications. </p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00577">577</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="affae827367c0da040c8983b5c3ef6015"></a><!-- doxytag: member="gevd_float_operators::Scale" ref="affae827367c0da040c8983b5c3ef6015" args="(gevd_bufferxy &amp;buf, float factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::Scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale all values by factor. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03822">3822</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aafd62806d4cb397f07852770d168b258"></a><!-- doxytag: member="gevd_float_operators::SetupPipeline" ref="aafd62806d4cb397f07852770d168b258" args="(const float *data, const int len, const int kradius, const bool wrap, float *&amp;cache, float *&amp;pipeline)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::SetupPipeline </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kradius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>wrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup the cache for reflection/wrapping at the borders, and the center pipeline. </p>
<p>Only cache should be deleted after you're done, not the pipeline, since pipeline shares the same space. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00731">731</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e71cce4ae9f19ea21b73f3248be62a"></a><!-- doxytag: member="gevd_float_operators::ShiftToPositive" ref="ab9e71cce4ae9f19ea21b73f3248be62a" args="(gevd_bufferxy &amp;buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::ShiftToPositive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift to positive values, by adding 30.0000, and truncate all values to 0-60.000. </p>
<p>O(n*m). </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03784">3784</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ab331874ed8ed644cd04a09675b2155d3"></a><!-- doxytag: member="gevd_float_operators::ShrinkBy2" ref="ab331874ed8ed644cd04a09675b2155d3" args="(const gevd_bufferxy &amp;cfrom, gevd_bufferxy *&amp;to, const float burt_ka=0.359375f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::ShrinkBy2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>burt_ka</em> = <code>0.359375f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shrinks the <em>from</em> image by 2 and stores into <em>to</em> image, using Burt-Adelson reduction algorithm. </p>
<p>Convolution with a 5-point kernel [(0.5-ka)/2, 0.25, ka, 0.25, (0.5-ka)/2] ka = 0.6 maximum decorrelation, wavelet for image compression. ka = 0.5 linear interpolation, ka = 0.4 Gaussian filter ka = 0.359375 min aliasing, wider than Gaussian The image indexes are mapped with: to.ij = from.ij / 2 The image sizes are related by: to.size = (from.size+1)/2.</p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01840">1840</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa28f010f44e1b4b01efc54ee35585642"></a><!-- doxytag: member="gevd_float_operators::ShrinkBy2" ref="aa28f010f44e1b4b01efc54ee35585642" args="(const float *from, const int length, float *&amp;to, const float burt_ka=0.359375f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::ShrinkBy2 </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>burt_ka</em> = <code>0.359375f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02269">2269</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a676f18190a31b96019d581aa4f044830"></a><!-- doxytag: member="gevd_float_operators::ShrinkBy2_D" ref="a676f18190a31b96019d581aa4f044830" args="(const gevd_bufferxy &amp;from, gevd_bufferxy *&amp;to, float no_value, float burt_ka=0.359375f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::ShrinkBy2_D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>no_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>burt_ka</em> = <code>0.359375f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shrinks the <em>from</em> image by 2 and stores into <em>to</em> image. </p>
<p>Same as ShrinkBy2 except that it properly handles pixels that have unusable value ("dropouts" --- hence the appended "_D" in the name). These are pixel values "no_value". One problem with this function is that one pixel wide structures may or may not be retained in the shrunken image, depending on the position of the structure. This should not be a problem for the initial application.</p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01961">1961</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a106eeba665925277d71961746259228f"></a><!-- doxytag: member="gevd_float_operators::ShrinkBy2AlongX" ref="a106eeba665925277d71961746259228f" args="(const gevd_bufferxy &amp;cfrom, const int y, float *yline, const int len, const float ka, const float kb, const float kc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::ShrinkBy2AlongX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>yline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>ka</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>kc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shrinks the yline by 2 along the x-axis. </p>
<p>We compute every 2 pixels, the convolution of the 5 pixels along x, with the 5-point kernel [kc, kb, ka, kb, kc]. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01903">1903</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a9e0e1a97b9f7c4e9814406191054aef3"></a><!-- doxytag: member="gevd_float_operators::ShrinkBy2AlongX_D" ref="a9e0e1a97b9f7c4e9814406191054aef3" args="(const gevd_bufferxy &amp;from, int from_sizeX, int sizeX, int y, float kernel[], float no_value, float *yline, float *wline)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::ShrinkBy2AlongX_D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kernel</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>no_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>yline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>wline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a smoothed and subsampled array of x values in the given row. </p>
<p>This will return the weighted (but unnormalized) values (in yline) and the weights (wline). </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02099">2099</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a824bc51a5db748afd30cdef306a5a122"></a><!-- doxytag: member="gevd_float_operators::SimilarBuffer" ref="a824bc51a5db748afd30cdef306a5a122" args="(const gevd_bufferxy &amp;buffer, int bits_per_pixel=0, int sizeX=0, int sizeY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::SimilarBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits_per_pixel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new buffer similar to buf, unless dimension and precision are given. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03542">3542</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="af8d139c37b132338ab6507987c5f4024"></a><!-- doxytag: member="gevd_float_operators::Slope" ref="af8d139c37b132338ab6507987c5f4024" args="(float *from, float *&amp;to, const int len, const bool wrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Slope </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute slope or first-difference, in linear/circular array. </p>
<p>Special care is taken when <em>to</em> and <em>from</em> are identical - Peter Vanroose. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00883">883</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a70d3b60ced56ea57d9aa8ef6334ce491"></a><!-- doxytag: member="gevd_float_operators::Sum" ref="a70d3b60ced56ea57d9aa8ef6334ce491" args="(const gevd_bufferxy &amp;buf, int sizeX=0, int sizeY=0, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::Sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the sum of all values in float buffer. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03713">3713</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="af5f14d8c6f2870d3d57103a900206c06"></a><!-- doxytag: member="gevd_float_operators::SupportAngle" ref="af5f14d8c6f2870d3d57103a900206c06" args="(const gevd_bufferxy &amp;dirx, const gevd_bufferxy &amp;diry, const gevd_bufferxy &amp;magnitude, gevd_bufferxy *&amp;angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::SupportAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>dirx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>diry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find angle of the line of support, in degrees. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01477">1477</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a2076a04a9ba4d23f547bd9f7e396655b"></a><!-- doxytag: member="gevd_float_operators::SurfaceCurvature" ref="a2076a04a9ba4d23f547bd9f7e396655b" args="(const gevd_bufferxy &amp;normal, gevd_bufferxy *&amp;curvature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::SurfaceCurvature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>curvature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find local gaussian curvature at all pixels from the local surface normals, previously computed from the range z(x,y) image. </p>
<p>The gaussian curvature is estimated as the root mean square of the two curvatures along the x- and y- axes. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01527">1527</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="af6483b7c665252ff627859bc1fbd403e"></a><!-- doxytag: member="gevd_float_operators::SurfaceCurvatureD" ref="af6483b7c665252ff627859bc1fbd403e" args="(const gevd_bufferxy &amp;normal, const gevd_bufferxy &amp;surface, gevd_bufferxy *&amp;curvature, float dflt, float pixel_distance=1.0f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::SurfaceCurvatureD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dflt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pixel_distance</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the maximum curvature at all pixels from the local surface normals, previously computed from the range z(x,y) image. </p>
<p>This is similar to SurfaceCurvature above with two exceptions. First, it explicitly recognizes image locations where no normal has been calculated. Second, it normalizes the curvature by the pixel_distance, converting the curvature to a real-world quantity rather than a pixel quantity. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01758">1758</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae89d06e33fa86aa6b90a4c5c86072de9"></a><!-- doxytag: member="gevd_float_operators::SurfaceNormal" ref="ae89d06e33fa86aa6b90a4c5c86072de9" args="(const gevd_bufferxy &amp;range, gevd_bufferxy *&amp;normal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::SurfaceNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find local surface normal at all pixels in the range z(x,y) image. </p>
<p>The normal is estimated from the cross-product of the two tangent vectors along the x- and y- axes. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01500">1500</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a60fca4d67f903c1ec5c9ce04d70080ef"></a><!-- doxytag: member="gevd_float_operators::SurfaceNormalD" ref="a60fca4d67f903c1ec5c9ce04d70080ef" args="(const gevd_bufferxy &amp;range, gevd_bufferxy *&amp;normal, float no_value, float pixel_distance=1.0f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::SurfaceNormalD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>no_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pixel_distance</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="classgevd__float__operators.html#ae89d06e33fa86aa6b90a4c5c86072de9" title="Find local surface normal at all pixels in the range z(x,y) image.">gevd_float_operators::SurfaceNormal</a> with two exceptions. </p>
<p>First, it explicitly recognizes and avoids pixels that have no range value. These are often called "dropouts", hence the "D" at the end of the function name. Second, it uses an optional "pixel_distance" value to put the inter-pixel distances in the same coordinate system as the range values. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l01616">1616</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a162fce826738f6d4378dbb900a387d47"></a><!-- doxytag: member="gevd_float_operators::TestWavelets" ref="a162fce826738f6d4378dbb900a387d47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::TestWavelets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02962">2962</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a066c8b4d3a757fb2959ed626c35037a8"></a><!-- doxytag: member="gevd_float_operators::Threshold" ref="a066c8b4d3a757fb2959ed626c35037a8" args="(gevd_bufferxy &amp;buf, float noise, int sizeX=0, int sizeY=0, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::Threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncate all values in ROI to 0, if below noise. </p>
<p>Return the number of pixels changed. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03732">3732</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ac71a14b3007df5035badb3a3da00beae"></a><!-- doxytag: member="gevd_float_operators::TransposeExtract" ref="ac71a14b3007df5035badb3a3da00beae" args="(const gevd_bufferxy &amp;buf, int sizeX, int sizeY, int origX, int origY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::TransposeExtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l04088">4088</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a2545c33f194fc14b46e300feebaa8c24"></a><!-- doxytag: member="gevd_float_operators::TransposeUpdate" ref="a2545c33f194fc14b46e300feebaa8c24" args="(gevd_bufferxy &amp;buf, const gevd_bufferxy &amp;sub, int origX, int origY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::TransposeUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l04099">4099</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a051c8e2b43da2bc756a9b27e313231e0"></a><!-- doxytag: member="gevd_float_operators::TruncateHighFrequencies" ref="a051c8e2b43da2bc756a9b27e313231e0" args="(gevd_bufferxy &amp;wave, const int nlevels, const float threshold=0.1f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::TruncateHighFrequencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>wave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.1f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncate to 0, all wavelet components with high frequency along either x- or y- axes only, not both. </p>
<p>The relative magnitude of the components must be smaller than the given threshold. This will simulate reduced accuracy in presence of transmission errors. Return the number of coefficients deleted. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03108">3108</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a312c45d027b65a44ef077130afcb05d6"></a><!-- doxytag: member="gevd_float_operators::TruncateLowestFrequency" ref="a312c45d027b65a44ef077130afcb05d6" args="(gevd_bufferxy &amp;wave, const int nlevels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gevd_float_operators::TruncateLowestFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>wave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nlevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncate to average value, the lowest frequency component. </p>
<p>This will simulate throwing away the lowest frequencies in image. Return the number of coefficients deleted. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03139">3139</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ace6867c107dc7208a3a43a574dc7af57"></a><!-- doxytag: member="gevd_float_operators::TruncateToCeiling" ref="ace6867c107dc7208a3a43a574dc7af57" args="(gevd_bufferxy &amp;buf, float ceil)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::TruncateToCeiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ceil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03857">3857</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae52801fb1325d8c99fb65ca778a7a1c2"></a><!-- doxytag: member="gevd_float_operators::TruncateToPositive" ref="ae52801fb1325d8c99fb65ca778a7a1c2" args="(gevd_bufferxy &amp;buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gevd_float_operators::TruncateToPositive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zeros out all negative values. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03803">3803</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae92d0f5801ed4afeaa0725a54d764356"></a><!-- doxytag: member="gevd_float_operators::UnpadFromPowerOf2" ref="ae92d0f5801ed4afeaa0725a54d764356" args="(gevd_bufferxy &amp;padded, int sizeX, int sizeY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::UnpadFromPowerOf2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>padded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse of the above operation. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l04074">4074</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a59ce32ff7bc0c2452e520e0559320784"></a><!-- doxytag: member="gevd_float_operators::Update" ref="a59ce32ff7bc0c2452e520e0559320784" args="(gevd_bufferxy &amp;old_buf, const gevd_bufferxy &amp;new_buf, int origX=0, int origY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a float sub-buffer of <em>buf</em>, from top-left corner (origX, origY), with values in <em>sub</em>. </p>
<p>Faster copying can be done with read/write chunks of memory. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03592">3592</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a3e7a0d96d6241af66b2cb312c253591f"></a><!-- doxytag: member="gevd_float_operators::WaveletTransform" ref="a3e7a0d96d6241af66b2cb312c253591f" args="(float *array, const int n, const bool forwardp, int nlevels, const int waveletno=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::WaveletTransform </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forwardp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>waveletno</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the forward/inverse wavelet transform of a 1d array of data. </p>
<p>Convolution with low (resp. high) filter is stored on the side of low (resp. high) indices. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02600">2600</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a6852b582f1079b5da0dd8206c6fb9d4c"></a><!-- doxytag: member="gevd_float_operators::WaveletTransformByBlock" ref="a6852b582f1079b5da0dd8206c6fb9d4c" args="(float *array, const int *dims, const int ndim, const bool forwardp, int nlevels, const int waveletno=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::WaveletTransformByBlock </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forwardp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>waveletno</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>n-dimensional wavelet transform of an n-dimensional array. </p>
<p>Convolution with low (resp. high) filter is stored on the side of low (resp. high) indices. Assumes data are stored consecutively with right-most index varying fastest, consistent with convention in C <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m(i,j)</a> = m[i][j]. This version decomposes only the n-dimensional sub-block of low frequency convolutions. The wavelet are self-similar in n-dimensional space, rather than elongated. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02863">2863</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ab0dca678e4dcdb393a6a971e8a33c212"></a><!-- doxytag: member="gevd_float_operators::WaveletTransformByBlock" ref="ab0dca678e4dcdb393a6a971e8a33c212" args="(const gevd_bufferxy &amp;cfrom, gevd_bufferxy *&amp;to, const bool forwardp, int nlevels, const int waveletno=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::WaveletTransformByBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forwardp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>waveletno</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the Fast Wavelet Transform of the image. </p>
<p>Higher number wavelets are less compact, but give more accurate decomposition of the image into linear combinations of mother wavelets. Image compression uses mother wavelets around 12, while image segmentation uses compact wavelets around 2 or 4. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03056">3056</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1a9679591c857ea4047f23437c0df344"></a><!-- doxytag: member="gevd_float_operators::WaveletTransformByIndex" ref="a1a9679591c857ea4047f23437c0df344" args="(float *array, const int *dims, const int ndim, const bool forwardp, int nlevels, const int waveletno=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::WaveletTransformByIndex </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forwardp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>waveletno</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>n-dimensional wavelet transform of an n-dimensional array. </p>
<p>Convolution with low (resp. high) filter is stored on the side of low (resp. high) indices. Assumes data are stored consecutively with right-most index varying fastest, consistent with convention in C <a class="elRef" doxygen="core_vnl.tag:../../../../core/vnl/html" href="../../../../core/vnl/html/vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m(i,j)</a> = m[i][j]. This version does a 1d-FWT recursively on each dimension, rather than an nd-FWT on each recursive nd sub-block that are convolved with lo-filters. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02691">2691</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a93f8a9498d7a0717efbc804226b0cdd3"></a><!-- doxytag: member="gevd_float_operators::WaveletTransformByIndex" ref="a93f8a9498d7a0717efbc804226b0cdd3" args="(const gevd_bufferxy &amp;cfrom, gevd_bufferxy *&amp;to, const bool forwardp, int nlevels, const int waveletno=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gevd_float_operators::WaveletTransformByIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> *&amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forwardp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>waveletno</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the Fast Wavelet Transform of the 2d array. </p>
<p>Higher number wavelets are less compact, but give more accurate decomposition of the image into linear combinations of mother wavelets. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l03029">3029</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1e66970ff8d396fc76e78cb96820bbb2"></a><!-- doxytag: member="gevd_float_operators::WaveletTransformStep" ref="a1e66970ff8d396fc76e78cb96820bbb2" args="(float *array, const int n, const bool forwardp, const float *lo_filter, const float *hi_filter, const int ncof, float *wksp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::WaveletTransformStep </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forwardp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>lo_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>hi_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ncof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>wksp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolution with wavelets (<em>lo_filter</em>, <em>hi_filter</em>) and gather results into consecutive blocks, with convolution of <em>lo_filter</em> (resp. </p>
<p><em>hi_filter</em>) on the sides of low (resp. high) indices. Wrap around edges of the array is done with modulo(n) replaced by bit masking with <em>n-1</em>, when <em>n</em> is a power of 2. Assumes n &gt;= 4. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02552">2552</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a5e93387ce99e8b1701d853f605047ee1"></a><!-- doxytag: member="gevd_float_operators::WaveletTransformStep" ref="a5e93387ce99e8b1701d853f605047ee1" args="(float *array, const int *dims, const int ndim, const bool forwardp, const float *lo_filter, const float *hi_filter, const int ncof, float *buffer, float *wksp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gevd_float_operators::WaveletTransformStep </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forwardp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>lo_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>hi_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ncof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>wksp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l02776">2776</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a894545aa9c77e332bd3a1914fd0c0b7e"></a><!-- doxytag: member="gevd_float_operators::WrapAlongX" ref="a894545aa9c77e332bd3a1914fd0c0b7e" args="(const gevd_bufferxy &amp;img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::WrapAlongX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a buffer that wraps rows/columns. </p>

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00755">755</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a43649f2c4bbbda765713cd679acbd7f3"></a><!-- doxytag: member="gevd_float_operators::WrapAlongY" ref="a43649f2c4bbbda765713cd679acbd7f3" args="(const gevd_bufferxy &amp;img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> * gevd_float_operators::WrapAlongY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgevd__bufferxy.html">gevd_bufferxy</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="gevd__float__operators_8cxx_source.html#l00769">769</a> of file <a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>contrib/gel/gevd/<a class="el" href="gevd__float__operators_8h_source.html">gevd_float_operators.h</a></li>
<li>contrib/gel/gevd/<a class="el" href="gevd__float__operators_8cxx_source.html">gevd_float_operators.cxx</a></li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:37:55 for contrib/gel/gevd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
