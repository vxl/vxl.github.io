<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>contrib/gel/vtol/vtol_cycle_processor.cxx Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">contrib/gel/vtol/vtol_cycle_processor.cxx</div>  </div>
</div>
<div class="contents">
<a href="vtol__cycle__processor_8cxx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This is gel/vtol/vtol_cycle_processor.cxx</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include &quot;<a class="code" href="vtol__cycle__processor_8h.html" title="A class for tracing boundaries and forming nested one_cycles.">vtol_cycle_processor.h</a>&quot;</span>
<a name="l00003"></a>00003 <span class="comment">//:</span>
<a name="l00004"></a>00004 <span class="comment">// \file</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;vcl_vector.h&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;vcl_algorithm.h&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;vcl_iostream.h&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;vcl_cmath.h&gt;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__box__2d_8h.html">vsol/vsol_box_2d.h</a>&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__box__2d__sptr_8h.html">vsol/vsol_box_2d_sptr.h</a>&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_gel_vdgl.tag:../../../../contrib/gel/vdgl/html" href="../../../../contrib/gel/vdgl/html/vdgl__digital__curve_8h.html">vdgl/vdgl_digital_curve.h</a>&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_gel_vdgl.tag:../../../../contrib/gel/vdgl/html" href="../../../../contrib/gel/vdgl/html/vdgl__interpolator_8h.html">vdgl/vdgl_interpolator.h</a>&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;<a class="codeRef" doxygen="contrib_gel_vdgl.tag:../../../../contrib/gel/vdgl/html" href="../../../../contrib/gel/vdgl/html/vdgl__edgel__chain_8h.html">vdgl/vdgl_edgel_chain.h</a>&gt;</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;<a class="code" href="vtol__vertex_8h.html" title="Topological container for a spatial point, without geometry info.">vtol/vtol_vertex.h</a>&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;<a class="code" href="vtol__vertex__2d_8h.html" title="Topological container for a spatial point, with 2d geometry (location)">vtol/vtol_vertex_2d.h</a>&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;<a class="code" href="vtol__one__chain_8h.html" title="Represents a connected chain of edges.">vtol/vtol_one_chain.h</a>&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;<a class="code" href="vtol__edge_8h.html" title="Represents the basic 1D topological entity.">vtol/vtol_edge.h</a>&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;<a class="code" href="vtol__edge__2d_8h.html" title="Represents the basic 1D topological entity with 2d geometry (curve)">vtol/vtol_edge_2d.h</a>&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="vtol__edge__2d__sptr_8h.html" title="Smart pointer on a vtol_edge_2d.">vtol/vtol_edge_2d_sptr.h</a>&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">//Constructors</span>
<a name="l00025"></a><a class="code" href="classvtol__cycle__processor.html#a9043b26711a4bf3178b2ad21dd20ca74">00025</a> <a class="code" href="classvtol__cycle__processor.html#a9043b26711a4bf3178b2ad21dd20ca74">vtol_cycle_processor::vtol_cycle_processor</a>(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; <a class="code" href="classvtol__topology__object.html#a380b2f5f1d74935d0adec465c1f69fd7" title="Get list of edges.">edges</a>,
<a name="l00026"></a>00026                                            <span class="keywordtype">bool</span> debug1, <span class="keywordtype">bool</span> debug2)
<a name="l00027"></a>00027 {
<a name="l00028"></a>00028   <a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a> = debug1;
<a name="l00029"></a>00029   <a class="code" href="classvtol__cycle__processor.html#a1cd8b52edc826310db88e4151ac134ea">debug2_</a> = debug2;
<a name="l00030"></a>00030   <a class="code" href="classvtol__cycle__processor.html#a3052cb5b5d48611f3cb5d8c59c47fcae">tolerance_</a> = 0;
<a name="l00031"></a>00031   <a class="code" href="classvtol__cycle__processor.html#a0de1c26fe5f94cd820fc54778d5d5db7" title="The initial setup of the cycle process.">init</a>(edges);
<a name="l00032"></a>00032 }
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">//: a more convenient interface</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 <span class="keyword">static</span> <span class="keywordtype">void</span> edge_2d_erase(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; <a class="code" href="classvtol__topology__object.html#a380b2f5f1d74935d0adec465c1f69fd7" title="Get list of edges.">edges</a>,
<a name="l00037"></a>00037                           <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00038"></a>00038 {
<a name="l00039"></a>00039   vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit =
<a name="l00040"></a>00040     vcl_find(edges.begin(), edges.end(), e);
<a name="l00041"></a>00041   <span class="keywordflow">if</span> (eit == edges.end())
<a name="l00042"></a>00042     <span class="keywordflow">return</span>;
<a name="l00043"></a>00043   edges.erase(eit);
<a name="l00044"></a>00044   <span class="keywordflow">return</span>;
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">//: print a vector of vertices</span>
<a name="l00048"></a>00048 <span class="comment">//</span>
<a name="l00049"></a>00049 <span class="keyword">static</span> <span class="keywordtype">void</span> print_vertices(vcl_vector&lt;vtol_vertex_sptr&gt;&amp; verts)
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_vertex_sptr&gt;::iterator vit = verts.begin();
<a name="l00052"></a>00052        vit != verts.end(); ++vit)
<a name="l00053"></a>00053     vcl_cout &lt;&lt; *vit &lt;&lt; <span class="charliteral">&#39;(&#39;</span>
<a name="l00054"></a>00054              &lt;&lt; (*vit)-&gt;cast_to_vertex_2d()-&gt;x()&lt;&lt; <span class="charliteral">&#39; &#39;</span>
<a name="l00055"></a>00055              &lt;&lt; (*vit)-&gt;cast_to_vertex_2d()-&gt;y()&lt;&lt; <span class="stringliteral">&quot;)\n\n&quot;</span>;
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="comment">//: print a vector of edges_2d</span>
<a name="l00059"></a>00059 <span class="comment">//</span>
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keywordtype">void</span> print_edges(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; edges)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = edges.begin();
<a name="l00063"></a>00063        eit != edges.end(); ++eit)
<a name="l00064"></a>00064     vcl_cout &lt;&lt; *eit &lt;&lt; <span class="charliteral">&#39;(&#39;</span>
<a name="l00065"></a>00065              &lt;&lt; (*eit)-&gt;v1()-&gt;cast_to_vertex_2d()-&gt;x()&lt;&lt; <span class="charliteral">&#39; &#39;</span>
<a name="l00066"></a>00066              &lt;&lt; (*eit)-&gt;v1()-&gt;cast_to_vertex_2d()-&gt;y()&lt;&lt; <span class="stringliteral">&quot; |&quot;</span>
<a name="l00067"></a>00067              &lt;&lt; (*eit)-&gt;v2()-&gt;cast_to_vertex_2d()-&gt;x()&lt;&lt; <span class="charliteral">&#39; &#39;</span>
<a name="l00068"></a>00068              &lt;&lt; (*eit)-&gt;v2()-&gt;cast_to_vertex_2d()-&gt;y()&lt;&lt; <span class="stringliteral">&quot;)\n\n&quot;</span>;
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">//: print a vector of edges</span>
<a name="l00072"></a>00072 <span class="comment">//</span>
<a name="l00073"></a>00073 <span class="keyword">static</span> <span class="keywordtype">void</span> print_edges(vcl_vector&lt;vtol_edge_sptr&gt;&amp; edges)
<a name="l00074"></a>00074 {
<a name="l00075"></a>00075   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_sptr&gt;::iterator eit = edges.begin();
<a name="l00076"></a>00076        eit != edges.end(); ++eit)
<a name="l00077"></a>00077     vcl_cout &lt;&lt; *eit &lt;&lt; <span class="charliteral">&#39;(&#39;</span>
<a name="l00078"></a>00078              &lt;&lt; (*eit)-&gt;v1()-&gt;cast_to_vertex_2d()-&gt;x()&lt;&lt; <span class="charliteral">&#39; &#39;</span>
<a name="l00079"></a>00079              &lt;&lt; (*eit)-&gt;v1()-&gt;cast_to_vertex_2d()-&gt;y()&lt;&lt; <span class="stringliteral">&quot; |&quot;</span>
<a name="l00080"></a>00080              &lt;&lt; (*eit)-&gt;v2()-&gt;cast_to_vertex_2d()-&gt;x()&lt;&lt; <span class="charliteral">&#39; &#39;</span>
<a name="l00081"></a>00081              &lt;&lt; (*eit)-&gt;v2()-&gt;cast_to_vertex_2d()-&gt;y()&lt;&lt; <span class="stringliteral">&quot;)\n\n&quot;</span>;
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">//---------------------------------------------------------------</span>
<a name="l00085"></a>00085 <span class="comment">//</span>
<a name="l00086"></a>00086 <span class="keyword">static</span> <span class="keywordtype">void</span> pop_stacks(<a class="code" href="vtol__topology__object_8h.html#ad265137d5e3614dd7667d8cf5f57cbd9">vertex_list</a>&amp; verts,
<a name="l00087"></a>00087                        vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; edges,
<a name="l00088"></a>00088                        <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>&amp; v,
<a name="l00089"></a>00089                        vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; cycle_edges)
<a name="l00090"></a>00090 {
<a name="l00091"></a>00091   <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l00092"></a>00092   <span class="keywordflow">while</span> (verts.size()&amp;&amp;edges.size()&amp;&amp;!found)
<a name="l00093"></a>00093   {
<a name="l00094"></a>00094     found = verts.back()==v;
<a name="l00095"></a>00095     cycle_edges.push_back(edges.back());
<a name="l00096"></a>00096     verts.pop_back();
<a name="l00097"></a>00097     edges.pop_back();
<a name="l00098"></a>00098   }
<a name="l00099"></a>00099   <span class="keywordflow">if</span> (!edges.size()&amp;&amp;verts.size())
<a name="l00100"></a>00100     verts.clear();
<a name="l00101"></a>00101 }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="comment">//: Access to flags</span>
<a name="l00104"></a>00104 <span class="comment">//the user flags on SpatialObject are used to define the orientation</span>
<a name="l00105"></a>00105 <span class="comment">//of vtol_edge(s) during the boundary tracing process.  In effect, FLAG1 and</span>
<a name="l00106"></a>00106 <span class="comment">//FLAG2 define half edges. vtol_edges are used up when both half edges are used.</span>
<a name="l00107"></a>00107 <span class="keyword">static</span> <span class="keywordtype">bool</span> used(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109   <span class="keywordflow">return</span> e-&gt;get_user_flag(VSOL_FLAG1)&amp;&amp;e-&gt;get_user_flag(VSOL_FLAG2);
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="keyword">static</span> <span class="keywordtype">bool</span> unused(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114   <span class="keywordflow">return</span> !e-&gt;get_user_flag(VSOL_FLAG1)&amp;&amp;!e-&gt;get_user_flag(VSOL_FLAG2);
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keywordtype">bool</span> plus_used(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119   <span class="keywordflow">return</span> e-&gt;get_user_flag(VSOL_FLAG1) != 0;
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">bool</span> minus_used(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124   <span class="keywordflow">return</span> e-&gt;get_user_flag(VSOL_FLAG2) != 0;
<a name="l00125"></a>00125 }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="keyword">static</span> <span class="keywordtype">bool</span> half_used(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00128"></a>00128 {
<a name="l00129"></a>00129   <span class="keywordflow">return</span> e-&gt;get_user_flag(VSOL_FLAG1) ^ e-&gt;get_user_flag(VSOL_FLAG2);
<a name="l00130"></a>00130   <span class="comment">// exclusive OR; was: return (dir1&amp;&amp;!dir2)||(!dir1&amp;&amp;dir2);</span>
<a name="l00131"></a>00131 }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="comment">// Assignment of flags</span>
<a name="l00134"></a>00134 <span class="keyword">static</span> <span class="keywordtype">void</span> use_plus(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136   e-&gt;set_user_flag(VSOL_FLAG1);
<a name="l00137"></a>00137 }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">static</span> <span class="keywordtype">void</span> use_minus(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00140"></a>00140 {
<a name="l00141"></a>00141   e-&gt;set_user_flag(VSOL_FLAG2);
<a name="l00142"></a>00142 }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="comment">// One Chain flags</span>
<a name="l00145"></a>00145 <span class="comment">// predicates</span>
<a name="l00146"></a>00146 <span class="keyword">static</span> <span class="keywordtype">bool</span> ccw(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; ch)
<a name="l00147"></a>00147 {
<a name="l00148"></a>00148   <span class="keywordflow">return</span> ch &amp;&amp; ch-&gt;get_user_flag(VSOL_FLAG1) != 0;
<a name="l00149"></a>00149 }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keyword">static</span> <span class="keywordtype">bool</span> cw(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; ch)
<a name="l00152"></a>00152 {
<a name="l00153"></a>00153   <span class="keywordflow">return</span> ch &amp;&amp; ch-&gt;get_user_flag(VSOL_FLAG2) != 0;
<a name="l00154"></a>00154 }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="comment">// assignment</span>
<a name="l00157"></a>00157 <span class="keyword">static</span> <span class="keywordtype">void</span> set_ccw(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; ch)
<a name="l00158"></a>00158 {
<a name="l00159"></a>00159   ch-&gt;set_user_flag(VSOL_FLAG1);
<a name="l00160"></a>00160 }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keywordtype">void</span> set_cw(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; ch)
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164   ch-&gt;set_user_flag(VSOL_FLAG2);
<a name="l00165"></a>00165 }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment">// other house keeping functions and predicates</span>
<a name="l00168"></a>00168 <span class="comment">// vtol_edge functions</span>
<a name="l00169"></a>00169 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classvtol__chain.html#af482da14a5793d87e5b72db050b4eff6" title="Reset the chain.">clear</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171   e-&gt;unset_user_flag(VSOL_FLAG1);
<a name="l00172"></a>00172   e-&gt;unset_user_flag(VSOL_FLAG2);
<a name="l00173"></a>00173   e-&gt;unset_user_flag(VSOL_FLAG3);
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="preprocessor">#if 0 // only untouch(vtol_one_chain_sptr&amp;) is used</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> untouch(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00178"></a>00178 {
<a name="l00179"></a>00179   e-&gt;unset_user_flag(VSOL_FLAG3);
<a name="l00180"></a>00180 }
<a name="l00181"></a>00181 <span class="preprocessor">#endif</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>
<a name="l00183"></a>00183 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="codeRef" doxygen="core_vul.tag:../../../../core/vul/html" href="../../../../core/vul/html/classvul__timestamp.html#a35cb818365be3cd024a9bbfeb83355d8">touch</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185   e-&gt;set_user_flag(VSOL_FLAG3);
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">static</span> <span class="keywordtype">bool</span> touched(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190   <span class="keywordflow">return</span> e-&gt;get_user_flag(VSOL_FLAG3) != 0;
<a name="l00191"></a>00191 }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keyword">static</span> <span class="keywordtype">bool</span> self_loop(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00194"></a>00194 {
<a name="l00195"></a>00195   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = e-&gt;v1();
<a name="l00196"></a>00196   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v2 = e-&gt;v2();
<a name="l00197"></a>00197   <span class="keywordtype">bool</span> loop = v1 == v2;
<a name="l00198"></a>00198   <span class="keywordflow">return</span> loop;
<a name="l00199"></a>00199 }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="keyword">static</span> <span class="keywordtype">bool</span> bridge_traverse(<span class="keywordtype">double</span> angle)
<a name="l00202"></a>00202 {
<a name="l00203"></a>00203   <span class="keywordtype">double</span> tol = 1e-3;
<a name="l00204"></a>00204   <span class="keywordtype">double</span> delta = vcl_fabs(vcl_fabs(angle)-180);
<a name="l00205"></a>00205   <span class="keywordflow">return</span> delta&lt;tol;
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="comment">//vtol_one_chain functions</span>
<a name="l00209"></a>00209 <span class="keyword">static</span> <span class="keywordtype">void</span> untouch(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; ch)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211   ch-&gt;unset_user_flag(VSOL_FLAG3);
<a name="l00212"></a>00212 }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="preprocessor">#if 0 // only clear(vtol_edge_2d_sptr&amp; ) is used</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classvtol__chain.html#af482da14a5793d87e5b72db050b4eff6" title="Reset the chain.">clear</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; ch)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217   ch-&gt;unset_user_flag(VSOL_FLAG1);
<a name="l00218"></a>00218   ch-&gt;unset_user_flag(VSOL_FLAG2);
<a name="l00219"></a>00219   ch-&gt;unset_user_flag(VSOL_FLAG3);
<a name="l00220"></a>00220 }
<a name="l00221"></a>00221 <span class="preprocessor">#endif</span>
<a name="l00222"></a>00222 <span class="preprocessor"></span>
<a name="l00223"></a>00223 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="codeRef" doxygen="core_vul.tag:../../../../core/vul/html" href="../../../../core/vul/html/classvul__timestamp.html#a35cb818365be3cd024a9bbfeb83355d8">touch</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; ch)
<a name="l00224"></a>00224 {
<a name="l00225"></a>00225   ch-&gt;set_user_flag(VSOL_FLAG3);
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="keyword">static</span> <span class="keywordtype">bool</span> touched(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; ch)
<a name="l00229"></a>00229 {
<a name="l00230"></a>00230   <span class="keywordflow">return</span> ch-&gt;get_user_flag(VSOL_FLAG3) != 0;
<a name="l00231"></a>00231 }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="comment">//----------------------------------------------------------</span>
<a name="l00234"></a>00234 <span class="comment">//:   Get an array of edges attached to a vertex.</span>
<a name="l00235"></a>00235 <span class="comment">//    Only those edges</span>
<a name="l00236"></a>00236 <span class="comment">//    present in the given edge array are considered attached. Previously</span>
<a name="l00237"></a>00237 <span class="comment">//    un-traversed edges are returned unless force == true. Then edges</span>
<a name="l00238"></a>00238 <span class="comment">//    which are half-used are allowed in the returned set.</span>
<a name="l00239"></a>00239 <span class="keyword">static</span> <span class="keywordtype">void</span> v_edges(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v, vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; b_edges,
<a name="l00240"></a>00240                     <span class="keywordtype">bool</span> force, vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; edges_at_vertex)
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242   edges_at_vertex.clear();
<a name="l00243"></a>00243   <a class="code" href="vtol__topology__object_8h.html#ae8e5637ad9ee96d538018c6be317a689">edge_list</a> <a class="code" href="classvtol__topology__object.html#a380b2f5f1d74935d0adec465c1f69fd7" title="Get list of edges.">edges</a>; v-&gt;edges(edges);
<a name="l00244"></a>00244   <span class="keywordflow">for</span> (edge_list::iterator eit = edges.begin(); eit != edges.end(); ++eit)
<a name="l00245"></a>00245   {
<a name="l00246"></a>00246     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> e = (*eit)-&gt;cast_to_edge_2d();
<a name="l00247"></a>00247     <span class="keywordflow">if</span> (vcl_find(b_edges.begin(), b_edges.end(),e) != b_edges.end())
<a name="l00248"></a>00248     {
<a name="l00249"></a>00249       <span class="keywordflow">if</span> (used(e))
<a name="l00250"></a>00250         <span class="keywordflow">continue</span>;
<a name="l00251"></a>00251       <span class="keywordflow">if</span> (unused(e))
<a name="l00252"></a>00252         edges_at_vertex.push_back(e);
<a name="l00253"></a>00253       <span class="keywordflow">if</span> (half_used(e)&amp;&amp;force)
<a name="l00254"></a>00254         edges_at_vertex.push_back(e);
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256   }
<a name="l00257"></a>00257 }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">double</span> flip_y(<span class="keywordtype">double</span> ang)
<a name="l00260"></a>00260 {
<a name="l00261"></a>00261   <span class="comment">// no need to use sin(), cos() and atan2() for this job! - PVr</span>
<a name="l00262"></a>00262   ang = vcl_fmod(ang,360.0);
<a name="l00263"></a>00263   <span class="keywordflow">if</span> (ang &lt;= 0) ang += 360.0;
<a name="l00264"></a>00264   <span class="keywordflow">return</span> 360.0-ang;
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="keyword">static</span> <span class="keywordtype">double</span> tangent_angle_at_vertex(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v, <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> e)
<a name="l00268"></a>00268 {
<a name="l00269"></a>00269   <span class="keywordtype">double</span> ang = 0;
<a name="l00270"></a>00270   <span class="keywordflow">if</span> (!e||!v||!(v==e-&gt;v1()||v==e-&gt;v2()))
<a name="l00271"></a>00271   {
<a name="l00272"></a>00272     vcl_cout &lt;&lt; <span class="stringliteral">&quot;vtol_vertex and vtol_edge not incident\n&quot;</span>;
<a name="l00273"></a>00273     <span class="keywordflow">return</span> ang;
<a name="l00274"></a>00274   }
<a name="l00275"></a>00275   <span class="comment">//Here we assume that the edgel_chain starts at v1 and ends at v2;</span>
<a name="l00276"></a>00276   <span class="keywordflow">if</span> (v==e-&gt;v1())
<a name="l00277"></a>00277   {
<a name="l00278"></a>00278     ang = e-&gt;curve()-&gt;cast_to_vdgl_digital_curve()-&gt;
<a name="l00279"></a>00279                         get_interpolator()-&gt;get_tangent_angle(0);
<a name="l00280"></a>00280   }
<a name="l00281"></a>00281   <span class="keywordflow">else</span>
<a name="l00282"></a>00282   {
<a name="l00283"></a>00283     <span class="keywordtype">int</span> N = e-&gt;curve()-&gt;cast_to_vdgl_digital_curve()-&gt;
<a name="l00284"></a>00284                           get_interpolator()-&gt;get_edgel_chain()-&gt;size();
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     ang = e-&gt;curve()-&gt;cast_to_vdgl_digital_curve()-&gt;
<a name="l00287"></a>00287                         get_interpolator()-&gt;get_tangent_angle(N-1);
<a name="l00288"></a>00288     <span class="comment">//reverse the angle since we are at the end rather than the start of the edge?</span>
<a name="l00289"></a>00289     ang += 180.0;
<a name="l00290"></a>00290   }
<a name="l00291"></a>00291   <span class="comment">//If we want cw and ccw to be correct senses, we flip y because the input</span>
<a name="l00292"></a>00292   <span class="comment">//edges are in image coordinates that has a left-handed coordinate system.</span>
<a name="l00293"></a>00293   <span class="keywordflow">return</span> flip_y(ang);
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="comment">//----------------------------------------------------------------</span>
<a name="l00297"></a>00297 <span class="comment">//:   Find the vtol_vertex, if any,  which is shared by two vtol_edge(s)</span>
<a name="l00298"></a>00298 <span class="keyword">static</span> <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> common_vertex(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e0, <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e1)
<a name="l00299"></a>00299 {
<a name="l00300"></a>00300   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v01 = e0-&gt;v1(), v02 = e0-&gt;v2();
<a name="l00301"></a>00301   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v11 = e1-&gt;v1(), v12 = e1-&gt;v2();
<a name="l00302"></a>00302   <span class="keywordflow">if</span> ((<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>)v01==(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>)v11)
<a name="l00303"></a>00303     <span class="keywordflow">return</span> v01;
<a name="l00304"></a>00304   <span class="keywordflow">if</span> ((<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>)v01==(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>)v12)
<a name="l00305"></a>00305     <span class="keywordflow">return</span> v01;
<a name="l00306"></a>00306   <span class="keywordflow">if</span> ((<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>)v02==(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>)v11)
<a name="l00307"></a>00307     <span class="keywordflow">return</span> v02;
<a name="l00308"></a>00308   <span class="keywordflow">if</span> ((<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>)v02==(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>)v12)
<a name="l00309"></a>00309     <span class="keywordflow">return</span> v02;
<a name="l00310"></a>00310   <span class="keywordflow">return</span> NULL;
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="comment">//----------------------------------------------------------------</span>
<a name="l00314"></a>00314 <span class="comment">//:   Compute the angle between two edges at the specified vtol_vertex, v</span>
<a name="l00315"></a>00315 <span class="comment">//    The angle is mapped to the interval [-180, 180].  The angle sense is</span>
<a name="l00316"></a>00316 <span class="comment">//    defined so that the e0 orientation is towards v and the e1</span>
<a name="l00317"></a>00317 <span class="comment">//    orientation is away from v.</span>
<a name="l00318"></a><a class="code" href="classvtol__cycle__processor.html#adf4c375cb74e074893b404bda1d2f6cd">00318</a> <span class="keywordtype">double</span> <a class="code" href="classvtol__cycle__processor.html#adf4c375cb74e074893b404bda1d2f6cd" title="Compute the angle between two edges at the specified vtol_vertex, v.">vtol_cycle_processor::angle_between_edges</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> e0,
<a name="l00319"></a>00319                                                  <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> e1,
<a name="l00320"></a>00320                                                  <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v)
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322   <span class="keywordtype">double</span> theta0 = 180+tangent_angle_at_vertex(v, e0);
<a name="l00323"></a>00323   <span class="keywordflow">if</span> (theta0&gt;360)
<a name="l00324"></a>00324     theta0 -= 360;
<a name="l00325"></a>00325   <span class="keywordtype">double</span> theta1 = tangent_angle_at_vertex(v, e1);
<a name="l00326"></a>00326   <span class="keywordtype">double</span> angle = theta1-theta0;
<a name="l00327"></a>00327   <span class="keywordflow">if</span> (angle&gt;180)
<a name="l00328"></a>00328     angle-=360;
<a name="l00329"></a>00329   <span class="keywordflow">if</span> (angle&lt;-180)
<a name="l00330"></a>00330     angle+=360;
<a name="l00331"></a>00331   <span class="keywordflow">return</span> angle;
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="comment">//------------------------------------------------------------</span>
<a name="l00335"></a>00335 <span class="comment">//:   Find the most counter clockwise vtol_edge at the input vtol_vertex, from.</span>
<a name="l00336"></a>00336 <span class="comment">//</span>
<a name="l00337"></a>00337 <span class="keyword">static</span> <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> ccw_edge(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> in_edg, <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> from,
<a name="l00338"></a>00338                                   vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; edges)
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340   <span class="keywordtype">double</span> most_ccw = -360;
<a name="l00341"></a>00341   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> ccw = NULL;
<a name="l00342"></a>00342   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = edges.begin();
<a name="l00343"></a>00343        eit != edges.end(); ++eit)
<a name="l00344"></a>00344   {
<a name="l00345"></a>00345     <span class="keywordflow">if</span> ((*eit)==in_edg)
<a name="l00346"></a>00346       <span class="keywordflow">continue</span>;
<a name="l00347"></a>00347     <span class="keywordtype">double</span> delta = <a class="code" href="classvtol__cycle__processor.html#adf4c375cb74e074893b404bda1d2f6cd" title="Compute the angle between two edges at the specified vtol_vertex, v.">vtol_cycle_processor::angle_between_edges</a>(in_edg, *eit, from);
<a name="l00348"></a>00348     <span class="keywordflow">if</span> (delta&gt;most_ccw)
<a name="l00349"></a>00349     {
<a name="l00350"></a>00350       most_ccw = delta;
<a name="l00351"></a>00351       ccw = *eit;
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353   }
<a name="l00354"></a>00354   <span class="comment">//There were no edges found except the incoming edge, so return it.</span>
<a name="l00355"></a>00355   <span class="keywordflow">if</span> (!ccw &amp;&amp; vcl_find(edges.begin(), edges.end(),in_edg) != edges.end())
<a name="l00356"></a>00356     ccw = in_edg;
<a name="l00357"></a>00357   <span class="keywordflow">return</span> ccw;
<a name="l00358"></a>00358 }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360 <span class="comment">//-----------------------------------------------------</span>
<a name="l00361"></a>00361 <span class="comment">//:   Is an edge assignable to a path?</span>
<a name="l00362"></a>00362 <span class="comment">//    &quot;Assignable&quot; is defined by</span>
<a name="l00363"></a>00363 <span class="comment">//    the condition that an edge has not already been traversed in</span>
<a name="l00364"></a>00364 <span class="comment">//    the required direction.  That is, if a traversal from s to e,</span>
<a name="l00365"></a>00365 <span class="comment">//    (V1 to V2) has occurred then dir1 is true.  A second traversal</span>
<a name="l00366"></a>00366 <span class="comment">//    is not allowed and the edge is considered un-assignable.</span>
<a name="l00367"></a>00367 <span class="comment">//</span>
<a name="l00368"></a><a class="code" href="classvtol__cycle__processor.html#ac01117706a9747e34c4bad60693c54db">00368</a> <span class="keywordtype">bool</span> <a class="code" href="classvtol__cycle__processor.html#ac01117706a9747e34c4bad60693c54db" title="Is an edge assignable to a path?.">vtol_cycle_processor::assignable</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> edg, <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> last)
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a1cd8b52edc826310db88e4151ac134ea">debug2_</a>)
<a name="l00371"></a>00371   {
<a name="l00372"></a>00372     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In assignable(..)\n&quot;</span>
<a name="l00373"></a>00373              &lt;&lt; <span class="stringliteral">&quot;edg &quot;</span> ; this-&gt;<a class="code" href="classvtol__cycle__processor.html#a5f46138fd7d8020db8825e45209d9132">print_edge</a>(edg);
<a name="l00374"></a>00374     vcl_cout &lt;&lt; <span class="stringliteral">&quot;plus used(&quot;</span> &lt;&lt; plus_used(edg) &lt;&lt; <span class="stringliteral">&quot;) minus used(&quot;</span>
<a name="l00375"></a>00375              &lt;&lt; minus_used(edg) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>
<a name="l00376"></a>00376              &lt;&lt; <span class="stringliteral">&quot;last &quot;</span> &lt;&lt; *last &lt;&lt; vcl_endl;
<a name="l00377"></a>00377   }
<a name="l00378"></a>00378   <span class="keywordflow">if</span> (!edg||!last)
<a name="l00379"></a>00379     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00380"></a>00380   <span class="keywordflow">if</span> (unused(edg))
<a name="l00381"></a>00381     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00382"></a>00382   <span class="keywordflow">if</span> (used(edg))
<a name="l00383"></a>00383     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00384"></a>00384   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> s = edg-&gt;v1();
<a name="l00385"></a>00385   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> e = edg-&gt;v2();
<a name="l00386"></a>00386   <span class="keywordflow">if</span> (last==s&amp;&amp;!plus_used(edg))
<a name="l00387"></a>00387     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00388"></a>00388   <span class="keywordflow">if</span> (last==e&amp;&amp;!minus_used(edg))
<a name="l00389"></a>00389     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00390"></a>00390   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00391"></a>00391 }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 <span class="comment">//----------------------------------------------------------------------</span>
<a name="l00394"></a>00394 <span class="comment">//:   Set up the first edge in a cycle (or bridge) traversal.</span>
<a name="l00395"></a>00395 <span class="comment">//    A positive</span>
<a name="l00396"></a>00396 <span class="comment">//    traversal (half edge) is in the direction from v1-&gt;v2.</span>
<a name="l00397"></a>00397 <span class="comment">//    Self loops are a special case and use both directions on one traversal.</span>
<a name="l00398"></a>00398 <span class="comment">//    There is no point in traversing the self loop twice.</span>
<a name="l00399"></a><a class="code" href="classvtol__cycle__processor.html#a68b713b2fc6166a2c57a5d3238663956">00399</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a68b713b2fc6166a2c57a5d3238663956" title="Set up the first edge in a cycle (or bridge) traversal.">vtol_cycle_processor::assign_initial_edge</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e,
<a name="l00400"></a>00400                                                <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>&amp; first,
<a name="l00401"></a>00401                                                <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>&amp; last)
<a name="l00402"></a>00402 {
<a name="l00403"></a>00403   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00404"></a>00404       vcl_cout &lt;&lt; <span class="stringliteral">&quot;==== entering assign_initial_edge =====\n&quot;</span>
<a name="l00405"></a>00405                &lt;&lt; <span class="stringliteral">&quot;e &quot;</span> &lt;&lt; *e &lt;&lt; <span class="stringliteral">&quot;plus used(&quot;</span> &lt;&lt; plus_used(e) &lt;&lt; <span class="stringliteral">&quot;) minus used(&quot;</span>
<a name="l00406"></a>00406                &lt;&lt; minus_used(e) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   <span class="keywordflow">if</span> (used(e))
<a name="l00409"></a>00409   {
<a name="l00410"></a>00410     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In vtol_cycle_processor::assign_intial_edge(..) &quot;</span>
<a name="l00411"></a>00411              &lt;&lt; <span class="stringliteral">&quot;shouldn&#39;t happen - error\n&quot;</span>;
<a name="l00412"></a>00412     <span class="keywordflow">return</span>;
<a name="l00413"></a>00413   }
<a name="l00414"></a>00414   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = e-&gt;v1(), v2 = e-&gt;v2();
<a name="l00415"></a>00415   <span class="keywordflow">if</span> (v1==v2)
<a name="l00416"></a>00416   {
<a name="l00417"></a>00417     use_plus(e);
<a name="l00418"></a>00418     use_minus(e);
<a name="l00419"></a>00419     first = v1; last = v1;
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421   <span class="keywordflow">if</span> (plus_used(e))
<a name="l00422"></a>00422   {
<a name="l00423"></a>00423     use_minus(e);
<a name="l00424"></a>00424     first = v2;
<a name="l00425"></a>00425     last  = v1;
<a name="l00426"></a>00426   }
<a name="l00427"></a>00427   <span class="keywordflow">else</span>
<a name="l00428"></a>00428   {
<a name="l00429"></a>00429     use_plus(e);
<a name="l00430"></a>00430     first = v1;
<a name="l00431"></a>00431     last  = v2;
<a name="l00432"></a>00432   }
<a name="l00433"></a>00433   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00434"></a>00434     vcl_cout &lt;&lt; <span class="stringliteral">&quot;==== leaving assign_initial_edge =====\n&quot;</span>
<a name="l00435"></a>00435              &lt;&lt; <span class="stringliteral">&quot;plus used(&quot;</span> &lt;&lt; plus_used(e) &lt;&lt; <span class="stringliteral">&quot;) minus used(&quot;</span>
<a name="l00436"></a>00436              &lt;&lt; minus_used(e) &lt;&lt; <span class="stringliteral">&quot;)\n\n&quot;</span>;
<a name="l00437"></a>00437 }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="comment">//------------------------------------------------------------</span>
<a name="l00440"></a>00440 <span class="comment">//:   Link the vtol_edge, &quot;edg&quot; to the vtol_vertex, &quot;last&quot;.</span>
<a name="l00441"></a>00441 <span class="comment">//    Set the appropriate direction flag</span>
<a name="l00442"></a>00442 
<a name="l00443"></a><a class="code" href="classvtol__cycle__processor.html#a8b35dc27e0366ea121ddd7e950e587a4">00443</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a8b35dc27e0366ea121ddd7e950e587a4" title="Link the vtol_edge, &quot;edg&quot; to the vtol_vertex, &quot;last&quot;.">vtol_cycle_processor::assign_ends</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> edg, <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a>&amp; last)
<a name="l00444"></a>00444 {
<a name="l00445"></a>00445   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00446"></a>00446       vcl_cout &lt;&lt; <span class="stringliteral">&quot;==== entering assign_ends =====\n&quot;</span>
<a name="l00447"></a>00447                &lt;&lt; <span class="stringliteral">&quot;edg &quot;</span> &lt;&lt; *edg &lt;&lt; <span class="stringliteral">&quot;plus used(&quot;</span> &lt;&lt; plus_used(edg) &lt;&lt; <span class="stringliteral">&quot;) minus used(&quot;</span>
<a name="l00448"></a>00448                &lt;&lt; minus_used(edg) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00449"></a>00449   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> s = edg-&gt;v1();
<a name="l00450"></a>00450   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> e = edg-&gt;v2();
<a name="l00451"></a>00451   <span class="comment">// compare to last point added</span>
<a name="l00452"></a>00452   <span class="comment">// Here we need to be able to use the previous</span>
<a name="l00453"></a>00453   <span class="comment">// edge if there is no other choice</span>
<a name="l00454"></a>00454   <span class="keywordflow">if</span> (last == s)
<a name="l00455"></a>00455   {
<a name="l00456"></a>00456     last = e;
<a name="l00457"></a>00457     use_plus(edg);<span class="comment">//Forward direction</span>
<a name="l00458"></a>00458     <span class="keywordflow">if</span> (s==e)
<a name="l00459"></a>00459       use_minus(edg);<span class="comment">//For a self-loop, any traversal uses it up</span>
<a name="l00460"></a>00460     <span class="keywordflow">return</span>;
<a name="l00461"></a>00461   }
<a name="l00462"></a>00462   <span class="keywordflow">if</span> (last == e)
<a name="l00463"></a>00463   {
<a name="l00464"></a>00464     last = s;
<a name="l00465"></a>00465     use_minus(edg);<span class="comment">//Reverse direction</span>
<a name="l00466"></a>00466     <span class="keywordflow">if</span> (s==e)
<a name="l00467"></a>00467       use_plus(edg);<span class="comment">//For a self-loop, any traversal uses it up</span>
<a name="l00468"></a>00468     <span class="keywordflow">return</span>;
<a name="l00469"></a>00469   }
<a name="l00470"></a>00470   vcl_cout &lt;&lt; <span class="stringliteral">&quot;In vtol_cycle_processor::assign ends(..) - shouldn&#39;t happen\n&quot;</span>;
<a name="l00471"></a>00471 }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="comment">//------------------------------------------------------------</span>
<a name="l00474"></a>00474 <span class="comment">//:</span>
<a name="l00475"></a>00475 <span class="comment">//    Assign the next edge to the top of the edge stack when</span>
<a name="l00476"></a>00476 <span class="comment">//    a cycle is popped off the stack. That is, start the new path</span>
<a name="l00477"></a>00477 <span class="comment">//    with the edge at the top of the stack.  If the stack is</span>
<a name="l00478"></a>00478 <span class="comment">//    empty, then the last assignment to l_ is used.</span>
<a name="l00479"></a>00479 <span class="keyword">static</span> <span class="keywordtype">void</span> assign_stack_edge(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; e_stack, <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; next_edge)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481   <span class="keywordflow">if</span> (!e_stack.size())
<a name="l00482"></a>00482     <span class="keywordflow">return</span>;
<a name="l00483"></a>00483   next_edge = e_stack.back();
<a name="l00484"></a>00484 }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="comment">//------------------------------------------------------------------</span>
<a name="l00487"></a>00487 <span class="comment">//:   The initial setup of the cycle process.</span>
<a name="l00488"></a>00488 <span class="comment">//    Used by the vtol_cycle_processor</span>
<a name="l00489"></a>00489 <span class="comment">//    constructors to establish the start conditions</span>
<a name="l00490"></a><a class="code" href="classvtol__cycle__processor.html#a0de1c26fe5f94cd820fc54778d5d5db7">00490</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a0de1c26fe5f94cd820fc54778d5d5db7" title="The initial setup of the cycle process.">vtol_cycle_processor::init</a>(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; in_edges)
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492   <a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>.clear();
<a name="l00493"></a>00493   <a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.clear();
<a name="l00494"></a>00494   <a class="code" href="classvtol__cycle__processor.html#a1fac85ec11c2f28b0d22b65623fb3324">nested_one_cycles_</a>.clear();
<a name="l00495"></a>00495   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = in_edges.begin();
<a name="l00496"></a>00496        eit != in_edges.end(); ++eit)
<a name="l00497"></a>00497   {
<a name="l00498"></a>00498     <a class="code" href="classvtol__chain.html#af482da14a5793d87e5b72db050b4eff6" title="Reset the chain.">clear</a>(*eit);
<a name="l00499"></a>00499     <a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>.push_back(*eit);
<a name="l00500"></a>00500   }
<a name="l00501"></a>00501   this-&gt;<a class="code" href="classvtol__cycle__processor.html#a48ef63cca8909242f840437e77ff1d00" title="Initializes the search for cycles starting with an unexplored vtol_edge.">set_bridge_vars</a>();
<a name="l00502"></a>00502   <a class="code" href="classvtol__cycle__processor.html#a619c161c8c7f252ae2a85e63775a9cd9">valid_</a> = <span class="keyword">false</span>;
<a name="l00503"></a>00503 }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="comment">//---------------------------------------------------------------</span>
<a name="l00506"></a>00506 <span class="comment">//:  Initializes the search for cycles starting with an unexplored vtol_edge.</span>
<a name="l00507"></a>00507 <span class="comment">//   This initialization is called after a connected set of vtol_edge(s) is</span>
<a name="l00508"></a>00508 <span class="comment">//   completely explored and removed from edges_.</span>
<a name="l00509"></a><a class="code" href="classvtol__cycle__processor.html#a48ef63cca8909242f840437e77ff1d00">00509</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a48ef63cca8909242f840437e77ff1d00" title="Initializes the search for cycles starting with an unexplored vtol_edge.">vtol_cycle_processor::set_bridge_vars</a>()
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511   <span class="keywordflow">if</span> (!<a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>.size())
<a name="l00512"></a>00512     <span class="keywordflow">return</span>;
<a name="l00513"></a>00513   <a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>.clear();
<a name="l00514"></a>00514   <a class="code" href="classvtol__cycle__processor.html#aa4cb54ab5a41b368ba4d7262b1b67b81">e_stack_</a>.clear();
<a name="l00515"></a>00515   <a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a> = <a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>[0];
<a name="l00516"></a>00516   <a class="code" href="classvtol__cycle__processor.html#aa4cb54ab5a41b368ba4d7262b1b67b81">e_stack_</a>.push_back(<a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a>);
<a name="l00517"></a>00517   <a class="code" href="classvtol__cycle__processor.html#a68b713b2fc6166a2c57a5d3238663956" title="Set up the first edge in a cycle (or bridge) traversal.">assign_initial_edge</a>(<a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a>, <a class="code" href="classvtol__cycle__processor.html#a48795b0b787307e1de5ce601642d9dc4">first_</a>, <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>);
<a name="l00518"></a>00518   <a class="code" href="classvtol__cycle__processor.html#a3286f56686008a0ea6f81e96ecb21468">cycle_</a> = <a class="code" href="classvtol__cycle__processor.html#a48795b0b787307e1de5ce601642d9dc4">first_</a>==<a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>;
<a name="l00519"></a>00519   <a class="code" href="classvtol__cycle__processor.html#a3232e0ed4285e76f878eb3cbcc80532b">found_next_edge_</a> = <span class="keyword">true</span>;
<a name="l00520"></a>00520   <a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>.push_back(<a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>);
<a name="l00521"></a>00521   <span class="keywordflow">if</span> (!<a class="code" href="classvtol__cycle__processor.html#a3286f56686008a0ea6f81e96ecb21468">cycle_</a>)
<a name="l00522"></a>00522     <a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>.push_back(<a class="code" href="classvtol__cycle__processor.html#a48795b0b787307e1de5ce601642d9dc4">first_</a>);<span class="comment">//why do we put both first and last on the stack?</span>
<a name="l00523"></a>00523   <span class="keywordflow">else</span>
<a name="l00524"></a>00524     <a class="codeRef" doxygen="core_vul.tag:../../../../core/vul/html" href="../../../../core/vul/html/classvul__timestamp.html#a35cb818365be3cd024a9bbfeb83355d8">touch</a>(<a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a>);
<a name="l00525"></a>00525   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00526"></a>00526   {
<a name="l00527"></a>00527     vcl_cout &lt;&lt; <span class="stringliteral">&quot;------init bridge vars-------\n&quot;</span>
<a name="l00528"></a>00528              &lt;&lt; <span class="stringliteral">&quot;oooooooo Vertex Stack ooooooooo\n&quot;</span>;
<a name="l00529"></a>00529     print_vertices(<a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>);
<a name="l00530"></a>00530     vcl_cout &lt;&lt; <span class="stringliteral">&quot;oooooooo Edge Stack ooooooooo\n&quot;</span>;
<a name="l00531"></a>00531     print_edges(<a class="code" href="classvtol__cycle__processor.html#aa4cb54ab5a41b368ba4d7262b1b67b81">e_stack_</a>);
<a name="l00532"></a>00532   }
<a name="l00533"></a>00533 }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00536"></a>00536 <span class="comment">//:   check for bridges and compute winding angle.</span>
<a name="l00537"></a>00537 <span class="comment">//    (just convenient code packaging for use in classify_path)</span>
<a name="l00538"></a>00538 <span class="comment">//</span>
<a name="l00539"></a>00539 <span class="keyword">static</span> <span class="keywordtype">void</span> classify_adjacent_edges(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e0, <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e1,
<a name="l00540"></a>00540                                     <span class="keywordtype">bool</span>&amp; all_bridge, <span class="keywordtype">double</span>&amp; angle)
<a name="l00541"></a>00541 {
<a name="l00542"></a>00542   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> cv = common_vertex(e0, e1);
<a name="l00543"></a>00543   <span class="keywordflow">if</span> (cv)
<a name="l00544"></a>00544   {
<a name="l00545"></a>00545     angle = <a class="code" href="classvtol__cycle__processor.html#adf4c375cb74e074893b404bda1d2f6cd" title="Compute the angle between two edges at the specified vtol_vertex, v.">vtol_cycle_processor::angle_between_edges</a>(e0, e1, cv);
<a name="l00546"></a>00546     all_bridge = all_bridge &amp;&amp; used(e1) &amp;&amp; bridge_traverse(angle);
<a name="l00547"></a>00547   }
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00551"></a>00551 <span class="comment">//:  Classify two edges, it is simpler to deal with this case exhaustively.</span>
<a name="l00552"></a>00552 <span class="comment">//   Returns true if the path is cycle (not a bridge)</span>
<a name="l00553"></a>00553 <span class="comment">//</span>
<a name="l00554"></a>00554 <span class="keyword">static</span> <span class="keywordtype">bool</span> classify_two_edge_path(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e0, <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e1)
<a name="l00555"></a>00555 {
<a name="l00556"></a>00556   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = e0-&gt;v1(), v2 = e0-&gt;v1();
<a name="l00557"></a>00557   <span class="keywordtype">double</span> angle1 = <a class="code" href="classvtol__cycle__processor.html#adf4c375cb74e074893b404bda1d2f6cd" title="Compute the angle between two edges at the specified vtol_vertex, v.">vtol_cycle_processor::angle_between_edges</a>(e0, e1, v1);
<a name="l00558"></a>00558   <span class="keywordtype">double</span> angle2 = <a class="code" href="classvtol__cycle__processor.html#adf4c375cb74e074893b404bda1d2f6cd" title="Compute the angle between two edges at the specified vtol_vertex, v.">vtol_cycle_processor::angle_between_edges</a>(e0, e1, v2);
<a name="l00559"></a>00559   <span class="keywordtype">bool</span> bridge = bridge_traverse(angle1)&amp;&amp;bridge_traverse(angle2);
<a name="l00560"></a>00560   <span class="keywordflow">return</span> !bridge;
<a name="l00561"></a>00561 }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l00564"></a>00564 <span class="comment">//:</span>
<a name="l00565"></a>00565 <span class="comment">//   Search the set of vtol_edge(s) connected to the last path vertex for</span>
<a name="l00566"></a>00566 <span class="comment">//   a suitable addition to the path</span>
<a name="l00567"></a>00567 <span class="comment">//</span>
<a name="l00568"></a><a class="code" href="classvtol__cycle__processor.html#a4e1eac59dc1a7f23a7ff3a8f3618bff1">00568</a> <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> <a class="code" href="classvtol__cycle__processor.html#a4e1eac59dc1a7f23a7ff3a8f3618bff1" title="Search the set of vtol_edge(s) connected to the last path vertex for a suitable addition to the path...">vtol_cycle_processor::search_for_next_edge</a>(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; edges_at_last)
<a name="l00569"></a>00569 {
<a name="l00570"></a>00570   <span class="keywordflow">while</span> (edges_at_last.size())
<a name="l00571"></a>00571   {
<a name="l00572"></a>00572     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> temp = ccw_edge(<a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a>, <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>, edges_at_last);
<a name="l00573"></a>00573     <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a1cd8b52edc826310db88e4151ac134ea">debug2_</a>)
<a name="l00574"></a>00574     {
<a name="l00575"></a>00575       vcl_cout &lt;&lt; <span class="stringliteral">&quot;next ccw_edge\n&quot;</span>;
<a name="l00576"></a>00576       this-&gt;<a class="code" href="classvtol__cycle__processor.html#a5f46138fd7d8020db8825e45209d9132">print_edge</a>(temp);
<a name="l00577"></a>00577     }
<a name="l00578"></a>00578     <span class="keywordflow">if</span> (!temp || <a class="code" href="classvtol__cycle__processor.html#ac01117706a9747e34c4bad60693c54db" title="Is an edge assignable to a path?.">assignable</a>(temp, <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>))
<a name="l00579"></a>00579       <span class="keywordflow">return</span> temp;
<a name="l00580"></a>00580     edge_2d_erase(edges_at_last, temp);
<a name="l00581"></a>00581   }
<a name="l00582"></a>00582   <span class="keywordflow">return</span> NULL;
<a name="l00583"></a>00583 }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l00586"></a>00586 <span class="comment">//:   A suitable vtol_edge is added to the evolving path</span>
<a name="l00587"></a>00587 <span class="comment">//</span>
<a name="l00588"></a><a class="code" href="classvtol__cycle__processor.html#a249fe335349808430e8214d069efb85a">00588</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a249fe335349808430e8214d069efb85a" title="A suitable vtol_edge is added to the evolving path.">vtol_cycle_processor::add_edge_to_path</a>()
<a name="l00589"></a>00589 {
<a name="l00590"></a>00590   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> temp = <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>;
<a name="l00591"></a>00591   <a class="code" href="classvtol__cycle__processor.html#a8b35dc27e0366ea121ddd7e950e587a4" title="Link the vtol_edge, &quot;edg&quot; to the vtol_vertex, &quot;last&quot;.">assign_ends</a>(<a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a>, temp);
<a name="l00592"></a>00592   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a1cd8b52edc826310db88e4151ac134ea">debug2_</a>)
<a name="l00593"></a>00593     vcl_cout &lt;&lt; <span class="stringliteral">&quot;==== after assign_ends =====\n&quot;</span>
<a name="l00594"></a>00594              &lt;&lt; <span class="stringliteral">&quot;next_edge_ &quot;</span>  &lt;&lt; *<a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a> &lt;&lt; <span class="stringliteral">&quot;plus used(&quot;</span>
<a name="l00595"></a>00595              &lt;&lt; plus_used(<a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a>) &lt;&lt; <span class="stringliteral">&quot;) minus used(&quot;</span>
<a name="l00596"></a>00596              &lt;&lt; minus_used(<a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a>) &lt;&lt; <span class="stringliteral">&quot;)\n\n&quot;</span>;
<a name="l00597"></a>00597   <a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>.push_back(<a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>);
<a name="l00598"></a>00598   <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a> = temp;
<a name="l00599"></a>00599   <a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a> = <a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a>;
<a name="l00600"></a>00600   <a class="code" href="classvtol__cycle__processor.html#aa4cb54ab5a41b368ba4d7262b1b67b81">e_stack_</a>.push_back(<a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a>);
<a name="l00601"></a>00601   <a class="codeRef" doxygen="core_vul.tag:../../../../core/vul/html" href="../../../../core/vul/html/classvul__timestamp.html#a35cb818365be3cd024a9bbfeb83355d8">touch</a>(<a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a>);
<a name="l00602"></a>00602   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00603"></a>00603   {
<a name="l00604"></a>00604     vcl_cout &lt;&lt; <span class="stringliteral">&quot;------assign_edge_to_path-------\n&quot;</span>
<a name="l00605"></a>00605              &lt;&lt; <span class="stringliteral">&quot;oooooooo Vertex Stack ooooooooo\n&quot;</span>;
<a name="l00606"></a>00606     print_vertices(<a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>);
<a name="l00607"></a>00607     vcl_cout &lt;&lt; <span class="stringliteral">&quot;oooooooo Edge Stack ooooooooo\n&quot;</span>;
<a name="l00608"></a>00608     print_edges(<a class="code" href="classvtol__cycle__processor.html#aa4cb54ab5a41b368ba4d7262b1b67b81">e_stack_</a>);
<a name="l00609"></a>00609   }
<a name="l00610"></a>00610 }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00613"></a>00613 <span class="comment">//:   Classify a closed path as a cycle or bridge.</span>
<a name="l00614"></a>00614 <span class="comment">//    The path traverse is reversed since the vtol_edge sequence was</span>
<a name="l00615"></a>00615 <span class="comment">//    popped from the path stack.</span>
<a name="l00616"></a>00616 <span class="comment">//    Thus, the winding angle is opposite in sign, which is</span>
<a name="l00617"></a>00617 <span class="comment">//    accounted for in code.</span>
<a name="l00618"></a><a class="code" href="classvtol__cycle__processor.html#af4b6c6a4c074915d5264ff054b357d5d">00618</a> <span class="keywordtype">bool</span> <a class="code" href="classvtol__cycle__processor.html#af4b6c6a4c074915d5264ff054b357d5d" title="Classify a closed path as a cycle or bridge.">vtol_cycle_processor::classify_path</a>(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; path_edges,
<a name="l00619"></a>00619                                          <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a>&amp; chain)
<a name="l00620"></a>00620 {
<a name="l00621"></a>00621   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00622"></a>00622         vcl_cout &lt;&lt; <span class="stringliteral">&quot;======= In classify_path ========\n&quot;</span>;
<a name="l00623"></a>00623   <span class="keywordflow">if</span> (!path_edges.size())
<a name="l00624"></a>00624     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00625"></a>00625   <a class="code" href="vtol__topology__object_8h.html#ae8e5637ad9ee96d538018c6be317a689">edge_list</a> c_edges;
<a name="l00626"></a>00626   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> e0 = *path_edges.begin();
<a name="l00627"></a>00627   <span class="comment">//If the path is a self_loop then the treatment is special</span>
<a name="l00628"></a>00628   <span class="comment">//A self loop is classified as both a cw and ccw cycle</span>
<a name="l00629"></a>00629   <span class="keywordflow">if</span> (self_loop(e0))
<a name="l00630"></a>00630   {
<a name="l00631"></a>00631     c_edges.push_back(e0-&gt;cast_to_edge());
<a name="l00632"></a>00632     chain = <span class="keyword">new</span> <a class="code" href="classvtol__one__chain.html" title="The class represents a collection of edges and orientations.">vtol_one_chain</a>(c_edges, <span class="keyword">true</span>);
<a name="l00633"></a>00633     set_ccw(chain); set_cw(chain);
<a name="l00634"></a>00634     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00635"></a>00635   }
<a name="l00636"></a>00636   <span class="comment">//scan the path and determine if it is a bridge.  Also compute</span>
<a name="l00637"></a>00637   <span class="comment">//the cumulative angle between vtol_edge(s) along the path</span>
<a name="l00638"></a>00638   <span class="keywordtype">double</span> winding_angle = 0, angle = 0;
<a name="l00639"></a>00639   <span class="keywordtype">bool</span> all_bridge = used(e0);
<a name="l00640"></a>00640   <span class="comment">//If the path has two edges it is simpler to deal with it as follows</span>
<a name="l00641"></a>00641   <span class="comment">//JLM why don&#39;t we mark the edges as all used?</span>
<a name="l00642"></a>00642   <span class="keywordflow">if</span> (path_edges.size()==2)
<a name="l00643"></a>00643     <span class="keywordflow">if</span> (classify_two_edge_path(e0, *(path_edges.begin()+1)))
<a name="l00644"></a>00644     {
<a name="l00645"></a>00645       c_edges.push_back(e0-&gt;cast_to_edge());
<a name="l00646"></a>00646       chain = <span class="keyword">new</span> <a class="code" href="classvtol__one__chain.html" title="The class represents a collection of edges and orientations.">vtol_one_chain</a>(c_edges, <span class="keyword">true</span>);
<a name="l00647"></a>00647       set_ccw(chain); set_cw(chain);
<a name="l00648"></a>00648       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00649"></a>00649     }
<a name="l00650"></a>00650   <span class="comment">//the typical case, three or more edges</span>
<a name="l00651"></a>00651   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = path_edges.begin()+1;
<a name="l00652"></a>00652        eit != path_edges.end(); ++eit)
<a name="l00653"></a>00653   {
<a name="l00654"></a>00654     classify_adjacent_edges(e0, *eit, all_bridge, angle);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656     <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00657"></a>00657       vcl_cout &lt;&lt; <span class="stringliteral">&quot;wind_ang &quot;</span> &lt;&lt; winding_angle &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; angle &lt;&lt; <span class="stringliteral">&quot; = &quot;</span>
<a name="l00658"></a>00658                &lt;&lt; winding_angle - angle &lt;&lt; vcl_endl;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     winding_angle -= angle;<span class="comment">//because pop_stacks reverses the traverse order</span>
<a name="l00661"></a>00661 
<a name="l00662"></a>00662     e0 = *eit;
<a name="l00663"></a>00663   }
<a name="l00664"></a>00664   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> eN = *path_edges.begin();<span class="comment">//The closure of the loop</span>
<a name="l00665"></a>00665   classify_adjacent_edges(e0, eN, all_bridge, angle);
<a name="l00666"></a>00666   winding_angle -= angle;
<a name="l00667"></a>00667   <span class="comment">//If the path is completely a bridge then nothing more is done</span>
<a name="l00668"></a>00668   <span class="keywordflow">if</span> (all_bridge)
<a name="l00669"></a>00669     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00670"></a>00670   <span class="comment">//Form a cycle from the path</span>
<a name="l00671"></a>00671   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = path_edges.begin();
<a name="l00672"></a>00672        eit != path_edges.end(); ++eit)
<a name="l00673"></a>00673     c_edges.push_back((*eit)-&gt;cast_to_edge());
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   chain = <span class="keyword">new</span> <a class="code" href="classvtol__one__chain.html" title="The class represents a collection of edges and orientations.">vtol_one_chain</a>(c_edges, <span class="keyword">true</span>);
<a name="l00676"></a>00676   <span class="comment">//classify the cycle</span>
<a name="l00677"></a>00677   <span class="keywordflow">if</span> (winding_angle&gt;0)
<a name="l00678"></a>00678     set_ccw(chain); <span class="comment">//ccw chain (outer boundary)</span>
<a name="l00679"></a>00679   <span class="keywordflow">else</span>
<a name="l00680"></a>00680     set_cw(chain);<span class="comment">//cw chain (hole boundary)</span>
<a name="l00681"></a>00681   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00682"></a>00682 }
<a name="l00683"></a>00683 
<a name="l00684"></a><a class="code" href="classvtol__cycle__processor.html#a5f46138fd7d8020db8825e45209d9132">00684</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a5f46138fd7d8020db8825e45209d9132">vtol_cycle_processor::print_edge</a>(<a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a>&amp; e)
<a name="l00685"></a>00685 {
<a name="l00686"></a>00686   <span class="keywordflow">if</span> (!e)
<a name="l00687"></a>00687     <span class="keywordflow">return</span>;
<a name="l00688"></a>00688   vcl_cout &lt;&lt; e &lt;&lt; <span class="stringliteral">&quot; :[(&quot;</span> &lt;&lt; e-&gt;v1()-&gt;cast_to_vertex_2d()-&gt;x()
<a name="l00689"></a>00689            &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; e-&gt;v1()-&gt;cast_to_vertex_2d()-&gt;y()&lt;&lt; <span class="stringliteral">&quot;), (&quot;</span>
<a name="l00690"></a>00690            &lt;&lt; e-&gt;v2()-&gt;cast_to_vertex_2d()-&gt;x() &lt;&lt; <span class="charliteral">&#39; &#39;</span>
<a name="l00691"></a>00691            &lt;&lt; e-&gt;v2()-&gt;cast_to_vertex_2d()-&gt;y() &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>;
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00695"></a>00695 <span class="comment">//: The main cycle tracing algorithm.</span>
<a name="l00696"></a>00696 <span class="comment">//  The input is edges_ and the output is chains_, a set of 1-cycles.</span>
<a name="l00697"></a>00697 <span class="comment">//  The approach is to select a vtol_edge from edges_ and explore all the</span>
<a name="l00698"></a>00698 <span class="comment">//  vtol_edge(s) connected to it.  The search proceeds by traversing connected</span>
<a name="l00699"></a>00699 <span class="comment">//  vtol_edge(s), turning in a cw or ccw direction depending on the initial vtol_edge</span>
<a name="l00700"></a>00700 <span class="comment">//  orientation.  If the search returns to a vertex already on the path,</span>
<a name="l00701"></a>00701 <span class="comment">//  then a cycle is output.  The traversed vtol_edge(s) and vertices are pushed</span>
<a name="l00702"></a>00702 <span class="comment">//  onto a stack so that cycles can be &quot;popped&quot; off and the search continued</span>
<a name="l00703"></a>00703 <span class="comment">//  from a proper state.  Each vtol_edge can be traversed in a plus or minus</span>
<a name="l00704"></a>00704 <span class="comment">//  direction (2 half_edges). Thus boundaries might be traced twice producing</span>
<a name="l00705"></a>00705 <span class="comment">//  identical cycles but traversed in opposite senses.</span>
<a name="l00706"></a>00706 <span class="comment">//</span>
<a name="l00707"></a>00707 <span class="comment">//  Bridges are detected by the fact that all vtol_edge(s) in the bridge are</span>
<a name="l00708"></a>00708 <span class="comment">//  used(plus and minus) and the traversal winding angle is 180 deg, i.e.,</span>
<a name="l00709"></a>00709 <span class="comment">//  the path folds exactly back on itself.</span>
<a name="l00710"></a>00710 <span class="comment">//</span>
<a name="l00711"></a>00711 <span class="comment">//  Cycles are labeled according to the accumulated winding angle in</span>
<a name="l00712"></a>00712 <span class="comment">//  traversing the cycle.  If the accumulated angle is + then the</span>
<a name="l00713"></a>00713 <span class="comment">//  cycle is ccw, otherwise cw.  Here, the winding angle is defined as the</span>
<a name="l00714"></a>00714 <span class="comment">//  exterior angle between two sequential vtol_edge(s) in the traversed path.</span>
<a name="l00715"></a>00715 <span class="comment">//</span>
<a name="l00716"></a>00716 <span class="comment">//  In the traversal, completely unused vtol_edge(s) are favored to continue in</span>
<a name="l00717"></a>00717 <span class="comment">//  an unexplored path.  If none are available then the bool, force,</span>
<a name="l00718"></a>00718 <span class="comment">//  is set and the remaining half_edge is used, retracing a previous path</span>
<a name="l00719"></a>00719 <span class="comment">//  in the opposite direction.</span>
<a name="l00720"></a><a class="code" href="classvtol__cycle__processor.html#a74098d40cbcc493adfd650aaf0d332dc">00720</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a74098d40cbcc493adfd650aaf0d332dc" title="The main cycle tracing algorithm.">vtol_cycle_processor::compute_cycles</a>()
<a name="l00721"></a>00721 {
<a name="l00722"></a>00722   <span class="keywordtype">int</span> limit = 10*<a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>.size();<span class="comment">//just to be guard against any infinite loop</span>
<a name="l00723"></a>00723   <span class="keywordflow">while</span> (<a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>.size()&amp;&amp;limit--)<span class="comment">//should be removed when sure none can happen</span>
<a name="l00724"></a>00724     <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a3232e0ed4285e76f878eb3cbcc80532b">found_next_edge_</a>&amp;&amp;!<a class="code" href="classvtol__cycle__processor.html#a3286f56686008a0ea6f81e96ecb21468">cycle_</a>)
<a name="l00725"></a>00725     {
<a name="l00726"></a>00726       <span class="keywordtype">bool</span> force = <span class="keyword">false</span>;
<a name="l00727"></a>00727 
<a name="l00728"></a>00728       <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>&amp;&amp;<a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>) {
<a name="l00729"></a>00729         vcl_cout &lt;&lt; <span class="stringliteral">&quot;last_ =&quot;</span>; <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>-&gt;print(); vcl_cout &lt;&lt;vcl_endl;
<a name="l00730"></a>00730       }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732       vcl_vector&lt;vtol_edge_2d_sptr&gt; edges_at_last;
<a name="l00733"></a>00733       v_edges(<a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>, <a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>, force, edges_at_last);
<a name="l00734"></a>00734       <a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a> = <a class="code" href="classvtol__cycle__processor.html#a4e1eac59dc1a7f23a7ff3a8f3618bff1" title="Search the set of vtol_edge(s) connected to the last path vertex for a suitable addition to the path...">search_for_next_edge</a>(edges_at_last);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736       <span class="keywordflow">if</span> (!<a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a>&amp;&amp;!force)
<a name="l00737"></a>00737       {
<a name="l00738"></a>00738         force = <span class="keyword">true</span>;
<a name="l00739"></a>00739         v_edges(<a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>, <a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>, force, edges_at_last);
<a name="l00740"></a>00740         <a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a> = <a class="code" href="classvtol__cycle__processor.html#a4e1eac59dc1a7f23a7ff3a8f3618bff1" title="Search the set of vtol_edge(s) connected to the last path vertex for a suitable addition to the path...">search_for_next_edge</a>(edges_at_last);
<a name="l00741"></a>00741       }
<a name="l00742"></a>00742       <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>&amp;&amp;<a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a>) {
<a name="l00743"></a>00743         vcl_cout &lt;&lt; <span class="stringliteral">&quot;next_edge_(&quot;</span>&lt;&lt; force &lt;&lt;<span class="stringliteral">&quot;) = &quot;</span>; this-&gt;<a class="code" href="classvtol__cycle__processor.html#a5f46138fd7d8020db8825e45209d9132">print_edge</a>(<a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a>);
<a name="l00744"></a>00744       }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746       <span class="keywordflow">if</span> (!<a class="code" href="classvtol__cycle__processor.html#a017b3a0247733c428851bac505006b38">next_edge_</a>)
<a name="l00747"></a>00747         <a class="code" href="classvtol__cycle__processor.html#a3232e0ed4285e76f878eb3cbcc80532b">found_next_edge_</a> = <span class="keyword">false</span>;
<a name="l00748"></a>00748       <span class="keywordflow">else</span>
<a name="l00749"></a>00749         <a class="code" href="classvtol__cycle__processor.html#a249fe335349808430e8214d069efb85a" title="A suitable vtol_edge is added to the evolving path.">add_edge_to_path</a>();
<a name="l00750"></a>00750       <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00751"></a>00751           vcl_cout &lt;&lt; <span class="stringliteral">&quot;========checking for cycle ===========\n&quot;</span>
<a name="l00752"></a>00752                    &lt;&lt; <span class="stringliteral">&quot; last_ &quot;</span> &lt;&lt; <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a> &lt;&lt; <span class="charliteral">&#39;(&#39;</span>
<a name="l00753"></a>00753                    &lt;&lt; <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>-&gt;cast_to_vertex_2d()-&gt;x()&lt;&lt; <span class="charliteral">&#39; &#39;</span>
<a name="l00754"></a>00754                    &lt;&lt; <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>-&gt;cast_to_vertex_2d()-&gt;y()&lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00755"></a>00755       <a class="code" href="classvtol__cycle__processor.html#a3286f56686008a0ea6f81e96ecb21468">cycle_</a> = vcl_find(<a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>.begin(), <a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>.end(), <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>) != <a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>.end();
<a name="l00756"></a>00756       <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>&amp;&amp;<a class="code" href="classvtol__cycle__processor.html#a3286f56686008a0ea6f81e96ecb21468">cycle_</a>)
<a name="l00757"></a>00757         vcl_cout &lt;&lt; <span class="stringliteral">&quot;...Found Cycle....\n\n&quot;</span>;
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759     <span class="keywordflow">else</span>
<a name="l00760"></a>00760     {
<a name="l00761"></a>00761       <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a3286f56686008a0ea6f81e96ecb21468">cycle_</a>)
<a name="l00762"></a>00762       {
<a name="l00763"></a>00763         <a class="code" href="classvtol__cycle__processor.html#a3286f56686008a0ea6f81e96ecb21468">cycle_</a> = <span class="keyword">false</span>;
<a name="l00764"></a>00764         vcl_vector&lt;vtol_edge_2d_sptr&gt; cycle_edges;
<a name="l00765"></a>00765         pop_stacks(<a class="code" href="classvtol__cycle__processor.html#a2dc908c365f037dd01e5b7fdf64164dd">v_stack_</a>, <a class="code" href="classvtol__cycle__processor.html#aa4cb54ab5a41b368ba4d7262b1b67b81">e_stack_</a>, <a class="code" href="classvtol__cycle__processor.html#aa61f62c74afb39d4c72453f7142c78cc">last_</a>, cycle_edges);
<a name="l00766"></a>00766         <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00767"></a>00767         {
<a name="l00768"></a>00768           vcl_cout &lt;&lt; <span class="stringliteral">&quot;======== In Cycle Classifier =======\n&quot;</span>
<a name="l00769"></a>00769                    &lt;&lt; <span class="stringliteral">&quot;cycle_edges\n&quot;</span>;
<a name="l00770"></a>00770           print_edges(cycle_edges);
<a name="l00771"></a>00771         }
<a name="l00772"></a>00772         assign_stack_edge(<a class="code" href="classvtol__cycle__processor.html#aa4cb54ab5a41b368ba4d7262b1b67b81">e_stack_</a>, <a class="code" href="classvtol__cycle__processor.html#a1138803946aef326664fb54d22ee24c5">l_</a>);
<a name="l00773"></a>00773         <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a> cycle;
<a name="l00774"></a>00774         <span class="keywordtype">bool</span> <a class="code" href="classvtol__chain.html#a90a7c6622b0110d17d362ff1a11a570e" title="Is `this&#39; a connected chain ?.">is_cycle</a> = <a class="code" href="classvtol__cycle__processor.html#af4b6c6a4c074915d5264ff054b357d5d" title="Classify a closed path as a cycle or bridge.">classify_path</a>(cycle_edges, cycle);
<a name="l00775"></a>00775         <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00776"></a>00776         {
<a name="l00777"></a>00777           vcl_cout &lt;&lt; <span class="stringliteral">&quot;is_cycle(&quot;</span> &lt;&lt; is_cycle &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00778"></a>00778           <span class="keywordflow">if</span> (cycle)
<a name="l00779"></a>00779           {
<a name="l00780"></a>00780             vcl_cout &lt;&lt; <span class="stringliteral">&quot;cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="stringliteral">&quot;[cw(&quot;</span> &lt;&lt; cw(cycle)
<a name="l00781"></a>00781                      &lt;&lt; <span class="stringliteral">&quot;), ccw(&quot;</span> &lt;&lt; ccw(cycle) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>;
<a name="l00782"></a>00782             vcl_vector&lt;vtol_edge_sptr&gt; c_edges; cycle-&gt;edges(c_edges);
<a name="l00783"></a>00783             vcl_cout &lt;&lt; <span class="stringliteral">&quot;cycle edges\n&quot;</span>;
<a name="l00784"></a>00784             print_edges(c_edges);
<a name="l00785"></a>00785           }
<a name="l00786"></a>00786         }
<a name="l00787"></a>00787         <span class="keywordflow">if</span> (is_cycle)
<a name="l00788"></a>00788           <a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.push_back(cycle);
<a name="l00789"></a>00789         <span class="keywordflow">else</span><span class="comment">//path was all bridge edges, so remove them from consideration</span>
<a name="l00790"></a>00790           <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = cycle_edges.begin();
<a name="l00791"></a>00791                eit != cycle_edges.end(); ++eit)
<a name="l00792"></a>00792             edge_2d_erase(<a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>,*eit);
<a name="l00793"></a>00793       }
<a name="l00794"></a>00794       <span class="keywordflow">if</span> (!<a class="code" href="classvtol__cycle__processor.html#a3232e0ed4285e76f878eb3cbcc80532b">found_next_edge_</a>)
<a name="l00795"></a>00795       {
<a name="l00796"></a>00796         <span class="comment">//Get rid of edges touched in the search</span>
<a name="l00797"></a>00797         vcl_vector&lt;vtol_edge_2d_sptr&gt; removed_edges;
<a name="l00798"></a>00798         <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = <a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>.begin();
<a name="l00799"></a>00799              eit != <a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>.end(); ++eit)
<a name="l00800"></a>00800           <span class="keywordflow">if</span> (touched(*eit)&amp;&amp;used(*eit))
<a name="l00801"></a>00801             removed_edges.push_back(*eit);
<a name="l00802"></a>00802         <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator
<a name="l00803"></a>00803              eit = removed_edges.begin(); eit != removed_edges.end();
<a name="l00804"></a>00804              ++eit)
<a name="l00805"></a>00805           edge_2d_erase(<a class="code" href="classvtol__cycle__processor.html#aaf4d8af2ad57500f73df46f813b86ead">edges_</a>,*eit);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807         this-&gt;<a class="code" href="classvtol__cycle__processor.html#a48ef63cca8909242f840437e77ff1d00" title="Initializes the search for cycles starting with an unexplored vtol_edge.">set_bridge_vars</a>();
<a name="l00808"></a>00808       }
<a name="l00809"></a>00809     }
<a name="l00810"></a>00810   <span class="keywordflow">if</span> (!limit)
<a name="l00811"></a>00811     vcl_cout &lt;&lt; <span class="stringliteral">&quot;Limit Exhaused in vtol_cycle_processor::compute_cycles(..)\n&quot;</span>;
<a name="l00812"></a>00812 }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 <span class="comment">//-----------------------------------------------------------------</span>
<a name="l00815"></a>00815 <span class="comment">//:</span>
<a name="l00816"></a>00816 <span class="comment">//    The input is a set of 1-cycles in chains_.  These cycles are</span>
<a name="l00817"></a>00817 <span class="comment">//    sorted so that they form a proper containment relation.  That</span>
<a name="l00818"></a>00818 <span class="comment">//    is, there is one outer cycle, with traversal in the ccw direction</span>
<a name="l00819"></a>00819 <span class="comment">//    and zero or more interior hole boundaries with traversal in</span>
<a name="l00820"></a>00820 <span class="comment">//    the cw direction. All other cycles are removed.  The output is</span>
<a name="l00821"></a>00821 <span class="comment">//    nested_one_cycles_.</span>
<a name="l00822"></a><a class="code" href="classvtol__cycle__processor.html#a69d36610159544c47d928deaa7725b9a">00822</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a69d36610159544c47d928deaa7725b9a" title="The input is a set of 1-cycles in chains_.">vtol_cycle_processor::sort_one_cycles</a>()
<a name="l00823"></a>00823 {
<a name="l00824"></a>00824   <span class="keywordflow">if</span> (!<a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.size())
<a name="l00825"></a>00825   {
<a name="l00826"></a>00826     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In vtol_cycle_processor::sort_one_cycles(..) no cycles\n&quot;</span>;
<a name="l00827"></a>00827     <span class="keywordflow">return</span>;
<a name="l00828"></a>00828   }
<a name="l00829"></a>00829   <a class="code" href="classvtol__cycle__processor.html#a1fac85ec11c2f28b0d22b65623fb3324">nested_one_cycles_</a>.clear();
<a name="l00830"></a>00830   <span class="comment">//First, find the outer bounding vtol_one_chain. This outer boundary is</span>
<a name="l00831"></a>00831   <span class="comment">//defined as a ccw cycle with the largest bounding box.</span>
<a name="l00832"></a>00832   <span class="comment">//search for the largest ccw bounding box</span>
<a name="l00833"></a>00833   <span class="keywordtype">double</span> area = 0;
<a name="l00834"></a>00834   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_one_chain_sptr</a> outer_chain = 0;
<a name="l00835"></a>00835   <span class="keywordflow">for</span> (one_chain_list::iterator cit=<a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.begin(); cit!=<a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.end(); ++cit)
<a name="l00836"></a>00836   {
<a name="l00837"></a>00837     untouch(*cit);
<a name="l00838"></a>00838     <span class="keywordflow">if</span> (!ccw(*cit))
<a name="l00839"></a>00839       <span class="keywordflow">continue</span>;
<a name="l00840"></a>00840     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> box = (*cit)-&gt;get_bounding_box();
<a name="l00841"></a>00841     <span class="keywordtype">double</span> WxH = box-&gt;width()*box-&gt;height();
<a name="l00842"></a>00842     <span class="keywordflow">if</span> (WxH&gt;area)
<a name="l00843"></a>00843     {
<a name="l00844"></a>00844       area = WxH;
<a name="l00845"></a>00845       outer_chain = *cit;
<a name="l00846"></a>00846     }
<a name="l00847"></a>00847   }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   <span class="keywordflow">if</span> (!outer_chain||!ccw(outer_chain))
<a name="l00850"></a>00850   {
<a name="l00851"></a>00851     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In vtol_cycle_processor::sort_one_cycles(..)&quot;</span>
<a name="l00852"></a>00852              &lt;&lt; <span class="stringliteral">&quot; Shouldn&#39;t happen that there is no outer chain\n&quot;</span>
<a name="l00853"></a>00853              &lt;&lt; <span class="stringliteral">&quot;N cycles = &quot;</span> &lt;&lt; <a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.size() &lt;&lt; vcl_endl;
<a name="l00854"></a>00854     <span class="keywordflow">for</span> (one_chain_list::iterator cit = <a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.begin();
<a name="l00855"></a>00855          cit != <a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.end(); ++cit)
<a name="l00856"></a>00856     {
<a name="l00857"></a>00857       vcl_cout &lt;&lt; <span class="stringliteral">&quot; chain is &quot;</span> &lt;&lt; (ccw(*cit) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;ccw, &quot;</span>
<a name="l00858"></a>00858                &lt;&lt; <span class="stringliteral">&quot;chain is &quot;</span> &lt;&lt; (cw(*cit) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;cw\n&quot;</span>;
<a name="l00859"></a>00859     }
<a name="l00860"></a>00860     vcl_cout &lt;&lt; <span class="stringliteral">&quot;Outer Chain &quot;</span> &lt;&lt; outer_chain &lt;&lt; vcl_endl;
<a name="l00861"></a>00861     <span class="keywordflow">return</span>;
<a name="l00862"></a>00862   }
<a name="l00863"></a>00863   <a class="code" href="classvtol__cycle__processor.html#a1fac85ec11c2f28b0d22b65623fb3324">nested_one_cycles_</a>.push_back(outer_chain);
<a name="l00864"></a>00864   <a class="codeRef" doxygen="core_vul.tag:../../../../core/vul/html" href="../../../../core/vul/html/classvul__timestamp.html#a35cb818365be3cd024a9bbfeb83355d8">touch</a>(outer_chain);
<a name="l00865"></a>00865   <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00866"></a>00866     vcl_cout &lt;&lt; <span class="stringliteral">&quot;Outer Cycle area = &quot;</span> &lt;&lt; area &lt;&lt; vcl_endl;
<a name="l00867"></a>00867   <span class="comment">//At this point, we have the outer bounding chain.</span>
<a name="l00868"></a>00868   <span class="comment">//next we will include any cw cycles that lie inside the</span>
<a name="l00869"></a>00869   <span class="comment">//outer_chain.  We exclude any cycle with the same bounding</span>
<a name="l00870"></a>00870   <span class="comment">//box as the outer cycle.  This condition can occur since the outer</span>
<a name="l00871"></a>00871   <span class="comment">//boundary is mostly traced twice, once ccw and once cw when there is</span>
<a name="l00872"></a>00872   <span class="comment">//an included loop in the outer boundary.  The boundary vertices will</span>
<a name="l00873"></a>00873   <span class="comment">//be identical and thus the bounding box will be the same.</span>
<a name="l00874"></a>00874   <span class="comment">//</span>
<a name="l00875"></a>00875   <span class="comment">// - one caveat is that the equality test below is exact.</span>
<a name="l00876"></a>00876   <span class="comment">//   some situations may require a tolerance</span>
<a name="l00877"></a>00877   <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> b = outer_chain-&gt;get_bounding_box();
<a name="l00878"></a>00878   <span class="keywordflow">for</span> (one_chain_list::iterator cit=<a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.begin(); cit!=<a class="code" href="classvtol__cycle__processor.html#ad347e90a3b11f555eff357f037bf0fee">chains_</a>.end(); ++cit)
<a name="l00879"></a>00879     <span class="keywordflow">if</span> (cw(*cit)&amp;&amp;!touched(*cit))
<a name="l00880"></a>00880     {
<a name="l00881"></a>00881       <span class="keywordflow">if</span> ((*cit)==outer_chain)
<a name="l00882"></a>00882         <span class="keywordflow">continue</span>;
<a name="l00883"></a>00883       <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> bc = (*cit)-&gt;get_bounding_box();
<a name="l00884"></a>00884       <span class="keywordflow">if</span> ((*bc&lt;*b)&amp;&amp;!bc-&gt;near_equal(*b, <a class="code" href="classvtol__cycle__processor.html#a3052cb5b5d48611f3cb5d8c59c47fcae">tolerance_</a>))
<a name="l00885"></a>00885       {
<a name="l00886"></a>00886         <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vsol_box_2d_sptr</a> bc = (*cit)-&gt;get_bounding_box();
<a name="l00887"></a>00887         <span class="keywordflow">if</span> ((*bc&lt;*b)&amp;&amp;!bc-&gt;near_equal(*b, <a class="code" href="classvtol__cycle__processor.html#a3052cb5b5d48611f3cb5d8c59c47fcae">tolerance_</a>))
<a name="l00888"></a>00888         {
<a name="l00889"></a>00889           <span class="keywordflow">if</span> (<a class="code" href="classvtol__cycle__processor.html#a94de2ae2e33712ac526d1dcbf6d553f4">debug1_</a>)
<a name="l00890"></a>00890             vcl_cout &lt;&lt; <span class="stringliteral">&quot;Adding inner cycle with area = &quot;</span>
<a name="l00891"></a>00891                      &lt;&lt; bc-&gt;width()*bc-&gt;height() &lt;&lt; vcl_endl;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893           <a class="code" href="classvtol__cycle__processor.html#a1fac85ec11c2f28b0d22b65623fb3324">nested_one_cycles_</a>.push_back(*cit);
<a name="l00894"></a>00894           <a class="codeRef" doxygen="core_vul.tag:../../../../core/vul/html" href="../../../../core/vul/html/classvul__timestamp.html#a35cb818365be3cd024a9bbfeb83355d8">touch</a>(*cit);
<a name="l00895"></a>00895         }
<a name="l00896"></a>00896       }
<a name="l00897"></a>00897     }
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 
<a name="l00900"></a><a class="code" href="classvtol__cycle__processor.html#a3ad72f7d5bc299293b021f7ca5ed3805">00900</a> <span class="keywordtype">void</span> <a class="code" href="classvtol__cycle__processor.html#a3ad72f7d5bc299293b021f7ca5ed3805">vtol_cycle_processor::process</a>()
<a name="l00901"></a>00901 {
<a name="l00902"></a>00902   this-&gt;<a class="code" href="classvtol__cycle__processor.html#a74098d40cbcc493adfd650aaf0d332dc" title="The main cycle tracing algorithm.">compute_cycles</a>();
<a name="l00903"></a>00903   this-&gt;<a class="code" href="classvtol__cycle__processor.html#a69d36610159544c47d928deaa7725b9a" title="The input is a set of 1-cycles in chains_.">sort_one_cycles</a>();
<a name="l00904"></a>00904   <a class="code" href="classvtol__cycle__processor.html#a619c161c8c7f252ae2a85e63775a9cd9">valid_</a> = <span class="keyword">true</span>;
<a name="l00905"></a>00905 }
<a name="l00906"></a>00906 
<a name="l00907"></a><a class="code" href="classvtol__cycle__processor.html#a3969a05d822b42bd2562513537607609">00907</a> <span class="keywordtype">bool</span> <a class="code" href="classvtol__cycle__processor.html#a3969a05d822b42bd2562513537607609">vtol_cycle_processor::nested_one_cycles</a>(<a class="code" href="vtol__topology__object_8h.html#a8f6d4cf2f45c8d953e5b9da7a81a9825">one_chain_list</a>&amp; <a class="code" href="classvtol__topology__object.html#a00f077438a51ba029364662d404a6d38" title="Get list of one chains.">one_chains</a>,
<a name="l00908"></a>00908                                              <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; tolerance)
<a name="l00909"></a>00909 {
<a name="l00910"></a>00910   <span class="keywordflow">if</span> (!<a class="code" href="classvtol__cycle__processor.html#a619c161c8c7f252ae2a85e63775a9cd9">valid_</a>||tolerance!=<a class="code" href="classvtol__cycle__processor.html#a3052cb5b5d48611f3cb5d8c59c47fcae">tolerance_</a>)
<a name="l00911"></a>00911   {
<a name="l00912"></a>00912     <a class="code" href="classvtol__cycle__processor.html#a3052cb5b5d48611f3cb5d8c59c47fcae">tolerance_</a> = tolerance;
<a name="l00913"></a>00913     <a class="code" href="classvtol__cycle__processor.html#a3ad72f7d5bc299293b021f7ca5ed3805">process</a>();
<a name="l00914"></a>00914   }
<a name="l00915"></a>00915   one_chains = <a class="code" href="classvtol__cycle__processor.html#a1fac85ec11c2f28b0d22b65623fb3324">nested_one_cycles_</a>;
<a name="l00916"></a>00916   <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">//later return error state</span>
<a name="l00917"></a>00917 }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919 <span class="comment">//: flag mutation functions</span>
<a name="l00920"></a>00920 <span class="keyword">static</span> <span class="keywordtype">void</span> clear_flags(vcl_vector&lt;vtol_edge_sptr&gt;&amp; s, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flag)
<a name="l00921"></a>00921 {
<a name="l00922"></a>00922   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_sptr&gt;::iterator eit = s.begin();
<a name="l00923"></a>00923        eit != s.end(); ++eit)
<a name="l00924"></a>00924     (*eit)-&gt;unset_user_flag(flag);
<a name="l00925"></a>00925 }
<a name="l00926"></a>00926 
<a name="l00927"></a>00927 <span class="keyword">static</span> <span class="keywordtype">void</span> set_flags(vcl_vector&lt;vtol_edge_sptr&gt;&amp; s, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flag)
<a name="l00928"></a>00928 {
<a name="l00929"></a>00929   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_sptr&gt;::iterator eit = s.begin();
<a name="l00930"></a>00930        eit != s.end(); ++eit)
<a name="l00931"></a>00931     (*eit)-&gt;set_user_flag(flag);
<a name="l00932"></a>00932 }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934 <span class="comment">//---------------------------------------------------------------------------</span>
<a name="l00935"></a>00935 <span class="comment">//: This method scans the edge sets s1, s2 and computes their set intersection.</span>
<a name="l00936"></a>00936 <span class="comment">// If the intersection is empty then the method returns false.</span>
<a name="l00937"></a>00937 <span class="comment">// The method uses flags to mark edges appearing in both lists. Thus the</span>
<a name="l00938"></a>00938 <span class="comment">// computation is O(n1+n2).</span>
<a name="l00939"></a>00939 <span class="comment">//</span>
<a name="l00940"></a>00940 <span class="comment">// This method might not be needed if stl algorithms worked (&quot;old&quot; vcl probs)</span>
<a name="l00941"></a>00941 <span class="comment">// however with flags this might be faster than stl</span>
<a name="l00942"></a>00942 <span class="comment">//</span>
<a name="l00943"></a><a class="code" href="classvtol__cycle__processor.html#ae19d91d0258afa6078b299ac058f0eee">00943</a> <span class="keywordtype">bool</span> <a class="code" href="classvtol__cycle__processor.html#ae19d91d0258afa6078b299ac058f0eee" title="set operations on edges">vtol_cycle_processor::intersect_edges</a>(vcl_vector&lt;vtol_edge_sptr&gt;&amp; s1,
<a name="l00944"></a>00944                                            vcl_vector&lt;vtol_edge_sptr&gt;&amp; s2,
<a name="l00945"></a>00945                                            vcl_vector&lt;vtol_edge_sptr&gt;&amp; s1_and_s2)
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947   s1_and_s2.clear();
<a name="l00948"></a>00948   <span class="comment">//If either set is empty then the result is empty</span>
<a name="l00949"></a>00949   <span class="keywordflow">if</span> (!(s1.size()&amp;&amp;s2.size()))
<a name="l00950"></a>00950     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00951"></a>00951   <span class="comment">//Get Flags</span>
<a name="l00952"></a>00952   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flag1 = <a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#ace99ba03a9b08208acecb2427919881e">VSOL_FLAG5</a>, flag2 = <a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#a38fee115168ddf077b921c4f8edae69b">VSOL_FLAG6</a>;
<a name="l00953"></a>00953   <span class="comment">//Scan through s2 and clear the flags</span>
<a name="l00954"></a>00954   clear_flags(s2, flag1);
<a name="l00955"></a>00955   clear_flags(s2, flag2);
<a name="l00956"></a>00956 
<a name="l00957"></a>00957   <span class="comment">//Scan through s1 and set flag 1 which is used to indicate</span>
<a name="l00958"></a>00958   <span class="comment">//that an edge is in s1.</span>
<a name="l00959"></a>00959   set_flags(s1, flag1);
<a name="l00960"></a>00960 
<a name="l00961"></a>00961   <span class="comment">//Scan s2 again and push edges also in s1  onto the set intersection</span>
<a name="l00962"></a>00962   <span class="comment">//mark the edge as in the output list with flag2.</span>
<a name="l00963"></a>00963   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_sptr&gt;::iterator eit = s2.begin();
<a name="l00964"></a>00964        eit != s2.end(); ++eit)
<a name="l00965"></a>00965   {
<a name="l00966"></a>00966     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_sptr</a> e = *eit;
<a name="l00967"></a>00967     <span class="keywordflow">if</span> (e-&gt;get_user_flag(flag1)&amp;&amp;!e-&gt;get_user_flag(flag2))
<a name="l00968"></a>00968     {
<a name="l00969"></a>00969       e-&gt;set_user_flag(flag2);<span class="comment">//mark the edge as in the output</span>
<a name="l00970"></a>00970       s1_and_s2.push_back(e);
<a name="l00971"></a>00971     }
<a name="l00972"></a>00972   }
<a name="l00973"></a>00973   <span class="comment">//clean up the flags</span>
<a name="l00974"></a>00974   clear_flags(s1, flag1);
<a name="l00975"></a>00975   clear_flags(s2, flag1);
<a name="l00976"></a>00976   clear_flags(s1, flag2);
<a name="l00977"></a>00977   clear_flags(s2, flag2);
<a name="l00978"></a>00978   <span class="keywordflow">return</span> s1_and_s2.size()&gt;0;
<a name="l00979"></a>00979 }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981 <span class="comment">//---------------------------------------------------------------------------</span>
<a name="l00982"></a>00982 <span class="comment">//: This method scans the edge sets s1, s2 and computes their set difference.</span>
<a name="l00983"></a>00983 <span class="comment">// i.e, s1 with any edges also in s2 removed. If the difference</span>
<a name="l00984"></a>00984 <span class="comment">// is empty then the method returns false. The method uses flags to mark</span>
<a name="l00985"></a>00985 <span class="comment">// edges appearing in both lists. Thus the computation is O(n1+n2).</span>
<a name="l00986"></a>00986 <span class="comment">//</span>
<a name="l00987"></a>00987 <span class="comment">// This method might not be needed if stl algorithms worked (&quot;old&quot; vcl probs)</span>
<a name="l00988"></a>00988 <span class="comment">// however with flags this might be faster than stl</span>
<a name="l00989"></a>00989 <span class="comment">//</span>
<a name="l00990"></a><a class="code" href="classvtol__cycle__processor.html#ac97ef1820d9ae7265763e8c51168bc7e">00990</a> <span class="keywordtype">bool</span> <a class="code" href="classvtol__cycle__processor.html#ac97ef1820d9ae7265763e8c51168bc7e" title="This method scans the edge sets s1, s2 and computes their set difference.">vtol_cycle_processor::difference_edges</a>(vcl_vector&lt;vtol_edge_sptr&gt;&amp; s1,
<a name="l00991"></a>00991                                             vcl_vector&lt;vtol_edge_sptr&gt;&amp; s2,
<a name="l00992"></a>00992                                             vcl_vector&lt;vtol_edge_sptr&gt;&amp; s1_minus_s2)
<a name="l00993"></a>00993 {
<a name="l00994"></a>00994   s1_minus_s2.clear();
<a name="l00995"></a>00995   <span class="comment">//If either set is empty then the result is empty</span>
<a name="l00996"></a>00996   <span class="keywordflow">if</span> (!(s1.size()&amp;&amp;s2.size()))
<a name="l00997"></a>00997     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00998"></a>00998   <span class="comment">//Get Flags</span>
<a name="l00999"></a>00999   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flag1 = <a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#ace99ba03a9b08208acecb2427919881e">VSOL_FLAG5</a>, flag2 = <a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#a38fee115168ddf077b921c4f8edae69b">VSOL_FLAG6</a>;
<a name="l01000"></a>01000   <span class="comment">//Scan through s1 and clear the flags</span>
<a name="l01001"></a>01001   clear_flags(s1, flag1);
<a name="l01002"></a>01002   clear_flags(s1, flag2);
<a name="l01003"></a>01003 
<a name="l01004"></a>01004   <span class="comment">//Scan through s2 and set flag1 which marks that it is in s2.</span>
<a name="l01005"></a>01005   set_flags(s2, flag1);
<a name="l01006"></a>01006 
<a name="l01007"></a>01007   <span class="comment">//Scan s1 again and push edges exclusively in s1 onto the output</span>
<a name="l01008"></a>01008   <span class="comment">//mark the edge as in the output list with flag2.</span>
<a name="l01009"></a>01009   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_sptr&gt;::iterator eit = s1.begin();
<a name="l01010"></a>01010        eit != s1.end(); ++eit)
<a name="l01011"></a>01011   {
<a name="l01012"></a>01012     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_sptr</a> e = *eit;
<a name="l01013"></a>01013     <span class="keywordflow">if</span> (!e-&gt;get_user_flag(flag1)&amp;&amp;!e-&gt;get_user_flag(flag2))
<a name="l01014"></a>01014     {
<a name="l01015"></a>01015       e-&gt;set_user_flag(flag2);<span class="comment">//mark the edge as in the output</span>
<a name="l01016"></a>01016       s1_minus_s2.push_back(e);
<a name="l01017"></a>01017     }
<a name="l01018"></a>01018   }
<a name="l01019"></a>01019   <span class="comment">//Clean up the flags</span>
<a name="l01020"></a>01020   clear_flags(s1, flag1);
<a name="l01021"></a>01021   clear_flags(s2, flag1);
<a name="l01022"></a>01022   clear_flags(s1, flag2);
<a name="l01023"></a>01023   clear_flags(s2, flag2);
<a name="l01024"></a>01024   <span class="keywordflow">return</span> s1_minus_s2.size()&gt;0;
<a name="l01025"></a>01025 }
<a name="l01026"></a>01026 
<a name="l01027"></a>01027 <span class="comment">//--------------------------------------------------------------------</span>
<a name="l01028"></a>01028 <span class="comment">//: mark all vertices as used if they are incident on exactly two edges.</span>
<a name="l01029"></a>01029 <span class="comment">// Vertices that are not incident two edges are output in the vector, bad_verts.</span>
<a name="l01030"></a><a class="code" href="classvtol__cycle__processor.html#a3accb87f31e296a62ebf207ed5d86169">01030</a> <span class="keywordtype">bool</span> <a class="code" href="classvtol__cycle__processor.html#a3accb87f31e296a62ebf207ed5d86169" title="topology repair methods useful in forming cycles.">vtol_cycle_processor::corrupt_boundary</a>(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; edges,
<a name="l01031"></a>01031                                             vcl_vector&lt;vtol_vertex_sptr&gt;&amp; bad_verts)
<a name="l01032"></a>01032 {
<a name="l01033"></a>01033   <span class="keywordtype">bool</span> bad = <span class="keyword">false</span>;
<a name="l01034"></a>01034   <span class="comment">//Initialize Markers</span>
<a name="l01035"></a>01035   <span class="keywordflow">if</span> (!edges.front())
<a name="l01036"></a>01036   {
<a name="l01037"></a>01037     vcl_cout &lt;&lt; <span class="stringliteral">&quot;In cycle_processor::corrupt_boundary - null edge\n&quot;</span>;
<a name="l01038"></a>01038     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01039"></a>01039   }
<a name="l01040"></a>01040   <span class="comment">//setup vertex flags</span>
<a name="l01041"></a>01041   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f1=<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#aa09bd32841efc922d82c90b8f568535d">VSOL_FLAG4</a>, f2=<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#ace99ba03a9b08208acecb2427919881e">VSOL_FLAG5</a>, f3=<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#a38fee115168ddf077b921c4f8edae69b">VSOL_FLAG6</a>;
<a name="l01042"></a>01042   <span class="comment">//Initialize Flags</span>
<a name="l01043"></a>01043   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = edges.begin();
<a name="l01044"></a>01044        eit != edges.end(); ++eit)
<a name="l01045"></a>01045   {
<a name="l01046"></a>01046     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = (*eit)-&gt;v1();
<a name="l01047"></a>01047     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v2 = (*eit)-&gt;v2();
<a name="l01048"></a>01048     v1-&gt;unset_user_flag(f1);
<a name="l01049"></a>01049     v1-&gt;unset_user_flag(f2);
<a name="l01050"></a>01050     v1-&gt;unset_user_flag(f3);
<a name="l01051"></a>01051     v2-&gt;unset_user_flag(f1);
<a name="l01052"></a>01052     v2-&gt;unset_user_flag(f2);
<a name="l01053"></a>01053     v2-&gt;unset_user_flag(f3);
<a name="l01054"></a>01054   }
<a name="l01055"></a>01055   <span class="comment">//Mark using flags that a vertex is incident on two edges</span>
<a name="l01056"></a>01056   <span class="comment">//Flags f1 and f2 act as a counter</span>
<a name="l01057"></a>01057   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = edges.begin();
<a name="l01058"></a>01058        eit != edges.end(); ++eit)
<a name="l01059"></a>01059   {
<a name="l01060"></a>01060     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = (*eit)-&gt;v1();
<a name="l01061"></a>01061     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v2 = (*eit)-&gt;v2();
<a name="l01062"></a>01062     <span class="keywordflow">if</span> (!v1-&gt;get_user_flag(f1))
<a name="l01063"></a>01063       v1-&gt;set_user_flag(f1);
<a name="l01064"></a>01064     <span class="keywordflow">else</span>
<a name="l01065"></a>01065       v1-&gt;set_user_flag(f2);
<a name="l01066"></a>01066     <span class="keywordflow">if</span> (!v2-&gt;get_user_flag(f1))
<a name="l01067"></a>01067       v2-&gt;set_user_flag(f1);
<a name="l01068"></a>01068     <span class="keywordflow">else</span>
<a name="l01069"></a>01069       v2-&gt;set_user_flag(f2);
<a name="l01070"></a>01070   }
<a name="l01071"></a>01071   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = edges.begin();
<a name="l01072"></a>01072        eit != edges.end(); ++eit)
<a name="l01073"></a>01073   {
<a name="l01074"></a>01074     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = (*eit)-&gt;v1();
<a name="l01075"></a>01075     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v2 = (*eit)-&gt;v2();
<a name="l01076"></a>01076     <span class="keywordflow">if</span> ((v1!=v2)&amp;&amp;*v1==*v2)
<a name="l01077"></a>01077       vcl_cout &lt;&lt; <span class="stringliteral">&quot;Improper Loop(\n&quot;</span> &lt;&lt; *v1 &lt;&lt; *v2 &lt;&lt; <span class="stringliteral">&quot;)\n\n&quot;</span>;
<a name="l01078"></a>01078     <span class="keywordtype">bool</span> bad1 = !v1-&gt;get_user_flag(f2);
<a name="l01079"></a>01079     <span class="keywordtype">bool</span> bad2 = !v2-&gt;get_user_flag(f2);
<a name="l01080"></a>01080     <span class="comment">// flag f3 keeps track that we have already put the vertex onto the bad list</span>
<a name="l01081"></a>01081     <span class="keywordflow">if</span> (bad1)
<a name="l01082"></a>01082     {
<a name="l01083"></a>01083       <span class="keywordflow">if</span> (!v1-&gt;get_user_flag(f3))
<a name="l01084"></a>01084       {
<a name="l01085"></a>01085         bad_verts.push_back(v1);
<a name="l01086"></a>01086         v1-&gt;set_user_flag(f3);
<a name="l01087"></a>01087       }
<a name="l01088"></a>01088       bad = <span class="keyword">true</span>;
<a name="l01089"></a>01089     }
<a name="l01090"></a>01090     <span class="keywordflow">if</span> (bad2)
<a name="l01091"></a>01091     {
<a name="l01092"></a>01092       <span class="keywordflow">if</span> (!v2-&gt;get_user_flag(f3))
<a name="l01093"></a>01093       {
<a name="l01094"></a>01094         bad_verts.push_back(v2);
<a name="l01095"></a>01095         v2-&gt;set_user_flag(f3);
<a name="l01096"></a>01096       }
<a name="l01097"></a>01097       bad = <span class="keyword">true</span>;
<a name="l01098"></a>01098     }
<a name="l01099"></a>01099   }
<a name="l01100"></a>01100   <span class="comment">//release the flags</span>
<a name="l01101"></a>01101   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = edges.begin();
<a name="l01102"></a>01102        eit != edges.end(); ++eit)
<a name="l01103"></a>01103   {
<a name="l01104"></a>01104     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = (*eit)-&gt;v1();
<a name="l01105"></a>01105     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v2 = (*eit)-&gt;v2();
<a name="l01106"></a>01106     v1-&gt;unset_user_flag(f1);
<a name="l01107"></a>01107     v1-&gt;unset_user_flag(f2);
<a name="l01108"></a>01108     v1-&gt;unset_user_flag(f3);
<a name="l01109"></a>01109     v2-&gt;unset_user_flag(f1);
<a name="l01110"></a>01110     v2-&gt;unset_user_flag(f2);
<a name="l01111"></a>01111     v2-&gt;unset_user_flag(f3);
<a name="l01112"></a>01112   }
<a name="l01113"></a>01113   <span class="keywordflow">return</span> bad;
<a name="l01114"></a>01114 }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 <span class="comment">//--------------------------------------------------------------------</span>
<a name="l01117"></a>01117 <span class="comment">//:</span>
<a name="l01118"></a>01118 <span class="comment">//    Input is a set of edges that do not form cycles. There is a</span>
<a name="l01119"></a>01119 <span class="comment">//    set of vertices that represent the unconnected endpoints of a</span>
<a name="l01120"></a>01120 <span class="comment">//    set of paths.  Two endpoints can be connected if there exists</span>
<a name="l01121"></a>01121 <span class="comment">//    an edge between them that is not included in the input set of</span>
<a name="l01122"></a>01122 <span class="comment">//    edges.</span>
<a name="l01123"></a><a class="code" href="classvtol__cycle__processor.html#a27022b06b5b7d3bc0ca50ad836ed79f3">01123</a> <span class="keywordtype">bool</span> <a class="code" href="classvtol__cycle__processor.html#a27022b06b5b7d3bc0ca50ad836ed79f3" title="Input is a set of edges that do not form cycles.">vtol_cycle_processor::connect_paths</a>(vcl_vector&lt;vtol_edge_2d_sptr&gt;&amp; edges,
<a name="l01124"></a>01124                                          vcl_vector&lt;vtol_vertex_sptr&gt;&amp; bad_verts)
<a name="l01125"></a>01125 {
<a name="l01126"></a>01126   <span class="keywordtype">bool</span> paths_connected = <span class="keyword">true</span>;
<a name="l01127"></a>01127   <span class="keywordflow">if</span> (!bad_verts.size())
<a name="l01128"></a>01128     <span class="keywordflow">return</span> paths_connected;
<a name="l01129"></a>01129 
<a name="l01130"></a>01130 <span class="comment">//   if (edges.size()==1)</span>
<a name="l01131"></a>01131 <span class="comment">//     vcl_cout &lt;&lt; &quot;One Edge\n&quot;;</span>
<a name="l01132"></a>01132 
<a name="l01133"></a>01133   <span class="comment">//Clear the bad vertex flags</span>
<a name="l01134"></a>01134   vcl_vector&lt;vtol_vertex_sptr&gt; temp;<span class="comment">//temporary bad_verts array</span>
<a name="l01135"></a>01135 
<a name="l01136"></a>01136   <span class="comment">//</span>
<a name="l01137"></a>01137   <span class="comment">//Establish flags</span>
<a name="l01138"></a>01138   <span class="comment">//flag1 defines the state of a vertex in the search for a connecting edge</span>
<a name="l01139"></a>01139   <span class="comment">//flag2 defines the state of a vertex in forming the set edge_verts,</span>
<a name="l01140"></a>01140   <span class="comment">//that is there should be no duplicate vertices</span>
<a name="l01141"></a>01141   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flag1 = <a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#ace99ba03a9b08208acecb2427919881e">VSOL_FLAG5</a>, flag2=<a class="codeRef" doxygen="contrib_gel_vsol.tag:../../../../contrib/gel/vsol/html" href="../../../../contrib/gel/vsol/html/vsol__flags__id_8h.html#a38fee115168ddf077b921c4f8edae69b">VSOL_FLAG6</a>;
<a name="l01142"></a>01142   <span class="comment">//here we assume that all vertices are uniform in flag use.</span>
<a name="l01143"></a>01143   <span class="keywordflow">if</span> (!bad_verts.front())
<a name="l01144"></a>01144     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01145"></a>01145   <span class="comment">//make a copy of bad_verts</span>
<a name="l01146"></a>01146   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_vertex_sptr&gt;::iterator vit = bad_verts.begin();
<a name="l01147"></a>01147        vit != bad_verts.end(); ++vit)
<a name="l01148"></a>01148   {
<a name="l01149"></a>01149     (*vit)-&gt;unset_user_flag(flag1);
<a name="l01150"></a>01150     temp.push_back(*vit);
<a name="l01151"></a>01151   }
<a name="l01152"></a>01152   <span class="comment">//Collect the vertices from edges</span>
<a name="l01153"></a>01153   <span class="comment">//Initialize the flags.</span>
<a name="l01154"></a>01154   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = edges.begin();
<a name="l01155"></a>01155        eit != edges.end(); ++eit)
<a name="l01156"></a>01156   {
<a name="l01157"></a>01157     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = (*eit)-&gt;v1(), v2 = (*eit)-&gt;v2();
<a name="l01158"></a>01158     v1-&gt;unset_user_flag(flag1); v2-&gt;unset_user_flag(flag1);
<a name="l01159"></a>01159     v1-&gt;unset_user_flag(flag2); v2-&gt;unset_user_flag(flag2);
<a name="l01160"></a>01160   }
<a name="l01161"></a>01161   <span class="comment">//cache the verts for the edges already in the paths</span>
<a name="l01162"></a>01162   <span class="comment">//flag1 keeps track of vertices added to edge_verts</span>
<a name="l01163"></a>01163   vcl_vector&lt;vtol_vertex_sptr&gt; edge_verts;
<a name="l01164"></a>01164   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_2d_sptr&gt;::iterator eit = edges.begin();
<a name="l01165"></a>01165        eit != edges.end(); ++eit)
<a name="l01166"></a>01166   {
<a name="l01167"></a>01167     <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v1 = (*eit)-&gt;v1(), v2 = (*eit)-&gt;v2();
<a name="l01168"></a>01168     <span class="keywordflow">if</span> (!v1-&gt;get_user_flag(flag1))
<a name="l01169"></a>01169       {edge_verts.push_back(v1); v1-&gt;set_user_flag(flag1);}
<a name="l01170"></a>01170     <span class="keywordflow">if</span> (!v2-&gt;get_user_flag(flag1))
<a name="l01171"></a>01171       {edge_verts.push_back(v2); v2-&gt;set_user_flag(flag1);}
<a name="l01172"></a>01172   }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174   <span class="comment">//search through the list of bad verts and attempt to connect them</span>
<a name="l01175"></a>01175   <span class="comment">//repaired_verts allows the successfully connected vertices to be</span>
<a name="l01176"></a>01176   <span class="comment">//removed from the bad_verts set.  flag2 marks vertices as used.</span>
<a name="l01177"></a>01177   vcl_vector&lt;vtol_vertex_sptr&gt; repaired_verts;
<a name="l01178"></a>01178   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_vertex_sptr&gt;::iterator vit=bad_verts.begin();
<a name="l01179"></a>01179        vit != bad_verts.end(); ++vit)
<a name="l01180"></a>01180   {
<a name="l01181"></a>01181     <span class="keywordflow">if</span> ((*vit)-&gt;get_user_flag(flag2))<span class="comment">//skip used vertices</span>
<a name="l01182"></a>01182       <span class="keywordflow">continue</span>;
<a name="l01183"></a>01183     <span class="keywordtype">bool</span> found_edge = <span class="keyword">false</span>;
<a name="l01184"></a>01184     <span class="comment">//find edges attached to each bad vert</span>
<a name="l01185"></a>01185     vcl_vector&lt;vtol_edge_sptr&gt; vedges; (*vit)-&gt;edges(vedges);
<a name="l01186"></a>01186     <span class="comment">//scan through vedges to find a connecting edge</span>
<a name="l01187"></a>01187     <span class="keywordflow">for</span> (vcl_vector&lt;vtol_edge_sptr&gt;::iterator eit = vedges.begin();
<a name="l01188"></a>01188          eit != vedges.end()&amp;&amp;!found_edge; ++eit)
<a name="l01189"></a>01189     {
<a name="l01190"></a>01190       <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_edge_2d_sptr</a> e = (*eit)-&gt;cast_to_edge_2d();
<a name="l01191"></a>01191       <a class="codeRef" doxygen="core_vbl.tag:../../../../core/vbl/html" href="../../../../core/vbl/html/classvbl__smart__ptr.html">vtol_vertex_sptr</a> v = (*eit)-&gt;other_endpoint(*(*vit));
<a name="l01192"></a>01192       <span class="comment">//Continue if:</span>
<a name="l01193"></a>01193       <span class="comment">//  0)the edge e is not a 2d edge</span>
<a name="l01194"></a>01194       <span class="comment">//  1)the vertex v has been used;</span>
<a name="l01195"></a>01195       <span class="comment">//  2)v can&#39;t be found in bad_verts;</span>
<a name="l01196"></a>01196       <span class="comment">//  3)v can&#39;t be found in edge_verts;</span>
<a name="l01197"></a>01197       <span class="comment">//  4)e is already in the input edge set.</span>
<a name="l01198"></a>01198       <span class="keywordflow">if</span> (!e)
<a name="l01199"></a>01199         <span class="keywordflow">continue</span>; <span class="comment">//condition 0)</span>
<a name="l01200"></a>01200       <span class="keywordflow">if</span> (v-&gt;get_user_flag(flag2))
<a name="l01201"></a>01201         <span class="keywordflow">continue</span>; <span class="comment">//condition 1)</span>
<a name="l01202"></a>01202       <span class="keywordtype">bool</span> found_in_bad_verts = vcl_find(temp.begin(),temp.end(),v) != temp.end();
<a name="l01203"></a>01203       <span class="keywordtype">bool</span> found_in_edge_verts = <span class="keyword">false</span>;
<a name="l01204"></a>01204       <span class="keywordflow">if</span> (!found_in_bad_verts) <span class="comment">//condition 2)</span>
<a name="l01205"></a>01205         found_in_edge_verts = vcl_find(edge_verts.begin(),edge_verts.end(),v) != edge_verts.end();
<a name="l01206"></a>01206       <span class="keywordflow">if</span> (!found_in_bad_verts &amp;&amp; !found_in_edge_verts) <span class="comment">// condition 3)</span>
<a name="l01207"></a>01207         <span class="keywordflow">continue</span>;
<a name="l01208"></a>01208       <span class="keywordflow">if</span> ( vcl_find(edges.begin(),edges.end(),e) != edges.end())
<a name="l01209"></a>01209         <span class="keywordflow">continue</span>; <span class="comment">//condition 4)</span>
<a name="l01210"></a>01210 
<a name="l01211"></a>01211       <span class="comment">//Found a connecting edge, so add it to the input edges</span>
<a name="l01212"></a>01212       edges.push_back(e);
<a name="l01213"></a>01213       found_edge = <span class="keyword">true</span>;
<a name="l01214"></a>01214       v-&gt;set_user_flag(flag2);
<a name="l01215"></a>01215       (*vit)-&gt;set_user_flag(flag2);
<a name="l01216"></a>01216       <span class="comment">//record the successes</span>
<a name="l01217"></a>01217       repaired_verts.push_back(*vit);
<a name="l01218"></a>01218       repaired_verts.push_back(v);<span class="comment">//should also be in bad_verts</span>
<a name="l01219"></a>01219     }
<a name="l01220"></a>01220     paths_connected =
<a name="l01221"></a>01221       paths_connected&amp;&amp;(*vit)-&gt;get_user_flag(flag2);
<a name="l01222"></a>01222   }
<a name="l01223"></a>01223   <span class="comment">//Clear the flags</span>
<a name="l01224"></a>01224   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_vertex_sptr&gt;::iterator vit = bad_verts.begin();
<a name="l01225"></a>01225        vit!=bad_verts.end(); ++vit)
<a name="l01226"></a>01226   {
<a name="l01227"></a>01227     (*vit)-&gt;unset_user_flag(flag1);
<a name="l01228"></a>01228     (*vit)-&gt;unset_user_flag(flag2);
<a name="l01229"></a>01229   }
<a name="l01230"></a>01230   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_vertex_sptr&gt;::iterator vit = edge_verts.begin();
<a name="l01231"></a>01231        vit!=edge_verts.end(); ++vit)
<a name="l01232"></a>01232   {
<a name="l01233"></a>01233     (*vit)-&gt;unset_user_flag(flag1);
<a name="l01234"></a>01234     (*vit)-&gt;unset_user_flag(flag2);
<a name="l01235"></a>01235   }
<a name="l01236"></a>01236   <span class="comment">//Remove the successful vertex connections</span>
<a name="l01237"></a>01237   <span class="keywordflow">for</span> (vcl_vector&lt;vtol_vertex_sptr&gt;::iterator vit = repaired_verts.begin();
<a name="l01238"></a>01238        vit != repaired_verts.end(); ++vit)
<a name="l01239"></a>01239   {
<a name="l01240"></a>01240     vcl_vector&lt;vtol_vertex_sptr&gt;::iterator erit;
<a name="l01241"></a>01241     erit = vcl_find(bad_verts.begin(), bad_verts.end(), *vit);
<a name="l01242"></a>01242     <span class="keywordflow">if</span> (erit != bad_verts.end())
<a name="l01243"></a>01243       bad_verts.erase(erit);
<a name="l01244"></a>01244   }
<a name="l01245"></a>01245   <span class="keywordflow">return</span> paths_connected;
<a name="l01246"></a>01246 }
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:37:40 for contrib/gel/vtol by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
