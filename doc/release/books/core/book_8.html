<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on May, 1 2013 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>VXL: 8. vgl: Geometry</title>

<meta name="description" content="VXL: 8. vgl: Geometry">
<meta name="keywords" content="VXL: 8. vgl: Geometry">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="vgl"></a>
<a name="SEC90"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="book_7.html#SEC89" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book_7.html#SEC66" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 8. vgl: Geometry </h1>


  <blockquote><p>  <strong>Chapter summary</strong>:
This library provides geometric primitive entities, like points and
lines and planes.  The goal is to provide very lightweight structures
than are just slightly more costly than matrices or vectors.  At the
same time these classes can support all the routine geometric
computations that are needed in basic computer vision operations.  The
idea is that more complex spatial objects would use the vgl operations
to carry out basic geometric computations without duplicating
operations like line intersection.
  </p></blockquote>

<hr size="6">
<a name="SEC91"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC90" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC92" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 8.1 Geometric primitives </h2>
<p>The core geometry library <code>vgl</code> is intended to provide an environment for
geometric primitives, both in Cartesian and homogeneous representations, and
for both 2D and 3D.
</p>
<p>This includes classes for
</p><ul>
<li> Points, lines and planes.
</li><li> Direction vectors.
</li><li> 2D conics and 3D spheres, cones, cylinders and ellipsoids.
</li><li> Rectangular, axes-parallel bounding boxes (2D and 3D).
</li><li> Polygons.
</li><li> Region scan iterators.
</li></ul>

<p>In addition, the <code>vgl/algo</code> library contains functions to perform elementary
geometric operations like intersecting a bundle of planes, finding the nearest
point on a line or a conic, computing the cross ratio of four points or lines, ...
For convenience, most of this functionality is put in a &quot;name space&quot;, separate
for 2D and 3D, and separate for Cartesian and homogeneous representations.
Some of the most elementary operations like distance calculations and simple
intersections are implemented in the <code>vgl</code> library, often through class
methods.
</p>
<p>All representation classes are templated on the computational numeric type,
typically <code>double</code> or <code>float</code>, but it could make sense to use other
types like <code>int</code> (especially with homogeneous representations) or e.g.
<code>vnl_rational</code> or <code>vcl_complex&lt;double&gt;</code>.
</p>
<hr size="6">
<a name="SEC92"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC91" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 8.1.1 Homogeneous 2D classes and operations </h3>
<p>The most general geometric framework is based on projective geometry
and homogeneous coordinates.  Projective operations arise in the
analysis of image geometry and its relationship to the world geometry
projected into the image by perspective cameras.
</p>
<p>The basic 2D classes using homogeneous (3-argument) representations are:
</p>
<ul>
<li> <code>vgl_homg_point_2d&lt;T&gt;</code>
</li><li> <code>vgl_homg_line_2d&lt;T&gt;</code>
</li><li> <code>vgl_conic&lt;T&gt;</code>
</li></ul>
<p>Some useful functions can be found in <code>vgl_intersection.h</code>, <code>vgl_distance.h</code> and <code>vgl_closest_point.h</code>, like e.g.:
</p><ul>
<li> <code>bool vgl_intersection(vgl_line_2d&lt;T&gt; const&amp; line0, vgl_line_2d&lt;T&gt; const&amp; l2, vgl_point_2d&lt;T&gt; &amp; pt)</code>
</li><li> <code>vgl_point_3d&lt;T&gt; vgl_intersection(vgl_line_3d_2_points&lt;T&gt; const&amp; l1, vgl_line_3d_2_points&lt;T&gt; const&amp; l2)</code>
</li><li> <code>double vgl_distance(vgl_homg_point_2d&lt;T&gt; const&amp; p1, vgl_homg_point_2d&lt;T&gt; const&amp; p2)</code>
</li><li> <code>double vgl_distance(vgl_homg_point_2d&lt;T&gt; const&amp; p, vgl_homg_line_2d&lt;T&gt; const&amp; l)</code>
</li><li> <code>vgl_homg_point_2d&lt;T&gt; vgl_closest_point(vgl_homg_line_2d&lt;T&gt; const&amp; l, vgl_homg_point_2d&lt;T&gt; const&amp; p)</code>
</li></ul>
<p>Some of the most useful static functions in namespace <code>vgl_homg_operators_2d&lt;T&gt;</code> are:
</p><ul>
<li> <code>double distance_squared(vgl_homg_point_2d&lt;T&gt; const&amp; point1, vgl_homg_point_2d&lt;T&gt; const&amp; point2)</code>
</li><li> <code>vgl_homg_line_2d&lt;T&gt; join(vgl_homg_point_2d&lt;T&gt; const&amp; point1, vgl_homg_point_2d&lt;T&gt; const&amp; point2)</code>
   to get the line through two points.
</li><li> <code>vgl_homg_point_2d&lt;T&gt; intersection(vgl_homg_line_2d&lt;T&gt; const&amp; line1, vgl_homg_line_2d&lt;T&gt; const&amp; line2)</code>
   to get the intersection point of two lines.
</li><li> <code>void unitize(vgl_homg_point_2d&lt;T&gt; &amp;a)</code>
   to normalize a point representation (3-tuple) to unit magnitude.
</li><li> <code>double cross_ratio(vgl_homg_point_2d&lt;T&gt; const&amp; p1, vgl_homg_point_2d&lt;T&gt; const&amp; p2,
                               vgl_homg_point_2d&lt;T&gt; const&amp; p3, vgl_homg_point_2d&lt;T&gt; const&amp; p4)</code>
</li><li> <code>double angle_between_oriented_lines(vgl_homg_line_2d&lt;T&gt; const&amp; line1, vgl_homg_line_2d&lt;T&gt; const&amp; line2)</code>
    Return the angle between the (oriented) lines (in radians).
</li><li> <code>double perp_distance_squared(vgl_homg_line_2d&lt;T&gt; const&amp; line, vgl_homg_point_2d&lt;T&gt; const&amp; point)</code>
</li><li> <code>vgl_homg_line_2d&lt;T&gt; perp_line_through_point(vgl_homg_line_2d&lt;T&gt; const&amp; line, vgl_homg_point_2d&lt;T&gt; const&amp; point)</code>
</li><li> <code>vgl_homg_point_2d&lt;T&gt; perp_projection(vgl_homg_line_2d&lt;T&gt; const&amp; line, vgl_homg_point_2d&lt;T&gt; const&amp; point)</code>
</li><li> <code>vgl_homg_point_2d&lt;T&gt; midpoint(vgl_homg_point_2d&lt;T&gt; const&amp; p1, vgl_homg_point_2d&lt;T&gt; const&amp; p2)</code>
</li><li> <code>vgl_homg_point_2d&lt;T&gt; lines_to_point(vcl_list&lt;vgl_homg_line_2d&lt;T&gt; &gt; const&amp; lines)</code>
   to intersect a set of 2D lines to find the least-square point of intersection.
</li><li> <code>vcl_list&lt;vgl_homg_point_2d&lt;T&gt; &gt; intersection(vgl_conic&lt;T&gt; const &amp;c, vgl_homg_line_2d&lt;T&gt; const &amp;l)</code>
   to find all real intersection points of a conic and a line (between 0 and 2).
</li><li> <code>vcl_list&lt;vgl_homg_point_2d&lt;T&gt; &gt; intersection(vgl_conic&lt;T&gt; const &amp;c1, vgl_conic&lt;T&gt; const &amp;c2)</code>
   to find all real intersection points of two conics (between 0 and 4).
</li><li> <code>vcl_list&lt;vgl_homg_line_2d&lt;T&gt; &gt; tangent_from(vgl_conic&lt;T&gt; const &amp;c, vgl_homg_point_2d&lt;T&gt; const &amp;p)</code>
   returns the (at most) two tangent lines that pass through p and are tangent to the conic.
</li><li> <code>vgl_homg_point_2d&lt;T&gt; closest_point(vgl_conic&lt;T&gt; const&amp; c, vgl_homg_point_2d&lt;T&gt; const&amp; p)</code>
   returns the point on the conic closest to the given point.
</li></ul>

<p>Homogeneous projective geometry can be converted to standard Euclidean or Cartesian coordinates
by normalizing by the third homogeneous coordinate.  In general there will be need to convert back
and forth between the two geometries to carry out operations efficiently.  For example intersection
of lines in homogeneous coordinates can be carried out simply using the cross-product of vectors.
</p>
<hr size="6">
<a name="SEC93"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC92" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 8.1.2 Cartesian (Euclidean) 2D classes </h3>

<p>The basic 2D classes using non-homogeneous (2-argument) representations are:
</p>
<ul>
<li> <code>vgl_point_2d&lt;T&gt;</code>
</li><li> <code>vgl_vector_2d&lt;T&gt;</code>
</li><li> <code>vgl_line_2d&lt;T&gt;</code>
</li><li> <code>vgl_box_2d&lt;T&gt;</code>
</li></ul>

<p>A vector is a directional difference between two points, i.e., something having a direction and a length.
</p>
<p>A box is a rectangular bounding box, represented by two corner points: the &quot;min&quot; and the &quot;max&quot; coordinate points.
All points inside the box have x coordinates between min-x and max-x, and y coordinates between min-y and max-y.
</p>
<p>There are also two &quot;composite&quot; 2D curve objects:
</p>
<ul>
<li> <code>vgl_line_segment_2d&lt;T&gt;</code>
</li><li> <code>vgl_conic_segment_2d&lt;T&gt;</code>
</li></ul>

<p>A line segment is a bounded part of a line, between two end points.
</p>
<p>A conic segment is built on a <code>vgl_conic&lt;T&gt;</code> and two end points.
This curve only consists of those points of the conic between the two given end points.
(See the detailed documentation of this class for a precise definition of &quot;between&quot;.)
</p>
<hr size="6">
<a name="SEC94"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC93" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 8.1.3 Homogeneous 3D classes and operations </h3>

<p>The basic 3D classes using homogeneous (4-argument) representations are:
</p>
<ul>
<li> <code>vgl_homg_point_3d&lt;T&gt;</code>
</li><li> <code>vgl_homg_plane_3d&lt;T&gt;</code>
</li><li> <code>vgl_homg_line_3d_2_points&lt;T&gt;</code>
</li></ul>
<p>Some useful functions can be found in <code>vgl_distance.h</code> and <code>vgl_closest_point.h</code>:
</p><ul>
<li> <code>double vgl_distance(vgl_homg_point_3d&lt;T&gt; const&amp; p1, vgl_homg_point_3d&lt;T&gt; const&amp; p2)</code>
</li><li> <code>double vgl_distance(vgl_homg_plane_3d&lt;T&gt; const&amp; p1, vgl_homg_point_3d&lt;T&gt; const&amp; p2)</code>
</li><li> <code>double vgl_distance(vgl_homg_line_3d_2_points&lt;T&gt; const&amp; p1, vgl_homg_point_3d&lt;T&gt; const&amp; p2)</code>
</li><li> <code>double vgl_distance(vgl_homg_line_3d_2_points&lt;T&gt; const&amp; p1, vgl_homg_line_3d_2_points&lt;T&gt; const&amp; p2)</code>
</li><li> <code>vgl_homg_point_3d&lt;T&gt; vgl_closest_point(vgl_homg_plane_3d&lt;T&gt; const&amp; l, vgl_homg_point_3d&lt;T&gt; const&amp; p)</code>
</li><li> <code>vgl_homg_point_3d&lt;T&gt; vgl_closest_point(vgl_homg_line_3d_2_points&lt;T&gt; const&amp; l, vgl_homg_point_3d&lt;T&gt; const&amp; p)</code>
</li><li> <code>std::pair&lt;vgl_homg_point_3d&lt;T&gt;,vgl_homg_point_3d&lt;T&gt; &gt; vgl_closest_points(vgl_homg_line_3d_2_points&lt;T&gt; const&amp; l1,
                                                                                     vgl_homg_line_3d_2_points&lt;T&gt; const&amp; l2)</code>
</li></ul>
<p>The most useful static functions in namespace <code>vgl_homg_operators_3d&lt;T&gt;</code> are:
</p><ul>
<li> <code>T distance(vgl_homg_point_3d&lt;T&gt; const&amp; point1, vgl_homg_point_3d&lt;T&gt; const&amp; point2)</code>
</li><li> <code>T distance_squared(vgl_homg_point_3d&lt;T&gt; const&amp; point1, vgl_homg_point_3d&lt;T&gt; const&amp; point2)</code>
</li><li> <code>double perp_distance_squared(vgl_homg_line_3d const&amp; line, vgl_homg_point_3d&lt;T&gt; const&amp; point)</code>
</li><li> <code>vgl_homg_point_3d&lt;T&gt; intersect_line_and_plane(vgl_homg_line_3d const&amp; , vgl_homg_plane_3d&lt;T&gt; const&amp; )</code>
    Return the intersection point of the line and plane.
</li><li> <code>vgl_homg_point_3d&lt;T&gt; perp_projection(vgl_homg_line_3d const&amp; line, vgl_homg_point_3d&lt;T&gt; const&amp; point)</code>
    Compute the perpendicular projection point of p onto l.
</li><li> <code>double angle_between_oriented_lines(vgl_homg_line_3d const&amp; line1, vgl_homg_line_3d const&amp; line2)</code>
    Return the angle between the (oriented) lines (in radians).
</li><li> <code>vgl_homg_point_3d&lt;T&gt; lines_to_point(vcl_vector&lt;vgl_homg_line_3d&gt; const&amp; line_list)</code>
</li><li> <code>vgl_homg_line_3d points_to_line(vcl_vector&lt;vgl_homg_point_3d&lt;T&gt; &gt; const&amp; point_list)</code>
</li><li> <code>vgl_homg_line_3d planes_to_line(vcl_vector&lt;vgl_homg_plane_3d&lt;T&gt; &gt; const&amp; plane_list)</code>
    Return the intersection line of the planes.
</li><li> <code>vgl_homg_plane_3d&lt;T&gt; points_to_plane(vcl_vector&lt;vgl_homg_point_3d&lt;T&gt; &gt; const&amp; point_list)</code>
</li><li> <code>vgl_homg_point_3d&lt;T&gt; intersection_point(vcl_vector&lt;vgl_homg_plane_3d&lt;T&gt; &gt; const&amp; ) double </code>
    Compute best-fit intersection of planes in a point.
</li></ul>

<hr size="6">
<a name="SEC95"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC94" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 8.1.4 Cartesian 3D classes </h3>

<p>The basic 3D classes using non-homogeneous (3-argument) representations are:
</p>
<ul>
<li> <code>vgl_point_3d&lt;T&gt;</code>
</li><li> <code>vgl_vector_3d&lt;T&gt;</code>
</li><li> <code>vgl_plane_3d&lt;T&gt;</code>
</li><li> <code>vgl_box_3d&lt;T&gt;</code>
</li></ul>

<p>&quot;Non-basic&quot; 3D classes, i.e. those built from the basic ones, include:
</p>
<ul>
<li> <code>vgl_line_segment_3d&lt;T&gt;</code>
</li><li> <code>vgl_line_3d_2_points&lt;T&gt;</code>
</li><li> <code>vgl_sphere_3d&lt;T&gt;</code>
</li></ul>

<hr size="6">
<a name="SEC96"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC95" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC97" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 8.1.5 Homogeneous 1D classes </h3>

<p>For sake of completeness, the following 1D representation classes are present:
</p><ul>
<li> <code>vgl_homg_point_1d&lt;T&gt;</code>
</li><li> <code>vgl_1d_basis&lt;T&gt;</code>
</li></ul>

<p>A 1D basis is an arbitrary set of 3 (collinear) points.  One receives coordinate
0 or (0,1), one has coordinate infinity or (1,0) and the unit point has
coordinate 1 or (1,1).  Such a set is an essential ingredient for any projective
transformation.
</p>
<hr size="6">
<a name="SEC97"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC96" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 8.2 2D regions and iterators </h2>

<p>The <code>vgl_polygon&lt;T&gt;</code> class represents a more complex region or area in 2D space.
The <code>vgl_region_scan_iterator</code> class allows for iterating through regions.
More specifically, the derived classes <code>vgl_polygon_scan_iterator&lt;T&gt;</code>,
<code>vgl_triangle_scan_iterator&lt;T&gt;</code>, <code>vgl_ellipse_scan_iterator&lt;T&gt;</code> and
<code>vgl_window_scan_iterator&lt;T&gt;</code> can be used to iterate over the points of a
discrete grid that are interior to the region.
The general case for the polygon scan is shown in Figure 1.
    <p>
  <table border="1" cellpadding="10" align=center width=80%>
  <tr><td>
  <img src="./polygon-scan.png" alt="polygon-scan">
    <caption align="bottom">
  <div align=left><strong>Figure 1:</strong>
  The general situation for a polygon scan iterator.  The polygon defines a set of
discrete scan lines which are bounded by the polygon or by an optional clipping window.
    </div>
  </caption>
      </td></tr></table></p>
  The scan is initiated by calling <code>::reset()</code>.  The boolean method <code>::next()</code>
then iterates over the spans until all spans have been produced.  When no more spans
are available <code>::next()</code> returns false.
Thus an iteration over the interior of the polygon is executed as:
</p><table><tr><td>&nbsp;</td><td><pre class="example">...
vgl_polygon&lt;double&gt; my_polygon;
...
// do something to define the polygon
...
vgl_polygon_scan_iterator&lt;double&gt; psi(mypolygon);
psi.set_include_boundary(true); // optional flag, default is true
for (psi.reset(); psi.next(); ) {
  int y = psi.scany();
  for (int x = psi.startx(); x &lt;= psi.endx(); ++x)
    ....
    // do something with x and y, e.g. compute the center of gravity of
    // the interior points.
}
</pre></td></tr></table><p>The <code>vgl_polygon_scan_iterator&lt;T&gt;</code> also supports the specification
of an optional clipping window.  The window is intersected with the polygon
to define scan region as shown in Figure 1.  The window is specified by
an alternative constructor:
</p><table><tr><td>&nbsp;</td><td><pre class="example">vgl_polygon_scan_iterator&lt;float&gt;(vgl_polygon&lt;float&gt; const&amp; face, bool boundaryp,
                                 vgl_box_2d&lt;float&gt; const&amp; window)
</pre></td></tr></table><p>Note that the boundaryp flag is defined to determine if points on the boundary
of the polygon or window are to be included in the scan.
</p>
<p>The area of a polygon can be determined with the <code>vgl_area</code> function.
</p>
<hr size="6">
<a name="SEC98"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC97" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC99" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 8.3 Projective transformations </h2>
<p>One of the goals of vgl is to support the basic operations of
projective geometry.  This goal inevitably entails the use of
projective transformations which are typically represented as square
matrices of dimension n+1, where n is the dimension of the geometric
space in which a point set is embedded.  Because of the strict rules of
core libraries, vgl is not permitted to require other core libraries
in order to carry out its operations.  At the same time there is no
justification to re-invent a numerical library within vxl simply to
avoid library cross-linking.  The solution is to define a <code>vgl/algo</code>
library that can link to vnl and thus make use of the necessary vnl
functions.  A user can cleanly link to very basic vgl classes without
including vnl, but the full operations of projective geometry will
require the use of vnl matrix algorithms.
    <p>
  <table border="1" cellpadding="10" align=center width=80%>
  <tr><td>
  <img src="./homography.png" alt="homography">
    <caption align="bottom">
  <div align=left><strong>Figure 2:</strong>
  The mapping of points from one projective plane to another.  The transformation can be represented by a 3x3 matrix.
    </div>
  </caption>
      </td></tr></table></p>
  </p><hr size="6">
<a name="SEC99"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC98" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC100" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 8.3.1 2-d projective transformations </h3>
<p>Much of the discussion here will center on the projective plane (2-d
points and lines) but a partial set of operations are available for
both 1-d and 3-d geometry.  The basic operation is to transform a point
or line, and in the projective plane this corresponds to multiplying
the vector of corresponding homogeneous coordinates by a 3x3
transformation matrix.  This basic operation is illustrated in Figure
2.  The projective transformation between planes is often called a
planar homography, thus the symbol h, or H, is used to represent transformations.
</p>
<p>The class <code>vgl_h_matrix_2d&lt;T&gt;</code> defines the basic operations of a planar homography.
Points and lines are transformed by the operator <code>()</code> or the <code>*</code> operator as for example,
</p><table><tr><td>&nbsp;</td><td><pre class="example">...
vnl_matrix_fixed &lt;double, 3,3&gt; M;
...
//define M somehow
...
vgl_h_matrix_2d &lt;double&gt; H(M);
vgl_homg_point_2d&lt;double&gt; X(1.0, 0.0, 1.0), x1, x2;
x1 = H(X);
x2 = H*X;
...

</pre></td></tr></table><p>and x1 ~ x2, where ~ indicates that the two points are projectively
equivalent.  That is, their three homogeneous coordinates are within a
scale factor of each other.
</p>
<p>The method <code>preimage</code> effects the
inverse transformation.  So continuing with our example,
</p><table><tr><td>&nbsp;</td><td><pre class="example">...
vgl_homg_point_2d &lt;double&gt; Xpre;
Xpre = H.preimage(x1);
..
</pre></td></tr></table><p>and X ~ Xpre.  This operation is carried out by inverting the forward transformation matrix.
</p>
<p>The process is similar for lines, but it should be noted that the
transformation for lines requires a different matrix then that for
points.  It can be shown that,
</p>
<p>H_line = (H_point)^-t
</p>
<p>where ^-t indicates the transpose of the inverse of a matrix.  Thus,
the forward transformation of a line from plane 1 to plane 2 requires
a matrix inverse.  On the other hand, the pre-image operation is
easier, only requiring a matrix transpose.
</p>
<p>The ambiguity as to whether an <code>vgl_h_matrix_2d&lt;T&gt;</code> is a point
mapping or a line mapping is avoided by the convention that the class
only refers to point mappings.  The matrix inverse could be cached to
avoid extra computation, but currently it is not, since there hasn't
been performance issues to motivate the extra machinery.  Still, the
user should be aware that inversion is occurring on every forward line
transformation.
</p>
<hr size="6">
<a name="SEC100"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC99" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC101" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 8.3.2 3-d projective transformations </h3>
<p><code>vgl/algo</code> also provides a basic capability for carrying out 3-d
to 3-d projective transformations, based on a 4x4 linear matrix
multiplication.  The most common application is to implement Euclidean
transformations (rotation and translation) in a unified, compact framework.
For example the following code defines a Euclidean transformation
based on a given axis of rotation:
</p><table><tr><td>&nbsp;</td><td><pre class="example">vgl_h_matrix_3d &lt;double&gt; Hrot, Htrans, H;

//Setup the rotation transformation
vnl_vector_fixed&lt;double, 3&gt; axis(0.0,0.0,1.0);//The z axis
double angle = vnl_math::pi/4.0;//45 degree rotation
Hrot.set_rotation_about_axis(axis, angle);

//Set up the translation transformation
Htrans.set_translation(1.0, 2.0, 3.0);

//compose the two.  The rotation is applied first and then the translation
H = Htrans*Hrot;
...
// Transform a 3-d homogeneous point
vgl_homg_point_3d&lt;double&gt; X(1.0, 0.0, 0.0, 1.0), x;
x = H(X);
//
//The resulting transformed point
// x = (1.707, 2.707, 3.0, 1.0)
</pre></td></tr></table><p>In 3-d projective space, points and planes hold the same dual relationship as points and lines do
in 2-d projective space.  In 3-d, planes are transformed by H^-t, where H is a 3-d projective transformation on points.
</p>
<p>Lines in 3-d are considerably more complicated than points and
planes.  The representation called Plucker coordinates which allows
computations involving lines to be carried out using matrix and vector
operations.  It is planned to introduce Plucker geometry into <code>vgl/algo</code>
when the need arises.
</p>
<hr size="6">
<a name="SEC101"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC100" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 8.4 Computing 2-d projective transformations </h2>
<p>A standard coordinate frame is defined in projective geometry, called the
<em>projective basis</em>.  The basis is constructed from four points and in the
coordinate frame of the basis these points have coordinates as follows:
</p><table><tr><td>&nbsp;</td><td><pre class="example">   p[0] p[1] p[2] p[3]
    1    0    0    1
    0    1    0    1
    0    0    1    1
</pre></td></tr></table><p>Note that the first two points are <em>points at infinity</em>, or
<em>ideal</em> points that indicate the direction of the x and y
coordinate axes.  The third point is the origin and the last point is
called the <em>unit</em> point and is at Euclidean coordinates (1,1).
The method <code>bool projective_basis(vcl_vector&lt;vgl_homg_point_2d&lt;T&gt; &gt; const &amp; four_points)</code>
sets the transformation so as to map points from their projective plane to the plane defined by the canonical basis.
</p>

<p>The more general case is based on classes that compute a plane projective
transformations based on sets of corresponding points or lines.  For example,
</p><table><tr><td>&nbsp;</td><td><pre class="example">
vgl_h_matrix_2d_compute_linear hcl;
vcl_vector &lt;vgl_homg_point_2d &lt;double&gt; &gt; point_set1, point_set2;
...
//fill these two vectors with corresponding points
//taken from two projective planes,
//e.g. a world plane and the image plane.
//
vgl_h_matrix_2d &lt;double&gt; H = hcl.compute(point_set1, point_set2);
// H represents the homography that
// transforms points from plane1 into plane2.

</pre></td></tr></table>
<p>This functionality is very useful in tracking planar surfaces in images and
in the calibration of perspective cameras.  Currently, only linear
algorithms are available for finding the homography that best fits the
mapping between two sets of corresponding points or two sets of
corresponding lines.  It is planned to add
non-linear compute methods, such as Levenberg-Marquardt.
</p>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC90" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="book_9.html#SEC102" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated on <i>May, 1 2013</i> using <a href="http://texi2html.cvshome.org/"><i>texi2html 1.76</i></a>.
 </font>
 <br>

</p>
</body>
</html>
