<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on May, 1 2013 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>VXL: 11. vidl: Video Streaming</title>

<meta name="description" content="VXL: 11. vidl: Video Streaming">
<meta name="keywords" content="VXL: 11. vidl: Video Streaming">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="vidl"></a>
<a name="SEC136"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="book_10.html#SEC135" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC137" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book_10.html#SEC112" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 11. vidl: Video Streaming </h1>


  <blockquote><p>  <strong>Chapter summary</strong>:
<code>vidl</code> is a library for managing video streams.
</p>
<p>The purpose of this library is to provide a unified interface for
reading and writing video data in VXL. 
Unlike the previous vidl library, this library treats 
video as a data stream.  
The input streams are derived from <code>vidl_istream</code> and can 
provide data from disk or from a live capture (a camera, for example).
The output streams are derived from <code>vidl_ostream</code> 
and can write data to disk.
Potentially, output streams could also display on a screen
or transmit an internet video stream, but these capabilities
are not implemented yet.
  </p></blockquote>

<hr size="6">
<a name="SEC137"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC136" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.1 Introduction </h2>

<p>An example of simple, compact video transcoding with 
<code>vidl</code> is given below.
</p><table><tr><td>&nbsp;</td><td><pre class="example">#include &lt;vidl/vidl_image_list_istream.h&gt;
#include &lt;vidl/vidl_ffmpeg_ostream.h&gt;

...

  // create an input stream
  vidl_image_list_istream my_istream(&quot;*.png&quot;);

  // create an output stream
  vidl_ffmpeg_ostream my_ostream(&quot;video.avi&quot;,
      vidl_ffmpeg_ostream_params()
          .encoder( vidl_ffmpeg_ostream_params::DVVIDEO )
          .frame_rate( 29.95 ) );

  // transcode the video
  vidl_frame_sptr frame;
  while (bool(frame = my_istream.read_frame()) &amp;&amp;
         my_ostream.write_frame(frame) );
</pre></td></tr></table><p>This example has three parts:
open an input stream, open an output stream, and
transfer the data.
The streams are opened by constructing a stream instance.
The constructor arguments are different for each stream type.
</p>
<p>In the example, the <code>vidl_image_list_istream</code> is 
constructed with a file glob string (See <code>vul_file_iterator</code>
for details).
The input video will consist all PNG files in the current directory
sorted alphanumerically by file name.
The images should all have the same size because the output
format requires this.
</p>
<p>The <code>vidl_ffmpeg_ostream</code> is constructed with
the name of the output video file and a parameters class
that specifies all the encoding parameters.
The <code>vidl_ffmpeg_ostream_params</code> class uses a
design that allows the parameters to be set on an 
anonymous instance by chaining together function calls
that each return a reference to the instance to the next function.
Here the encoder <code>enum</code> is set to <code>DVVIDEO</code> and
the frame rate is set to 29.95 frames per second.
All other parameters take default values.
</p>
<p>In the transcoding loop, all frames are read from the
input stream one at a time. 
Each frame is written to the output stream until an invalid
frame is detected indicating the end of the input stream.
All of this processing is done within the loop condition test,
and the body of the loop is empty 
(there are, of course, several other ways to structure this code).
The <code>read_frame()</code> member function advances to the
next frame in the input sequence and then returns that frame.
It returns a null smart pointer when no more frames are available.
The cast to <code>bool</code> causes the loop to terminate when
the end of input is reached (i.e. a null pointer evaluates to false).
Because of lazy evaluation, <code>write_frame()</code> is only 
called on the output stream when the frame is valid.
This member function writes the frame to the output and
returns true on a successful write.
Thus, a failed write will also terminate the loop.
The streams are closed when the stream instances go out
of scope and are destroyed.
</p>
<hr size="6">
<a name="SEC138"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC137" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC137" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.1.1 Comparison with Previous Video Library </h3>
<p>This design has the following advantages over the old VXL video 
library (now called <code>vidl1</code>) that treated videos as container objects.
</p><ul>
<li> Better support for large video files
</li><li> Better support for encoding options
</li><li> Support for live video streams
</li><li> Better integration with vil
</li></ul>


<a name="SEC139"></a>
<h3 class="subheading"> Streams vs. Codecs </h3>

<p>Various stream subclasses are used to interface with different types 
of video streams. 
Note that these are no longer called <em>codecs</em>. 
The codec in the old <code>vidl1</code> library was somewhat of a misnomer. 
A codec (COder/DECoder) provides encoding and decoding algorithms for
a specific video compression format (e.g. MPEG2, DV, H.264, etc.).
<code>vidl</code> (and its predecessor) provided wrappers to other APIs
(like DirectShow and FFMPEG) which may encode or decode with a variety
of codecs. 
Each <code>vidl_istream</code> and <code>vidl_ostream</code> subclass is a wrapper 
for another video API that may or may not provide encoding, and may 
support many different codecs. For example,
<code>vidl_ffmpeg_istream</code> provides a input using the FFMPEG
library. The FFMPEG library can open a large variety of video file
formats (avi, mpeg, etc.) and decode using an even larger variety of
codecs (MPEG2, MPEG4, MJPEG, H.264, Cinepak, etc.).  
</p>
<p>The video stream design also allows for streams that receive images
from live video feeds. 
This could be from a camera, network video feed, or other source. 
Thus, video capture and video transcoding are both accomplished by 
directing an input stream into an output stream.
</p>
<p>Several APIs that <code>vidl</code> interfaces allow for both input
and output.
For these there are both a corresponding <code>vidl_istream</code> and
<code>vidl_ostream</code>.
Other APIs are designed only for one or the other.
For example, video capture APIs (like libdc1394) only provide an
interface for input, so only a <code>vidl_istream</code> is needed.
The separation of input and output was not allowed by the previous 
<code>vidl</code> library design.
</p>

<hr size="6">
<a name="SEC140"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC138" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC141" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.2 Streams </h2>

<p>All <code>vidl</code> input streams are derived from the abstract base
class <code>vidl_istream</code>.
Likewise all output streams are derived from <code>vidl_ostream</code>.
Once a stream is created, all critical operations are controlled by
invoking base class virtual functions.
This polymorphic design allows video processing algorithms
to operate on any combination of input and output streams 
configurable at run time.
</p>
<p>The following subsections give an overview of the input and
output stream base classes followed by an overview of the
different derived stream types.
</p>
<hr size="6">
<a name="SEC141"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC140" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.2.1 Input Streams </h3>

<p>The <code>vidl_istream</code> API defines several methods to access
properties of the stream, control the stream state, and access 
frame data.  
The functionality of most methods is obvious from the name.  
<code>width()</code> and <code>height()</code> return the video resolution in pixels, 
and <code>frame_rate()</code> returns the video frame rate in frames per second.  
Frame rate may not be define in some streams,
like a sequence of image files, and 0 is returned in this case.
<code>format()</code> returns the <code>vidl_pixel_format</code> of the frames.
<code>num_frames()</code> returns a count of the number frames in
a finite length video clip or -1 in a live video stream.
Note that some video files do not store an accurate count of all
video frames.
In this case, <code>num_frames()</code> must scan the entire video to 
count the number of frames.
Accessing the entire video can be costly, so use this function
only when you really need an accurate frame count.
<code>frame_number()</code> returns the current frame number in
the sequence of video frames (starting at 0 for the first frame).
</p>
<p>The method <code>is_open()</code> returns true when a video stream 
has been opened successfully and has not been closed by 
calling <code>close()</code>.
The method <code>is_valid()</code> has a slight different meaning.
A video stream is valid when its frame counter refers to a valid
video frame.
Video streams should open in an <em>invalid</em> state, referring 
to the position <em>before</em> the first valid frame.
When first opened, <code>frame_number()</code> should return 
<code>static_cast&lt;unsigned int&gt;(-1)</code> to indicate the invalid
frame before frame 0.
The stream is also invalid when it advances past the last valid frame.
The <code>advance()</code> method advances the frame counter and may
invalidate the previously release frame, but does not necessarily 
acquire or decode the next frame.
If the advance was successful it returns true.
The <code>current_frame()</code> method returns a smart pointer to 
the current frame, acquiring or decoding it 
the first time this method is called.  
The <code>read_frame()</code> method advances the frame counter
and returns the resulting current frame in one function call.
</p>
<p>Live streams only support advancing through frames 
sequentially, but most other streams allow traversal forward
or backward through the video to find a particular frame.
This operation is called <em>seeking</em>.
If an input stream supports seeking, the method 
<code>is_seekable()</code> will return true.
If supported, the method <code>seek_frame(frame_number)</code> 
will seek forward or backward to set the current frame 
number to <code>frame_number</code>.
Keep in mind that, even when supported, seeking is almost
always much slower than advancing.
For some video decoders it may even be error prone.
Try to avoid seeking when possible. 
</p>
<a name="SEC142"></a>
<h3 class="subheading"> Input Stream Types </h3>
<p>At the time of this writing, the following input stream classes 
have been implemented.
</p>
<dl compact="compact">
<dt> <code>vidl_image_list_istream</code></dt>
<dd><p>Treats an ordered list of image file paths as a video stream. 
</p></dd>
<dt> <code>vidl_ffmpeg_istream</code></dt>
<dd><p>Uses the <a href="http://ffmpeg.mplayerhq.hu/">FFMPEG</a> library to 
decode many common video file formats.
</p></dd>
<dt> <code>vidl_v4l_istream</code></dt>
<dd><p>Use a video for Linux input stream.
</p></dd>
<dt> <code>vidl_dshow_live_istream</code> </dt>
<dd><p>Use the DirectShow API to stream video directly from camera and 
frame-grabber devices in Windows using native Windows codecs.
</p></dd>
<dt> <code>vidl_dshow_file_istream</code> </dt>
<dd><p>Use the DirectShow API to encode video files in Windows using 
native Windows codecs
</p></dd>
<dt> <code>vidl_dc1394_istream</code></dt>
<dd><p>Use libdc1394 v2 to stream video directly from IEEE 1394 (firewire) 
based cameras (Windows not supported yet)
</p></dd>
</dl>


<hr size="6">
<a name="SEC143"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC141" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.2.2 Output Streams </h3>

<p>The interface for output streams is much simpler than for input
streams.
Once an output video stream is open, its sole job is to accept
frames and append them to the output video.
The key method is <code>write_frame(frame)</code> which takes a 
frame smart pointer and 
tries to write it to the end of the output stream.
It returns true if successful.
The other methods are <code>is_open()</code> which returns true
if the stream is open for writing, and <code>close()</code>
which closes the stream.
</p>
<p>The most complicated part of using output streams is 
typically their construction.
The constructors for output streams differ depending on
the particular stream type, but tend to involve many 
parameters especially when video encoding and compression
are involved. 
When the number of parameters is very large,
a special parameters struct may be used to encapsulate the
parameter collection.
For example, <code>vidl_ffmpeg_ostream_params</code>.
</p>
<a name="SEC144"></a>
<h3 class="subheading"> Output Stream Types </h3>
<p>At the time of this writing, the following output stream classes 
have been implemented.
</p>
<dl compact="compact">
<dt> <code>vidl_image_list_ostream</code> </dt>
<dd><p>Writes a video to disk as a sequence of numbered image files using 
any image file format supported by vil.
</p></dd>
<dt> <code>vidl_ffmpeg_ostream</code> </dt>
<dd><p>Uses the <a href="http://ffmpeg.mplayerhq.hu/">FFMPEG</a> libraries to 
encode to many common video file formats with many encoding options 
for video quality and compression.
</p></dd>
</dl>


<hr size="6">
<a name="SEC145"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC143" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC146" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.2.3 Image List Streams </h3>

<p>The image list streams are the simplest streams in <code>vidl</code>.
They require no third party libraries and rely only on <code>vil</code>.
The <code>vidl_image_list_istream</code> treats a vector of paths
to image files as a video (with unknown frame rate).
The stream is constructed with a vector of paths or a file glob
string that is used to match files on disk and produce a vector
of paths in alphanumeric order.
When the stream is &quot;opened&quot;, each file path is tested to see if
<code>vil</code> can open it as an image (image data is not read yet).
The first frame defines the video resolution.
Any frame that does not open in <code>vil</code> as a <code>vidl</code>
compatible format or does not match the video resolution is 
ignored.
</p>
<p>The <code>vidl_image_list_ostream</code> works in the opposite way.
Opening a stream requires an output directory, a name format,
a file format, and an initial index.
For each frame that is written to the stream, <code>vil</code> is used
to write an image file to the specified directory in the specified 
image file format.
The name of the files is produced by applying the frame number,
starting at the specified initial index, to the name format 
using <code>printf</code> syntax.
For example
</p><table><tr><td>&nbsp;</td><td><pre class="example">vidl_image_list_ostream my_ostream(&quot;video&quot;,&quot;frame%03d&quot;,&quot;tiff&quot;,7);
</pre></td></tr></table><p>will write TIFF images with the following paths
</p><table><tr><td>&nbsp;</td><td><pre class="example">video/frame007.tiff
video/frame008.tiff
video/frame009.tiff
video/frame010.tiff
...
</pre></td></tr></table>
<hr size="6">
<a name="SEC146"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC145" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC147" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.2.4 FFMPEG Streams </h3>

<p><a href="http://ffmpeg.mplayerhq.hu/">FFMPEG</a> is a collection of 
cross-platform, open source, C libraries for encoding and 
decoding video.
It is primarily used on Linux and Mac OS X, but it can be compiled
for Windows too.
It requires GCC and will not compile with Microsoft's compiler.
The primary libraries are libavcodec and libavformat.
Newer versions of FFMPEG also use libavutil and libswscale.
For several years prior to the version 0.5 release, FFMPEG
evolved continually with an ever-changing API 
but no formal releases.
<code>vidl</code> has tried to support several &quot;versions&quot; of the
API by supplying multiple stream implementations.
The selection of implementation and its interface 
with FFMPEG is encapsulated and hidden
from the public <code>vidl</code> stream interfaces.
Going forward, <code>vidl</code> will try to support any official 
release versions of FFMPEG.
If official release versions continue to be few and far between,
a subversion snapshot of FFMPEG may also be supported
and updated only when the need arises for new features.
In the future, a version of FFMPEG may also be added to 
<code>v3p</code> to make a common version easily accessible 
to all VXL users.
</p>
<p>Using the <code>vidl_ffmpeg_istream</code> is trivial.
The constructor only requires the path to a video file.
FFMPEG can decode almost any video file format with
any video codec that is thrown at it.
Be warned that some malformed files will still open
but may produce errors during seeking.
</p>
<p>Using the <code>vidl_ffmpeg_ostream</code> is also 
straightforward.
The constructor requires the path to the output 
video file and a <code>vidl_ffmpeg_ostream_params</code>
struct to specify the encoding parameters.
The <code>vidl_ffmpeg_ostream_params</code> is a struct that
mirrors the enormous set of parameters available to
FFMPEG for encoding.
The current set of parameters is not complete an will
need to be updated in the future.
Leaving most of the parameters at their default value
will produce reasonable results in most cases.
The most important parameters to set are
encoder, frame rate, and bit rate.
The encoder is the selection of codec to use from those
supported by FFMPEG.
An <code>enum</code> specifies a list of codecs allowed by 
<code>vidl</code>.
This list needs to be expanded and should ultimately 
vary depending on the FFMPEG configuration since some
codecs are optionally enabled during FFMPEG compilation. 
The frame rate is a <code>double</code> specifying the number 
of frames per second in the output video.
The bit rate is an <code>unsigned int</code> specifying the 
target compression level in number of bits per second
of video.
Another set of important parameters is the frame size,
the width (<code>ni</code>) and height (<code>nj</code>) of each image.
However, <code>vidl_ffmpeg_ostream</code> does not require 
that you specify the frame size directly.
Instead, it uses a delayed stream opening scheme.
The constructor stores the parameters but does not 
immediately open the stream.
When the first frame is written, the size of this frame
is used to specify the size of the output video and
the output stream is opened at this point.
If necessary, one can force the stream to open without
writing a frame by calling the <code>open()</code> method on 
the stream.
</p> 

<hr size="6">
<a name="SEC147"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC146" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC148" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.2.5 DirectShow Streams </h3>

<p><em>Not written yet.</em>
</p>
<hr size="6">
<a name="SEC148"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC147" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC149" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.2.6 1394 (Firewire) Camera Streams </h3>

<p>There are several cameras that capture and transmit video over
the 1394 (aka Firewire) interface.
Many of these cameras conform to a standard of camera 
configuration and streaming parameters.
This standard is known as the IIDC or DCAM Specifications.
Note that this refers to live capture 1394 cameras and 
does not generally include camcorders that transfer
saved video using the 1394 interface.
</p>
<p>There are several driver packages that implement the
IIDC Specifications.
<code>vidl</code> supports an open source package called 
<a href="http://damien.douxchamps.net/ieee1394/libdc1394/">libdc1394</a>.
The <code>vidl_dc1394_istream</code> uses the libdc1394 version 2
API to capture live video from 1394 cameras.
libdc1394 currently runs on linux and Mac OS X.
It may also run on Windows in the future.
Other examples of IIDC camera APIs are the
<a href="http://www.cs.cmu.edu/~iwan/1394/">CMU 1394 Driver</a>
for Windows and the Point Grey 
<a href="http://www.ptgrey.com/products/pgrflycapture/index.asp">FlyCapture SDK</a>
for Windows.
Point Grey adds additional features beyond the standard
for its own line of cameras.
Separate <code>vidl_istream</code> classes could be written for
these in the future.
</p>
<p>This <code>vidl_dc1394_istream</code> is opened with a parameters
 struct called <code>vidl_iidc1394_params</code> that specifies 
all the IIDC parameters needed to configure the camera.
Since the parameters are standard and not specific to libdc1394,
the <code>vidl_iidc1394_params</code> struct is intended to be 
shared with any other IIDC 1394 stream classes written in the future.
Additional parameters that are specific to libdc1394 are
kept out of <code>vidl_iidc1394_params</code>.
Namely, the <code>num_dma_buffers</code> parameter is passed in
separately when opening the stream.
This parameter specifies the number of frame buffers to use
for Direct Memory Access (DMA) transfer.
libdc1394 will create a separate thread to continually read
frames into these buffers asynchronously from the main
program.
Refer to the libdc1394 documentation for details.
</p>
<p>The <code>vidl_iidc1394_params</code> struct also contains a
nested struct called <code>valid_options</code>.
This struct is used to represent the available devices
and their parameters found by probing the 1394 bus.
The <code>vidl_dc1394_istream</code> class has a static
member function called <code>valid_params</code> that
can be used to probe the bus and populate this struct.
</p>  

<hr size="6">
<a name="SEC149"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC148" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC150" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.2.7 Video 4 Linux Streams </h3>

<p><em>Not written yet.</em>
</p>

<hr size="6">
<a name="SEC150"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC149" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC151" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.3 Video Frames </h2>

<p>The <code>vidl_frame_sptr</code> is a data structure used to transport video
frame data from a <code>vidl_istream</code> to a <code>vidl_ostream</code>. 
The <code>vidl_frame</code> contains a pointer to the frame buffer, 
the image resolution, the pixel format, and may eventually contain 
a time stamp. 
A <code>vidl_frame</code> is more restrictive than a <code>vil_image_view</code> 
since it requires contiguous memory and is limited in pixel data types. 
However, it also handles many pixels formats not supported by 
<code>vil</code>, such as those with sub-sampled chrominance 
(i.e. YUV 4:2:2).
</p>
<p>In some cases the <code>vidl_frame</code> data can be wrapped by a
<code>vil_image_view</code>, but usually this is not a good idea. 
The <code>vidl_frame</code> should be considered a volatile data structure. 
The image buffer is only guaranteed to be valid until the next call of
<code>vidl_istream::advance()</code>. 
The istream will keep a pointer to the released frame and then 
invalidate it before reusing memory. 
Use the functions in <code>vidl_convert.h</code> to obtain a non-volatile
<code>vil_image_view</code>.
More details are given below in the section on conversions.
</p>
<hr size="6">
<a name="SEC151"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC150" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC152" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.4 Pixel Formats </h2>

<p>The supported pixel formats are enumerated in
<code>vidl_pixel_format</code> enum.  
The naming convention is <code>VIDL_PIXEL_FORMAT_color_num[P]</code>, 
where <em>color</em> is the color encoding,
 <em>num</em> is the bit number, 
and the <code>P</code> character is optionally appended to indicate 
a planar encoding.  
There are also two special formats.  
<code>VIDL_PIXEL_FORMAT_UNKNOWN</code> is used when
the pixel format is not known or does not matter.
<code>VIDL_PIXEL_FORMAT_ENUM_END</code> is an end of enum marker and
should never be used in a <code>vidl_frame</code>.  
This marker is used to count the number of pixel formats.
All new formats should be added before the end marker in the enum.
</p>
<p>The <em>color</em> of a pixel format specifies the color encoding.  
A separate enum named <code>vidl_pixel_color</code> enumerates the 
available color modes.  
These are
</p><dl compact="compact">
<dt> <code>VIDL_PIXEL_COLOR_MONO</code></dt>
<dd><p>Monochrome or grayscale (1 color channel)
</p></dd>
<dt> <code>VIDL_PIXEL_COLOR_RGB</code></dt>
<dd><p>Red Green Blue (3 color channels)
</p></dd>
<dt> <code>VIDL_PIXEL_COLOR_RGBA</code></dt>
<dd><p>Red Green Blue Alpha (4 color channels)
</p></dd>
<dt> <code>VIDL_PIXEL_COLOR_YUV</code></dt>
<dd><p>Luma Chroma-Blue Chroma-Red, aka YCrCb (3 color channels)
</p></dd>
</dl>
<p>The multichannel color formats are not always encoded in the order
given above.  
The characters are permuted in the <code>vidl_pixel_format</code> 
names to indicate the actual ordering.  
For example, <code>BGR</code> indicates RGB color stored in reverse order.
</p>
<p>The <em>bit number</em> indicates how the bits are laid out.  
This is most important in packed color frames where a group 
of 2 or 4 pixels is encoded together and differing numbers of bits are 
added to different color channels.  
When no packing occurs, the number in the <code>vidl_pixel_format</code> 
name is the total number of bits
(i.e. <code>RGB_24</code> is RGB with 8 bits for each channel).  
When the number of bits per channel is different, the standard 
chroma sub-sampling numbering is used (i.e. <code>422</code> for 4:2:2).  
See 
<a href="http://en.wikipedia.org/wiki/Chroma_subsampling">Wikipedia</a> 
for more details. 
A separate enum named <code>vidl_pixel_arrangement</code>
enumerates the available arrangements.  
These are
</p><dl compact="compact">
<dt> <code>VIDL_PIXEL_ARRANGE_SINGLE</code></dt>
<dd><p>Each pixel is listed in single file with equal bit allocation to each
channel (e.g. RGBRGBRGBRGBRGB...)
</p></dd>
<dt> <code>VIDL_PIXEL_ARRANGE_PACKED</code></dt>
<dd><p>Small blocks of data represent a group of pixels and bit allocation
generally differs between channels
</p></dd>
<dt> <code>VIDL_PIXEL_ARRANGE_PLANAR</code></dt>
<dd><p>All data from one channel is provided before providing all data from
the next channel (e.g. RRRR... GGGG... BBBB...).  
Chroma sub-sampling may still apply.
</p></dd>
<dt> <code>VIDL_PIXEL_ARRANGE_PALETTE</code></dt>
<dd><p>(Not currently used) 
Each pixel is an index into a look-up table of colors.
</p></dd>
</dl>


<hr size="6">
<a name="SEC152"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC151" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC153" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC151" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.4.1 The Pixel Traits Table </h3>

<p>To determine properties of each pixel type, <code>vidl</code> relies
heavily on template specialization and meta-programming.  
The template <code>vidl_pixel_traits_of&lt;FMT&gt;</code> is specialized for 
each pixel format <code>FMT</code>.  
The traits class provides several static members that describe the 
properties of each format.  
The trait specializations are created using the macro <code>vidl_pt_mac</code>.  
This macro lets all the properties appear in a nice table.  
It also makes it easy to add a new pixel format.
</p>
<p>The following is a subset of the pixel traits table found in
<code>vidl_pixel_format.h</code>.
</p><table><tr><td>&nbsp;</td><td><pre class="example">//            format    name        type       bpp color    arrange xcs ycs
//            ------    ---------   ----       --- -------  ------- --- ---
vidl_pt_mac( UNKNOWN,  &quot;unknown&quot;,  void,       0, UNKNOWN, UNKNOWN, 0, 0 );

vidl_pt_mac( RGB_24,   &quot;RGB 24&quot;,   vxl_byte,   24, RGB,    SINGLE,  0, 0 );
vidl_pt_mac( RGB_24P,  &quot;RGB 24P&quot;,  vxl_byte,   24, RGB,    PLANAR,  0, 0 );
vidl_pt_mac( BGR_24,   &quot;BGR 24&quot;,   vxl_byte,   24, RGB,    SINGLE,  0, 0 );
vidl_pt_mac( RGBA_32,  &quot;RGBA 32&quot;,  vxl_byte,   32, RGBA,   SINGLE,  0, 0 );
vidl_pt_mac( YUV_444P, &quot;YUV 444P&quot;, vxl_byte,   24, YUV,    PLANAR,  0, 0 );
vidl_pt_mac( YUV_422P, &quot;YUV 422P&quot;, vxl_byte,   16, YUV,    PLANAR,  1, 0 );
vidl_pt_mac( YUV_420P, &quot;YUV 420P&quot;, vxl_byte,   12, YUV,    PLANAR,  1, 1 );
vidl_pt_mac( YUV_410P, &quot;YUV 410P&quot;, vxl_byte,   10, YUV,    PLANAR,  2, 1 );
vidl_pt_mac( YUYV_422, &quot;YUYV 422&quot;, vxl_byte,   16, YUV,    PACKED,  1, 0 );
vidl_pt_mac( MONO_1,   &quot;Mono 1&quot;,   bool,       1,  MONO,   SINGLE,  0, 0 );
vidl_pt_mac( MONO_8,   &quot;Mono 8&quot;,   vxl_byte,   8,  MONO,   SINGLE,  0, 0 );
vidl_pt_mac( MONO_16,  &quot;Mono 16&quot;, vxl_uint_16, 16, MONO,   SINGLE,  0, 0 );
</pre></td></tr></table>
<p>The meaning of each column in the pixel traits table are as follows.
</p><dl compact="compact">
<dt> <code>format</code></dt>
<dd><p>The format identifier symbol.  
Appended to <code>VIDL_PIXEL_FORMAT_</code>,
this should match the <code>vidl_pixel_format</code> enum value.
</p></dd>
<dt> <code>name</code></dt>
<dd><p>The string name of the format for human readability.
</p></dd>
<dt> <code>type</code></dt>
<dd><p>The data type to be used when converting to a <code>vil_image_view</code>.
</p></dd>
<dt> <code>bpp</code></dt>
<dd><p>The number of bits per pixel. 
Not always an even multiple of <code>sizeof(type)</code> because pixels 
may be packed or sub-sampled in some planes 
(see <code>xcs</code> and <code>ycs</code>).
</p></dd>
<dt> <code>color</code></dt>
<dd><p>The color format.  Appended to <code>VIDL_PIXEL_COLOR_</code> this
determines the <code>vidl_pixel_color</code>.
</p></dd>
<dt> <code>arrange</code></dt>
<dd><p>The pixel arrangement.  Appended to <code>VIDL_PIXEL_ARRANGE_</code> 
this determines the <code>vidl_pixel_arrangement</code>.
</p></dd>
<dt> <code>xcs</code></dt>
<dd><p>The X color sub-sampling factor.  In YUV color space, the U and V
channels have a horizontal resolution (<code>ni</code>) that is 
<SPAN CLASS="MATH"><IMG
 WIDTH="66" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="book_22.png"
 ALT="$2^@{-xcs@}$"></SPAN>  times that of the Y channel.
</p></dd>
<dt> <code>ycs</code></dt>
<dd><p>The Y color sub-sampling factor.  In YUV color space, the U and V
channels have a vertical resolution (<code>nj</code>) that is 
<SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="book_23.png"
 ALT="$2^@{-ycs@}$"></SPAN>  times that of the Y channel.
</p></dd>
</dl>

<p>A new pixel format may be introduced by simply adding an entry in this
table and a corresponding <code>enum</code> addition to 
<code>vidl_pixel_format</code>. 
The traits of a pixel format are used in the automatic generation of 
conversion routines.  
The ultimate goal of the <code>vidl</code> pixel format framework is that 
new formats added to the table should automatically work (possibly slowly) 
without writing any additional conversion routines.
</p>

<hr size="6">
<a name="SEC153"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC152" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC154" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC151" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.4.2 Run-time Pixel Traits </h3>

<p>The template specializations used to define traits are very useful at
compile-time, but less useful given a pixel format that is not known
until run-time.  
A second (non-templated) struct named <code>vidl_pixel_traits</code> 
is available to dynamically hold traits at run-time.  
The function <code>vidl_pixel_format_traits</code> provides
dynamic look-up of traits from a <code>vidl_pixel_format</code> variable.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">// find the pixel format of a frame
vidl_pixel_format format = my_frame_sptr-&gt;pixel_format();

// look up the pixel traits
vidl_pixel_traits pt = vidl_pixel_format_traits(format);

// print out some information
vcl_cout &lt;&lt; &quot;The frame has format &quot; &lt;&lt; pt.name
         &lt;&lt; &quot; with &quot; &lt;&lt; pt.bits_per_pixels &lt;&lt; &quot; bits per pixel&quot;
         &lt;&lt; &quot; and &quot; &lt;&lt; pt.num_channels &lt;&lt; &quot; channels&quot; &lt;&lt; vcl_endl;
</pre></td></tr></table>
<p>To simplify this process there are several convenience functions, such
as <code>vidl_pixel_format_bpp</code>, to directly look up a pixel trait
given the format without the need for the traits struct. 
There is also a <code>vcl_ostream</code> operator for <code>vidl_pixel_format</code> 
so that the human readable string name is printed.  
The following example
</p><table><tr><td>&nbsp;</td><td><pre class="example">vidl_pixel_format format = VIDL_PIXEL_FORMAT_RGB_24;
vcl_cout &lt;&lt; &quot;pixel format is &quot; &lt;&lt; format &lt;&lt; vcl_endl;
</pre></td></tr></table><p>produces the output
</p><table><tr><td>&nbsp;</td><td><pre class="example">pixel format is RGB 24
</pre></td></tr></table>
<p>There is also a function that provides a look up of a pixel format
from its string name.  
Use <code>vidl_pixel_format_from_string</code> for this purpose.  
The expression
</p><table><tr><td>&nbsp;</td><td><pre class="example">vidl_pixel_format_from_string(&quot;RGB 24&quot;) == VIDL_PIXEL_FORMAT_RGB_24
</pre></td></tr></table><p>should evaluate to true.
</p>
<hr size="6">
<a name="SEC154"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC153" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC155" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 11.5 Pixel Format Conversion </h2>

<p>When passing a frame from an input stream to an output stream,
pixel format conversion is generally not something the user needs 
to worry about.
The <code>vidl_istream</code> should provide a <code>vidl_frame_sptr</code>
that uses whatever pixel format is native to the video data.
If the <code>vidl_ostream</code> requires a different pixel format,
then it performs the required conversion automatically.
</p>
<p>If for some reason manual conversion is required, the appropriate
functions are found in <code>vidl_convert.h</code>.
The function is called <code>vidl_convert_frame</code>, 
and it comes in two forms.
The first
</p><table><tr><td>&nbsp;</td><td><pre class="example">bool vidl_convert_frame(const vidl_frame&amp; in_frame,
                               vidl_frame&amp; out_frame);
</pre></td></tr></table><p>takes an input frame and an output frame. 
The output frame must have the appropriate size and pixel format
for the output.
If the size is not appropriate then the function returns false.
This version is useful when you want to store the converted data 
into an existing memory buffer; 
for example, reusing the same output frame for each new input frame.
The second form of the function
</p><table><tr><td>&nbsp;</td><td><pre class="example">vidl_frame_sptr vidl_convert_frame(const vidl_frame_sptr&amp; in_frame,
                                     vidl_pixel_format format);
</pre></td></tr></table><p>takes a smart pointer to an input frame and allocates new memory
for the output frame using the specified pixel format.
If the conversion is possible, a smart pointer to the new frame
is returned.
Otherwise, a null smart pointer is returned. 
This version requires less preparation by the user, 
but does not allow for the reuse of frame memory.
</p>
<hr size="6">
<a name="SEC155"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC154" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC156" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC154" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.5.1 Conversion Between Frames and Image Views </h3>

<p>One case where the user usually does want to convert a frame
is conversion to and from a <code>vil_image_view</code>.
This type of conversion is needed to do any image processing
on the data.
There is more than one way to do such a conversion.
The fastest way, if possible, is to share the memory and 
wrap the <code>vidl_frame</code> in a <code>vil_image_view</code> or vice versa.
Wrapping is only possible when the memory layout of the <code>vil</code>
memory format is compatible with a <code>vidl</code> pixel format.
</p>
<p>For writing to output streams, wrapping is usually safe
because the data is immediately used and then no longer needed.
The function <code>vidl_convert_to_frame</code> takes a 
<code>vil_image_view_base_sptr</code> and always tries first to wrap 
the memory. 
If wrapping fails, new memory is allocated and the image data is
copied (and converted if necessary) into that memory.
The result is returned as a <code>vidl_frame_sptr</code>.
</p>
<p>When reading frames from video, wrapping can be more dangerous.
Processing images from video often involves multiple frames.
To reduce repeated reallocation of memory, most input streams 
will reuse the same memory.
A member function on the <code>vidl_frame</code> allows an input
stream to <em>invalidate</em> the frame object it previously
released in order to reclaim the memory for the next frame.
The invalidated frame will now have a null pointer to image data,
but any <code>vil_image_view</code> that was sharing the memory
will not be notified.
The image sharing the memory will be overwritten when the next 
frame is read from the video stream.
It is safer to copy memory when converting a frame to an image,
but it is potentially much slower than wrapping.
Functions are provided for both copy conversion and 
wrapping conversion.
The appropriate conversion depends on the situation.
</p>
<p>When in doubt, the safest way to get a <code>vil_image_view</code>
from a <code>vidl_frame</code> is by copying with
</p><table><tr><td>&nbsp;</td><td><pre class="example">bool vidl_convert_to_view(const vidl_frame&amp; frame,
                           vil_image_view_base&amp; image,
                           vidl_pixel_color require_color);
</pre></td></tr></table><p>This function resizes the image (if necessary) and then copies
the frame data into it with the appropriate conversion (if necessary).
The conversion is based on the data type of the image view.
The last function argument, <code>require_color</code>, is optional and
defaults to <code>VIDL_PIXEL_COLOR_UNKNOWN</code>.
In the default case, the color encoding is kept the same as
the input frame.
If <code>require_color</code> is specified, then it will be used as the
resulting color encoding.
Videos are often stored and transmitted in YUV, but <code>vil</code>
images are usually assumed to be in RGB.
The <code>require_color</code> is used to force that conversion.
<code>vidl_convert_to_view</code> will return true if the conversion
is successful.
</p>
<p>The fastest way to obtain a <code>vil_image_view</code> is by wrapping.
The function <code>vidl_convert_wrap_in_view</code> takes a 
<code>vidl_frame</code> and tries to wrap its memory with an 
appropriate image view.
If the wrapping is possible, the function returns a 
<code>vil_image_view_base_sptr</code> to the view.
Otherwise, it returns a null smart pointer.
</p>
<hr size="6">
<a name="SEC156"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC155" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC154" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 11.5.2 Adding Optimized Conversion Routines </h3>

<p>The pixel traits table is used to automatically generate conversion
routines between any pair of listed pixel formats.
There are two types of automatically generated conversion
functions.
The first, and simplest, is applied when the input pixel
format matches the output pixel format.
In this case, no conversion is needed so the frame data
is copied directly to the output with <code>vcl_memcpy</code>.
The second, and most general, is applied when the pixel
formats do not match and an actual conversion is needed.
In this case, the function uses a <code>vidl_pixel_iterator</code>
for the input and output frames to step through 
each pixel and convert it.
A <code>vidl_pixel_iterator</code> uses virtual functions to 
provide a standard interface for accessing or setting the pixel 
data as an array of bytes, even when multiple pixels are packed 
together.  
The data at each pixel is also passed through a color conversion
function to convert the pixel data type and color representation
when necessary.
</p>
<p>It is obvious that this generic conversion process is not optimal.
For each pixel, multiple virtual functions are called, and the
pixel data is copied through multiple intermediate variables.
Pixel iterators introduce additional overhead in packed formats
where data shared across pixels is accessed multiple times.
Since fast pixel format conversions are required in many 
applications, the generic routine is not acceptable.
Unfortunately, it is intractable to write an optimized conversion
routine for all pairs of pixel formats.
That would require hundreds of specialized functions.
Yet, not every conversion combination needs optimal performance.
Only a small subset of conversions are commonly used in 
practice. 
<code>vidl</code> allows the default, generic conversion routine
to be overridden by an optimized implementation for the
most common format pairs.
</p>
<p>Optimized conversion routines are added by creating a template
specialization within the designated area in
<code>vidl_convert.cxx</code>.
The specialization should follow the example below. 
</p><table><tr><td>&nbsp;</td><td><pre class="example">VCL_DEFINE_SPECIALIZATION
struct convert&lt;IN_FMT, OUT_FMT&gt;
{
  enum { defined = true };
  static bool apply(const vidl_frame&amp; in_frame,
                          vidl_frame&amp; out_frame)
  {
    assert(in_frame.pixel_format()==IN_FMT);
    assert(out_frame.pixel_format()==OUT_FMT);

    // convert the data here
 
    return true;
  }
};
</pre></td></tr></table><p>In this example, <code>IN_FMT</code> should be replaced by the
input pixel format <code>enum</code> value
(e.g. <code>VIDL_PIXEL_FORMAT_RGB_24</code>).
Likewise, <code>OUT_FMT</code> should be replaced with the 
output pixel format <code>enum</code> value.
Several optimized conversion routines are already provided.
The existing functions can be used as an example when
adding new optimizations.
</p>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC136" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="book_12.html#SEC157" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="book.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[<a href="book_20.html#SEC255" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="book_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated on <i>May, 1 2013</i> using <a href="http://texi2html.cvshome.org/"><i>texi2html 1.76</i></a>.
 </font>
 <br>

</p>
</body>
</html>
