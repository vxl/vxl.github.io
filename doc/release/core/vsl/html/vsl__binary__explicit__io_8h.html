<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>core/vsl/vsl_binary_explicit_io.h File Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">core/vsl/vsl_binary_explicit_io.h File Reference</div>  </div>
</div>
<div class="contents">

<p>Byte-swapping, arbitrary length integer conversion, and explicit I/O.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vxl_config.h&gt;</code><br/>
<code>#include &lt;vcl_cassert.h&gt;</code><br/>
<code>#include &lt;vcl_cstring.h&gt;</code><br/>
<code>#include &lt;vcl_cstddef.h&gt;</code><br/>
<code>#include &lt;vcl_iostream.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="vsl__binary__io_8h_source.html">vsl_binary_io.h</a>&quot;</code><br/>
</div>
<p><a href="vsl__binary__explicit__io_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a1dfd7962bb4c1217630d78989436e6c6">VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH</a>(size_of_type)&#160;&#160;&#160;(((size_of_type * 8)/7) + ((((size_of_type * 8) % 7) == 0) ? 0: 1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of buffer to use with arbitrary length integers.  <a href="#a1dfd7962bb4c1217630d78989436e6c6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#ad15eab05c6917478b2c90a09245078a9">vsl_swap_bytes</a> (char *ptr, unsigned nbyte, vcl_size_t nelem=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform byte swapping in situ.  <a href="#ad15eab05c6917478b2c90a09245078a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a2926a75ece0b6f557a7b2a0f74a12df6">vsl_swap_bytes_to_buffer</a> (const char *source, char *dest, unsigned nbyte, vcl_size_t nelem=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform byte swapping to a buffer.  <a href="#a2926a75ece0b6f557a7b2a0f74a12df6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a76f7298f80647b0203b07097225a2335">vsl_convert_to_arbitrary_length_unsigned_impl</a> (const T *ints, unsigned char *buffer, vcl_size_t count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement arbitrary length conversion for unsigned integers.  <a href="#a76f7298f80647b0203b07097225a2335"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a515b5b8ba2948e42bc040e713a4242be">vsl_convert_to_arbitrary_length_signed_impl</a> (const T *ints, unsigned char *buffer, vcl_size_t count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement arbitrary length conversion for signed integers.  <a href="#a515b5b8ba2948e42bc040e713a4242be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a597c3f7e64d2b2c86638b56d2b3ff60e">vsl_convert_from_arbitrary_length_signed_impl</a> (const unsigned char *buffer, T *ints, vcl_size_t count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement arbitrary length conversion for signed integers.  <a href="#a597c3f7e64d2b2c86638b56d2b3ff60e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a03cc4bce73b428a61548539381868646">vsl_convert_from_arbitrary_length_unsigned_impl</a> (const unsigned char *buffer, T *ints, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement arbitrary length conversion for unsigned integers.  <a href="#a03cc4bce73b428a61548539381868646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#aa756220489e32ec428591b4b19b61387">vsl_convert_to_arbitrary_length</a> (const unsigned long *ints, unsigned char *buffer, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an array of ints into an arbitrary length format.  <a href="#aa756220489e32ec428591b4b19b61387"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a3ebd134065ba82762cdc59e8b532ad73">vsl_convert_from_arbitrary_length</a> (const unsigned char *buffer, unsigned long *ints, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a buffer of arbitrary length integers.  <a href="#a3ebd134065ba82762cdc59e8b532ad73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a7968f2e92215875579c473625318c274">vsl_convert_to_arbitrary_length</a> (const long *ints, unsigned char *buffer, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an array of ints into an arbitrary length format.  <a href="#a7968f2e92215875579c473625318c274"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#aa9ef24897af60f8f3bf269c3fb7de24e">vsl_convert_from_arbitrary_length</a> (const unsigned char *buffer, long *ints, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a buffer of arbitrary length integers.  <a href="#aa9ef24897af60f8f3bf269c3fb7de24e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a42aeeaf5ef13e4fcfaba9d42636ab8bc">vsl_convert_to_arbitrary_length</a> (const unsigned int *ints, unsigned char *buffer, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an array of ints into an arbitrary length format.  <a href="#a42aeeaf5ef13e4fcfaba9d42636ab8bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a400bf1d9ba36e100746ed9d059bb00c3">vsl_convert_from_arbitrary_length</a> (const unsigned char *buffer, unsigned int *ints, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a buffer of arbitrary length integers.  <a href="#a400bf1d9ba36e100746ed9d059bb00c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a38efab8cc316135476160ea60455239a">vsl_convert_to_arbitrary_length</a> (const int *ints, unsigned char *buffer, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an array of ints into an arbitrary length format.  <a href="#a38efab8cc316135476160ea60455239a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#aeac7165265df73510889a7782f370b1a">vsl_convert_from_arbitrary_length</a> (const unsigned char *buffer, int *ints, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a buffer of arbitrary length integers.  <a href="#aeac7165265df73510889a7782f370b1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a7f9dcfde2814b8ea5d10c3ca8fe6a7d7">vsl_convert_to_arbitrary_length</a> (const unsigned short *ints, unsigned char *buffer, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an array of ints into an arbitrary length format.  <a href="#a7f9dcfde2814b8ea5d10c3ca8fe6a7d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#aa66f835d97e8f392284c3850fb2d7fda">vsl_convert_from_arbitrary_length</a> (const unsigned char *buffer, unsigned short *ints, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a buffer of arbitrary length integers.  <a href="#aa66f835d97e8f392284c3850fb2d7fda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a32e3690ee9467ffe541b3800169885d1">vsl_convert_to_arbitrary_length</a> (const short *ints, unsigned char *buffer, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an array of ints into an arbitrary length format.  <a href="#a32e3690ee9467ffe541b3800169885d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a7099f9d60b5ab4138c5bb2d5ed94f9bc">vsl_convert_from_arbitrary_length</a> (const unsigned char *buffer, short *ints, vcl_size_t count=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a buffer of arbitrary length integers.  <a href="#a7099f9d60b5ab4138c5bb2d5ed94f9bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#afc98298557fc46751e0912a5d54111f3">vsl_b_write_uint_16</a> (<a class="el" href="classvsl__b__ostream.html">vsl_b_ostream</a> &amp;os, unsigned long n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an unsigned int as 16 bits to <a class="el" href="classvsl__b__ostream.html" title="A binary output adaptor for any vcl_ostream.">vsl_b_ostream</a>.  <a href="#afc98298557fc46751e0912a5d54111f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a204a04d309a9eb8e8fb1f997a191a699">vsl_b_read_uint_16</a> (<a class="el" href="classvsl__b__istream.html">vsl_b_istream</a> &amp;is, unsigned long &amp;n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an unsigned int as 16 bits from <a class="el" href="classvsl__b__istream.html" title="An adaptor for any vcl_istream to make it suitable for binary input.">vsl_b_istream</a>.  <a href="#a204a04d309a9eb8e8fb1f997a191a699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a3bb6f4a34364866877bffbc651e1bdcf">vsl_b_write_int_16</a> (<a class="el" href="classvsl__b__ostream.html">vsl_b_ostream</a> &amp;os, long n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a signed int as 16 bits to <a class="el" href="classvsl__b__ostream.html" title="A binary output adaptor for any vcl_ostream.">vsl_b_ostream</a>.  <a href="#a3bb6f4a34364866877bffbc651e1bdcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#afa9b7e9ae7e67a020f59b30eefff58dd">vsl_b_read_int_16</a> (<a class="el" href="classvsl__b__istream.html">vsl_b_istream</a> &amp;is, long &amp;n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a signed int as 16 bits from <a class="el" href="classvsl__b__istream.html" title="An adaptor for any vcl_istream to make it suitable for binary input.">vsl_b_istream</a>.  <a href="#afa9b7e9ae7e67a020f59b30eefff58dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#aa8a79cd85127b6aa4bcd0323ab76cff4">vsl_b_write_uint_64</a> (<a class="el" href="classvsl__b__ostream.html">vsl_b_ostream</a> &amp;os, vcl_size_t n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a vcl_size_t as 64 bits to <a class="el" href="classvsl__b__ostream.html" title="A binary output adaptor for any vcl_ostream.">vsl_b_ostream</a>.  <a href="#aa8a79cd85127b6aa4bcd0323ab76cff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a67f8f9ba839fbdeb1e1c80d8ba498c12">vsl_b_read_uint_64</a> (<a class="el" href="classvsl__b__istream.html">vsl_b_istream</a> &amp;is, vcl_size_t &amp;n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a vcl_size_t as 64 bits from <a class="el" href="classvsl__b__istream.html" title="An adaptor for any vcl_istream to make it suitable for binary input.">vsl_b_istream</a>.  <a href="#a67f8f9ba839fbdeb1e1c80d8ba498c12"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">There is a problem with the <br class="typebreak"/>
ENDIAN indication&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsl__binary__explicit__io_8h.html#a999f42a0e45ba185867063b3cb628ca7">macros</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Byte-swapping, arbitrary length integer conversion, and explicit I/O. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Ian Scott (Manchester) April 2001</dd></dl>
<p>Include this file if you want to perform integer IO using fixed size encoding.</p>
<p>If you want to read or write a large number of floating points, then;</p>
<ul>
<li>Floats and doubles need byte swapped, and this can be done in situ.</li>
<li>Shorts, ints and longs need converted to/from the arbitrary length format.</li>
</ul>
<dl class="user"><dt><b>Implementation details:</b></dt><dd>The arbitrary length encoding takes the number and breaks it into 7 bit nibbles. Each nibble is saved with the 8th bit set if this is the last byte. The nibbles are stored in little endian order. ie The first byte of the encoded format represents the least significant 7 bits.</dd></dl>
<p>The algorithm used to encode an unsigned value works as follows </p>
<div class="fragment"><pre class="fragment">
    while value is greater than 2^7-1
      emit 0 bit
      emit least significant 7 bits of value.
      shift value right 7 bits
    emit bit 1
    emit value embedded in 7 bits
   </pre></div> 
<p>Definition in file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1dfd7962bb4c1217630d78989436e6c6"></a><!-- doxytag: member="vsl_binary_explicit_io.h::VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH" ref="a1dfd7962bb4c1217630d78989436e6c6" args="(size_of_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size_of_type</td><td>)</td>
          <td>&#160;&#160;&#160;(((size_of_type * 8)/7) + ((((size_of_type * 8) % 7) == 0) ? 0: 1))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum length of buffer to use with arbitrary length integers. </p>
<p>This macro tells you the size of buffer you need when using vsl_convert_ints_to_arbitrary_length(). You should give the macro the size of the type you want to convert. If you are converting several integers at once, multiply the value by the number of integers. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00160">160</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="afa9b7e9ae7e67a020f59b30eefff58dd"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_b_read_int_16" ref="afa9b7e9ae7e67a020f59b30eefff58dd" args="(vsl_b_istream &amp;is, long &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsl_b_read_int_16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvsl__b__istream.html">vsl_b_istream</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a signed int as 16 bits from <a class="el" href="classvsl__b__istream.html" title="An adaptor for any vcl_istream to make it suitable for binary input.">vsl_b_istream</a>. </p>
<p>Warning: This function should be used infrequently and carefully. Under all normal circumstances, the generic vsl_b_read and vsl_b_write in <a class="el" href="vsl__binary__io_8h.html" title="Set of functions, and objects to perform binary IO.">vsl_binary_io.h</a> will be perfectly adequate.</p>
<p>This function will only read values saved using <a class="el" href="vsl__binary__explicit__io_8h.html#a3bb6f4a34364866877bffbc651e1bdcf" title="Write a signed int as 16 bits to vsl_b_ostream.">vsl_b_write_int_16()</a>. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00665">665</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a204a04d309a9eb8e8fb1f997a191a699"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_b_read_uint_16" ref="a204a04d309a9eb8e8fb1f997a191a699" args="(vsl_b_istream &amp;is, unsigned long &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsl_b_read_uint_16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvsl__b__istream.html">vsl_b_istream</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an unsigned int as 16 bits from <a class="el" href="classvsl__b__istream.html" title="An adaptor for any vcl_istream to make it suitable for binary input.">vsl_b_istream</a>. </p>
<p>Warning: This function should be used infrequently and carefully. Under all normal circumstances, the generic vsl_b_read and vsl_b_write in <a class="el" href="vsl__binary__io_8h.html" title="Set of functions, and objects to perform binary IO.">vsl_binary_io.h</a> will be perfectly adequate.</p>
<p>This function will only read values saved using <a class="el" href="vsl__binary__explicit__io_8h.html#afc98298557fc46751e0912a5d54111f3" title="Write an unsigned int as 16 bits to vsl_b_ostream.">vsl_b_write_uint_16()</a>. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00632">632</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67f8f9ba839fbdeb1e1c80d8ba498c12"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_b_read_uint_64" ref="a67f8f9ba839fbdeb1e1c80d8ba498c12" args="(vsl_b_istream &amp;is, vcl_size_t &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsl_b_read_uint_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvsl__b__istream.html">vsl_b_istream</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a vcl_size_t as 64 bits from <a class="el" href="classvsl__b__istream.html" title="An adaptor for any vcl_istream to make it suitable for binary input.">vsl_b_istream</a>. </p>
<p>Warning: This function should be used infrequently and carefully. Under all normal circumstances, the generic vsl_b_read and vsl_b_write in <a class="el" href="vsl__binary__io_8h.html" title="Set of functions, and objects to perform binary IO.">vsl_binary_io.h</a> will be perfectly adequate.</p>
<p>This function will only read values saved using <a class="el" href="vsl__binary__explicit__io_8h.html#aa8a79cd85127b6aa4bcd0323ab76cff4" title="Write a vcl_size_t as 64 bits to vsl_b_ostream.">vsl_b_write_uint_64()</a>. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00705">705</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3bb6f4a34364866877bffbc651e1bdcf"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_b_write_int_16" ref="a3bb6f4a34364866877bffbc651e1bdcf" args="(vsl_b_ostream &amp;os, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsl_b_write_int_16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvsl__b__ostream.html">vsl_b_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a signed int as 16 bits to <a class="el" href="classvsl__b__ostream.html" title="A binary output adaptor for any vcl_ostream.">vsl_b_ostream</a>. </p>
<p>If your signed int cannot be represented in 16 bits (e.g. on a 32 bit platform) the stream's error flag will be set.</p>
<p>Warning: This function should be used infrequently and carefully. Under all normal circumstances, the generic vsl_b_read and vsl_b_write in <a class="el" href="vsl__binary__io_8h.html" title="Set of functions, and objects to perform binary IO.">vsl_binary_io.h</a> will be perfectly adequate.</p>
<p>You must <a class="el" href="vsl__binary__explicit__io_8h.html#afa9b7e9ae7e67a020f59b30eefff58dd" title="Read a signed int as 16 bits from vsl_b_istream.">vsl_b_read_int_16()</a> to read the value saved with this function. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00651">651</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="afc98298557fc46751e0912a5d54111f3"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_b_write_uint_16" ref="afc98298557fc46751e0912a5d54111f3" args="(vsl_b_ostream &amp;os, unsigned long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsl_b_write_uint_16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvsl__b__ostream.html">vsl_b_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an unsigned int as 16 bits to <a class="el" href="classvsl__b__ostream.html" title="A binary output adaptor for any vcl_ostream.">vsl_b_ostream</a>. </p>
<p>If your signed int cannot be represented in 16 bits (e.g. on a 32 bit platform) the stream's error flag will be set.</p>
<p>Warning: This function should be used infrequently and carefully. Under all normal circumstances, the generic vsl_b_read and vsl_b_write in <a class="el" href="vsl__binary__io_8h.html" title="Set of functions, and objects to perform binary IO.">vsl_binary_io.h</a> will be perfectly adequate.</p>
<p>You must use <a class="el" href="vsl__binary__explicit__io_8h.html#a204a04d309a9eb8e8fb1f997a191a699" title="Read an unsigned int as 16 bits from vsl_b_istream.">vsl_b_read_uint_16()</a> to read the value saved with this function. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00618">618</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8a79cd85127b6aa4bcd0323ab76cff4"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_b_write_uint_64" ref="aa8a79cd85127b6aa4bcd0323ab76cff4" args="(vsl_b_ostream &amp;os, vcl_size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsl_b_write_uint_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvsl__b__ostream.html">vsl_b_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a vcl_size_t as 64 bits to <a class="el" href="classvsl__b__ostream.html" title="A binary output adaptor for any vcl_ostream.">vsl_b_ostream</a>. </p>
<p>Will assert if your vcl_size_t cannot be represented in 64 bits (e.g. on some 128 bit platforms).</p>
<p>Warning: This function should be used infrequently and carefully. Under all normal circumstances, the generic vsl_b_read and vsl_b_write in <a class="el" href="vsl__binary__io_8h.html" title="Set of functions, and objects to perform binary IO.">vsl_binary_io.h</a> will be perfectly adequate.</p>
<p>You must use <a class="el" href="vsl__binary__explicit__io_8h.html#a67f8f9ba839fbdeb1e1c80d8ba498c12" title="Read a vcl_size_t as 64 bits from vsl_b_istream.">vsl_b_read_uint_64()</a> to read the value saved with this function. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00691">691</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ebd134065ba82762cdc59e8b532ad73"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_from_arbitrary_length" ref="a3ebd134065ba82762cdc59e8b532ad73" args="(const unsigned char *buffer, unsigned long *ints, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_from_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a buffer of arbitrary length integers. </p>
<p>Converts from the integers from the arbitrary length format into an array of normal longs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>Number of integers expected. Cannot be zero. </td></tr>
    <tr><td class="paramname">ints</td><td>should point to a buffer at least as long as count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes used, or zero on error. </dd></dl>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00323">323</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9ef24897af60f8f3bf269c3fb7de24e"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_from_arbitrary_length" ref="aa9ef24897af60f8f3bf269c3fb7de24e" args="(const unsigned char *buffer, long *ints, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_from_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a buffer of arbitrary length integers. </p>
<p>Converts from the integers from the arbitrary length format into an array of normal longs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>Number of integers expected. Cannot be zero. </td></tr>
    <tr><td class="paramname">ints</td><td>should point to a buffer at least as long as count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes used, or zero on error. </dd></dl>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00353">353</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a400bf1d9ba36e100746ed9d059bb00c3"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_from_arbitrary_length" ref="a400bf1d9ba36e100746ed9d059bb00c3" args="(const unsigned char *buffer, unsigned int *ints, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_from_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a buffer of arbitrary length integers. </p>
<p>Converts from the integers from the arbitrary length format into an array of normal ints. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>Number of integers expected. Cannot be zero. </td></tr>
    <tr><td class="paramname">ints</td><td>should point to a buffer at least as long as count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes used, or zero on error. </dd></dl>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00384">384</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeac7165265df73510889a7782f370b1a"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_from_arbitrary_length" ref="aeac7165265df73510889a7782f370b1a" args="(const unsigned char *buffer, int *ints, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_from_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a buffer of arbitrary length integers. </p>
<p>Converts from the integers from the arbitrary length format into an array of normal ints. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>Number of integers expected. Cannot be zero. </td></tr>
    <tr><td class="paramname">ints</td><td>should point to a buffer at least as long as count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes used, or zero on error. </dd></dl>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00415">415</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa66f835d97e8f392284c3850fb2d7fda"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_from_arbitrary_length" ref="aa66f835d97e8f392284c3850fb2d7fda" args="(const unsigned char *buffer, unsigned short *ints, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_from_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a buffer of arbitrary length integers. </p>
<p>Converts from the integers from the arbitrary length format into an array of normal ints. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>Number of integers expected. Cannot be zero. </td></tr>
    <tr><td class="paramname">ints</td><td>should point to a buffer at least as long as count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes used, or zero on error. </dd></dl>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00446">446</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7099f9d60b5ab4138c5bb2d5ed94f9bc"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_from_arbitrary_length" ref="a7099f9d60b5ab4138c5bb2d5ed94f9bc" args="(const unsigned char *buffer, short *ints, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_from_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a buffer of arbitrary length integers. </p>
<p>Converts from the integers from the arbitrary length format into an array of normal ints. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>Number of integers expected. Cannot be zero. </td></tr>
    <tr><td class="paramname">ints</td><td>should point to a buffer at least as long as count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes used, or zero on error. </dd></dl>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00477">477</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a597c3f7e64d2b2c86638b56d2b3ff60e"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_from_arbitrary_length_signed_impl" ref="a597c3f7e64d2b2c86638b56d2b3ff60e" args="(const unsigned char *buffer, T *ints, vcl_size_t count)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_from_arbitrary_length_signed_impl </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implement arbitrary length conversion for signed integers. </p>
<p>This function should only be used by this header file. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00213">213</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a03cc4bce73b428a61548539381868646"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_from_arbitrary_length_unsigned_impl" ref="a03cc4bce73b428a61548539381868646" args="(const unsigned char *buffer, T *ints, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_from_arbitrary_length_unsigned_impl </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implement arbitrary length conversion for unsigned integers. </p>
<p>This function should only be used by this header file. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00262">262</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa756220489e32ec428591b4b19b61387"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_to_arbitrary_length" ref="aa756220489e32ec428591b4b19b61387" args="(const unsigned long *ints, unsigned char *buffer, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_to_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned long *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode an array of ints into an arbitrary length format. </p>
<p>The return value is the number of bytes used. buffer should be at least as long as VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH(sizeof(unsigned long)) * count </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00307">307</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7968f2e92215875579c473625318c274"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_to_arbitrary_length" ref="a7968f2e92215875579c473625318c274" args="(const long *ints, unsigned char *buffer, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_to_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode an array of ints into an arbitrary length format. </p>
<p>The return value is the number of bytes used. buffer should be at least as long as VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH(sizeof(long)) * count </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00337">337</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a42aeeaf5ef13e4fcfaba9d42636ab8bc"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_to_arbitrary_length" ref="a42aeeaf5ef13e4fcfaba9d42636ab8bc" args="(const unsigned int *ints, unsigned char *buffer, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_to_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode an array of ints into an arbitrary length format. </p>
<p>The return value is the number of bytes used. buffer should be at least as long as VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH(sizeof(unsigned int)) * count </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00367">367</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a38efab8cc316135476160ea60455239a"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_to_arbitrary_length" ref="a38efab8cc316135476160ea60455239a" args="(const int *ints, unsigned char *buffer, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_to_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode an array of ints into an arbitrary length format. </p>
<p>The return value is the number of bytes used. buffer should be at least as long as VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH(sizeof(int)) * count </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00398">398</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f9dcfde2814b8ea5d10c3ca8fe6a7d7"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_to_arbitrary_length" ref="a7f9dcfde2814b8ea5d10c3ca8fe6a7d7" args="(const unsigned short *ints, unsigned char *buffer, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_to_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode an array of ints into an arbitrary length format. </p>
<p>The return value is the number of bytes used. buffer should be at least as long as VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH(sizeof(unsigned short)) * count </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00429">429</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32e3690ee9467ffe541b3800169885d1"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_to_arbitrary_length" ref="a32e3690ee9467ffe541b3800169885d1" args="(const short *ints, unsigned char *buffer, vcl_size_t count=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_to_arbitrary_length </td>
          <td>(</td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode an array of ints into an arbitrary length format. </p>
<p>The return value is the number of bytes used. buffer should be at least as long as VSL_MAX_ARBITRARY_INT_BUFFER_LENGTH(sizeof(short)) * count </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00460">460</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a515b5b8ba2948e42bc040e713a4242be"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_to_arbitrary_length_signed_impl" ref="a515b5b8ba2948e42bc040e713a4242be" args="(const T *ints, unsigned char *buffer, vcl_size_t count)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_to_arbitrary_length_signed_impl </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implement arbitrary length conversion for signed integers. </p>
<p>This function should only be used by this header file. Returns the number of bytes written </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00191">191</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a76f7298f80647b0203b07097225a2335"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_convert_to_arbitrary_length_unsigned_impl" ref="a76f7298f80647b0203b07097225a2335" args="(const T *ints, unsigned char *buffer, vcl_size_t count)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vcl_size_t vsl_convert_to_arbitrary_length_unsigned_impl </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implement arbitrary length conversion for unsigned integers. </p>
<p>This function should only be used by this header file. Returns the number of bytes written </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00168">168</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad15eab05c6917478b2c90a09245078a9"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_swap_bytes" ref="ad15eab05c6917478b2c90a09245078a9" args="(char *ptr, unsigned nbyte, vcl_size_t nelem=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsl_swap_bytes </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>nelem</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform byte swapping in situ. </p>
<p>Where appropriate, swaps pairs of bytes (behaviour is system dependent) Apply this function to your floating-point data to convert from system format to I/O format. Apply the same function to do the reverse conversion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The buffer to be byte-swapped. </td></tr>
    <tr><td class="paramname">nbyte</td><td>The length of the fundamental type, e.g. sizeof(float). </td></tr>
    <tr><td class="paramname">nelem</td><td>The number of elements in the buffer (default: 1).</td></tr>
  </table>
  </dd>
</dl>
<p>The standard I/O format is little-endian. The code assumes that your system's floats and doubles are stored in memory in either little-endian or big-endian IEEE floating point formats.</p>
<p>Note: There is no point in #ifdef-ing out calls to byte-swapping if you are on a little-endian machine. An optimising compiler will inline the function to nothing for little-endian machines anyway.</p>
<p>If your computer doesn't use IEEE format reals, then we really should redesign the floating point IO. Proposed design notes: Should do conversion to and from a buffer, rather than in place, (since size not known in general) double and reals should be converted to IEEE format. Someone needs to write a long double format anyway. Don't forget to fix all the code that calls vsl_swap_bytes. Really should check anything that #includes this file. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00080">80</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2926a75ece0b6f557a7b2a0f74a12df6"></a><!-- doxytag: member="vsl_binary_explicit_io.h::vsl_swap_bytes_to_buffer" ref="a2926a75ece0b6f557a7b2a0f74a12df6" args="(const char *source, char *dest, unsigned nbyte, vcl_size_t nelem=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsl_swap_bytes_to_buffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>nelem</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform byte swapping to a buffer. </p>
<p>Same as vsl_swap_bytes, but saves the results in a buffer. In general use vsl_swap_bytes where possible, because it is faster. </p>

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00105">105</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a999f42a0e45ba185867063b3cb628ca7"></a><!-- doxytag: member="vsl_binary_explicit_io.h::macros" ref="a999f42a0e45ba185867063b3cb628ca7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">There is a problem with the ENDIAN indication <a class="el" href="vsl__binary__explicit__io_8h.html#a999f42a0e45ba185867063b3cb628ca7">macros</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vsl__binary__explicit__io_8h_source.html#l00044">44</a> of file <a class="el" href="vsl__binary__explicit__io_8h_source.html">vsl_binary_explicit_io.h</a>.</p>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:32:01 for core/vsl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
