<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>core/vnl/vnl_sparse_matrix.txx Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">core/vnl/vnl_sparse_matrix.txx</div>  </div>
</div>
<div class="contents">
<a href="vnl__sparse__matrix_8txx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This is core/vnl/vnl_sparse_matrix.txx</span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef vnl_sparse_matrix_txx_</span>
<a name="l00003"></a><a class="code" href="vnl__sparse__matrix_8txx.html#aa959e6ddb4ce230bdda2537623fef28b">00003</a> <span class="preprocessor"></span><span class="preprocessor">#define vnl_sparse_matrix_txx_</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="comment">//:</span>
<a name="l00005"></a>00005 <span class="comment">// \file</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;<a class="code" href="vnl__sparse__matrix_8h.html" title="Simple sparse matrix.">vnl_sparse_matrix.h</a>&quot;</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;vcl_cassert.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;vcl_algorithm.h&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;vcl_iostream.h&gt;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;<a class="code" href="vnl__math_8h.html" title="Namespace with standard math functions.">vnl/vnl_math.h</a>&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;<a class="code" href="vnl__complex__traits_8h.html" title="To allow templated algorithms to determine appropriate actions of conjugation, complexification etc...">vnl/vnl_complex_traits.h</a>&gt;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#ifdef DEBUG_SPARSE</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor"># include &lt;<a class="code" href="vnl__matrix_8h.html" title="An ordinary mathematical matrix.">vnl/vnl_matrix.h</a>&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#endif</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="comment">// Implementation of vnl_sparse_matrix</span>
<a name="l00021"></a>00021 <span class="comment">//------------------------------------------------------------</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">//: Construct an empty matrix</span>
<a name="l00024"></a>00024 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00025"></a><a class="code" href="classvnl__sparse__matrix.html#a87c79b29725ad2a2b55045b26821346d">00025</a> <a class="code" href="classvnl__sparse__matrix.html#a87c79b29725ad2a2b55045b26821346d" title="Construct an empty matrix.">vnl_sparse_matrix&lt;T&gt;::vnl_sparse_matrix</a>()
<a name="l00026"></a>00026   : rs_(0), cs_(0)
<a name="l00027"></a>00027 {
<a name="l00028"></a>00028 }
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">//------------------------------------------------------------</span>
<a name="l00031"></a>00031 <span class="comment">//: Construct an empty m*n matrix.  There are m rows and n columns.</span>
<a name="l00032"></a>00032 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00033"></a><a class="code" href="classvnl__sparse__matrix.html#aaa6349777f29edd64dd7a5bb4f837e03">00033</a> <a class="code" href="classvnl__sparse__matrix.html#a87c79b29725ad2a2b55045b26821346d" title="Construct an empty matrix.">vnl_sparse_matrix&lt;T&gt;::vnl_sparse_matrix</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)
<a name="l00034"></a>00034   : elements(m), rs_(m), cs_(n)
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036 }
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="comment">//------------------------------------------------------------</span>
<a name="l00039"></a>00039 <span class="comment">//: Construct an m*n Matrix and copy rhs into it.</span>
<a name="l00040"></a>00040 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00041"></a><a class="code" href="classvnl__sparse__matrix.html#a32995ae27b5bd2400644900747ea5a1c">00041</a> <a class="code" href="classvnl__sparse__matrix.html#a87c79b29725ad2a2b55045b26821346d" title="Construct an empty matrix.">vnl_sparse_matrix&lt;T&gt;::vnl_sparse_matrix</a>(<span class="keyword">const</span> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; rhs)
<a name="l00042"></a>00042   : elements(rhs.elements), rs_(rhs.rs_), cs_(rhs.cs_)
<a name="l00043"></a>00043 {
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">//------------------------------------------------------------</span>
<a name="l00047"></a>00047 <span class="comment">//: Copy another vnl_sparse_matrix&lt;T&gt; into this.</span>
<a name="l00048"></a>00048 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00049"></a><a class="code" href="classvnl__sparse__matrix.html#a23bff97774ace186c286f020fa1d765a">00049</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; <a class="code" href="classvnl__sparse__matrix.html#a23bff97774ace186c286f020fa1d765a" title="Copy another vnl_sparse_matrix&lt;T&gt; into this.">vnl_sparse_matrix&lt;T&gt;::operator=</a>(<span class="keyword">const</span> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; rhs)
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051   <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs)
<a name="l00052"></a>00052     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   elements = rhs.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>;
<a name="l00055"></a>00055   rs_ = rhs.<a class="code" href="classvnl__sparse__matrix.html#aedc512d82472fd375534e4f135277d15">rs_</a>;
<a name="l00056"></a>00056   cs_ = rhs.<a class="code" href="classvnl__sparse__matrix.html#aa554158fca0601225a03e1f993e08fad">cs_</a>;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00059"></a>00059 }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="comment">//------------------------------------------------------------</span>
<a name="l00062"></a>00062 <span class="comment">//: Multiply this*rhs, another sparse matrix.</span>
<a name="l00063"></a>00063 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00064"></a><a class="code" href="classvnl__sparse__matrix.html#aa3a45f9099a1df5d0a433ce22dbc5e07">00064</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#af3862be2a0df923f480148d64ac4783a" title="Multiply this*rhs, where rhs is a vector.">vnl_sparse_matrix&lt;T&gt;::mult</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs, <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; result)<span class="keyword"> const</span>
<a name="l00065"></a>00065 <span class="keyword"></span>{
<a name="l00066"></a>00066   assert(rhs.<a class="code" href="classvnl__sparse__matrix.html#ad89ccfe4dcf1fbf03a86ac5479626cf0" title="Get the number of rows in the matrix.">rows</a>() == columns());
<a name="l00067"></a>00067   assert(<span class="keyword">this</span> != &amp;result); <span class="comment">// make sure not to overwrite *this</span>
<a name="l00068"></a>00068   assert(&amp;rhs != &amp;result); <span class="comment">// make sure not to overwrite rhs</span>
<a name="l00069"></a>00069   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result_rows = rows();
<a name="l00070"></a>00070   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result_cols = rhs.<a class="code" href="classvnl__sparse__matrix.html#ae9d7a556bbed7e4a521d41f85104929f" title="Get the number of columns in the matrix.">columns</a>();
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="comment">// Early return: empty result matrix</span>
<a name="l00073"></a>00073   <span class="keywordflow">if</span> (result_rows &lt;= 0 || result_cols &lt;= 0) <span class="keywordflow">return</span>;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075   result.<a class="code" href="classvnl__sparse__matrix.html#aa554158fca0601225a03e1f993e08fad">cs_</a> = result_cols;
<a name="l00076"></a>00076   <span class="keywordflow">if</span> (result.<a class="code" href="classvnl__sparse__matrix.html#ad89ccfe4dcf1fbf03a86ac5479626cf0" title="Get the number of rows in the matrix.">rows</a>() != result_rows)
<a name="l00077"></a>00077   {
<a name="l00078"></a>00078     <span class="comment">// Clear result matrix.</span>
<a name="l00079"></a>00079     result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.clear();
<a name="l00080"></a>00080     <span class="comment">// give the result matrix enough rows (but only if not yet correct).</span>
<a name="l00081"></a>00081     result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.resize(result_rows);
<a name="l00082"></a>00082     result.<a class="code" href="classvnl__sparse__matrix.html#aedc512d82472fd375534e4f135277d15">rs_</a> = result_rows;
<a name="l00083"></a>00083     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> row_id=0; row_id&lt;result_rows; ++row_id)
<a name="l00084"></a>00084       result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[row_id] = <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>();
<a name="l00085"></a>00085   }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087   <span class="comment">// Now, iterate over non-zero rows of this.</span>
<a name="l00088"></a>00088   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> row_id=0; row_id&lt;elements.size(); ++row_id) {
<a name="l00089"></a>00089     <span class="comment">// Get the row from this matrix (lhs).</span>
<a name="l00090"></a>00090     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; this_row = elements[row_id];
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="comment">// Skip to next row if empty.</span>
<a name="l00093"></a>00093     <span class="keywordflow">if</span> (this_row.empty())
<a name="l00094"></a>00094       <span class="keywordflow">continue</span>;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     <span class="comment">// Get the new row in the result matrix.</span>
<a name="l00097"></a>00097     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; result_row = result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[row_id];
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="comment">// Iterate over the row.</span>
<a name="l00100"></a>00100     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator col_iter = this_row.begin();
<a name="l00101"></a>00101          col_iter != this_row.end();
<a name="l00102"></a>00102          ++col_iter)
<a name="l00103"></a>00103     {
<a name="l00104"></a>00104       <span class="comment">// Get the element from the row.</span>
<a name="l00105"></a>00105       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span> &amp; entry = *col_iter;
<a name="l00106"></a>00106       <span class="keywordtype">unsigned</span> <span class="keyword">const</span> col_id = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108       <span class="comment">// So we are at (row_id,col_id) = this_val in lhs matrix (this).</span>
<a name="l00109"></a>00109       <span class="comment">// This must be multiplied by each entry in row col_id in</span>
<a name="l00110"></a>00110       <span class="comment">// the rhs matrix, and the result added to result_row[col_id].</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112       <span class="comment">// If that row in rhs is empty, there is nothing to do.</span>
<a name="l00113"></a>00113       <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span> &amp; rhs_row = rhs.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[col_id];
<a name="l00114"></a>00114       <span class="keywordflow">if</span> (rhs_row.empty())
<a name="l00115"></a>00115         <span class="keywordflow">continue</span>;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117       <span class="comment">// Else iterate over rhs&#39;s row.</span>
<a name="l00118"></a>00118       <span class="keyword">typename</span> row::iterator result_col_iter = result_row.begin();
<a name="l00119"></a>00119       <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator rhs_col_iter = rhs_row.begin();
<a name="l00120"></a>00120            rhs_col_iter != rhs_row.end();
<a name="l00121"></a>00121            ++rhs_col_iter)
<a name="l00122"></a>00122       {
<a name="l00123"></a>00123         <span class="keyword">const</span> <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>&amp; rhs_entry = *rhs_col_iter;
<a name="l00124"></a>00124         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> dest_col = rhs_entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126         <span class="comment">// Calculate the product.</span>
<a name="l00127"></a>00127         T prod = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a> * rhs_entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129         <span class="comment">// This must be added into result_row, at column dest_col.</span>
<a name="l00130"></a>00130         <span class="keywordflow">while</span> ((result_col_iter != result_row.end()) &amp;&amp;
<a name="l00131"></a>00131                ((*result_col_iter).first &lt; dest_col))
<a name="l00132"></a>00132           ++result_col_iter;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         <span class="keywordflow">if</span> ((result_col_iter == result_row.end()) ||
<a name="l00135"></a>00135             ((*result_col_iter).first != dest_col))
<a name="l00136"></a>00136         {
<a name="l00137"></a>00137           <span class="comment">// Add new column to the row.</span>
<a name="l00138"></a>00138           result_col_iter = result_row.insert(result_col_iter, <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>(dest_col,prod));
<a name="l00139"></a>00139         }
<a name="l00140"></a>00140         <span class="keywordflow">else</span>
<a name="l00141"></a>00141         {
<a name="l00142"></a>00142           <span class="comment">// Else add product to existing contents.</span>
<a name="l00143"></a>00143           (*result_col_iter).second += prod;
<a name="l00144"></a>00144         }
<a name="l00145"></a>00145       }
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147   }
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">//------------------------------------------------------------</span>
<a name="l00151"></a>00151 <span class="comment">//: Multiply this*p, a fortran order matrix.</span>
<a name="l00152"></a>00152 <span class="comment">//  The matrix p has n rows and m columns, and is in fortran order, ie. columns first.</span>
<a name="l00153"></a>00153 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00154"></a><a class="code" href="classvnl__sparse__matrix.html#a7787e57c03b4fb125024929f120d9bdf">00154</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#af3862be2a0df923f480148d64ac4783a" title="Multiply this*rhs, where rhs is a vector.">vnl_sparse_matrix&lt;T&gt;::mult</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> prows, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pcols,
<a name="l00155"></a>00155                                 T <span class="keyword">const</span>* p, T* q)<span class="keyword"> const</span>
<a name="l00156"></a>00156 <span class="keyword"></span>{
<a name="l00157"></a>00157   assert(prows == columns());
<a name="l00158"></a>00158 
<a name="l00159"></a>00159   <span class="comment">// Clear q matrix.</span>
<a name="l00160"></a>00160   <span class="keywordtype">int</span> size = prows*pcols;
<a name="l00161"></a>00161   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> temp=0; temp&lt;size; temp++)
<a name="l00162"></a>00162     q[temp] = T(0);
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="preprocessor">#ifdef DEBUG_SPARSE</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>  <a class="code" href="classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> md(rows(),columns());
<a name="l00166"></a>00166   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> rr = 0; rr&lt;rows(); rr++)
<a name="l00167"></a>00167     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cc = 0; cc&lt;columns(); cc++)
<a name="l00168"></a>00168       md(rr,cc) = (*this)(rr,cc);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <a class="code" href="classvnl__matrix.html">vnl_matrix&lt;double&gt;</a> pd(prows,pcols);
<a name="l00171"></a>00171   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> rr = 0; rr&lt;prows; rr++)
<a name="l00172"></a>00172     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cc = 0; cc&lt;pcols; cc++)
<a name="l00173"></a>00173       pd(rr,cc) = p[rr + cc*prows];
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   vcl_cout &lt;&lt; <span class="stringliteral">&quot;Initial p:\n&quot;</span>;
<a name="l00176"></a>00176   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> rr = 0; rr&lt;prows; rr++) {
<a name="l00177"></a>00177     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cc = 0; cc&lt;pcols; cc++) {
<a name="l00178"></a>00178       T pval = p[rr + cc*prows];
<a name="l00179"></a>00179       vcl_cout &lt;&lt; pval &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181     vcl_cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00182"></a>00182   }
<a name="l00183"></a>00183 <span class="preprocessor">#endif</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>
<a name="l00185"></a>00185   <span class="comment">// Now, iterate over non-zero rows of this.</span>
<a name="l00186"></a>00186   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> row_id=0; row_id&lt;elements.size(); ++row_id) {
<a name="l00187"></a>00187     <span class="comment">// Get the row from this matrix (lhs).</span>
<a name="l00188"></a>00188     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span> &amp; this_row = elements[row_id];
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     <span class="comment">// Skip to next row if empty.</span>
<a name="l00191"></a>00191     <span class="keywordflow">if</span> (this_row.empty())
<a name="l00192"></a>00192       <span class="keywordflow">continue</span>;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     <span class="comment">// Iterate over the row.</span>
<a name="l00195"></a>00195     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator col_iter = this_row.begin();
<a name="l00196"></a>00196          col_iter != this_row.end();
<a name="l00197"></a>00197          ++col_iter)
<a name="l00198"></a>00198     {
<a name="l00199"></a>00199       <span class="comment">// Get the element from the row.</span>
<a name="l00200"></a>00200       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span> &amp; entry = *col_iter;
<a name="l00201"></a>00201       <span class="keywordtype">unsigned</span> <span class="keyword">const</span> col_id = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203       <span class="comment">// So we are at (row_id,col_id) = this_val in lhs matrix</span>
<a name="l00204"></a>00204       <span class="comment">// (this).  This must be multiplied by each entry in row</span>
<a name="l00205"></a>00205       <span class="comment">// col_id in the p matrix, and the result added to</span>
<a name="l00206"></a>00206       <span class="comment">// (row_id,p_col_id) in the q matrix.</span>
<a name="l00207"></a>00207       <span class="comment">//</span>
<a name="l00208"></a>00208 
<a name="l00209"></a>00209       <span class="comment">// Iterate over p&#39;s row.</span>
<a name="l00210"></a>00210       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_col_id = 0; p_col_id &lt; pcols; p_col_id++) {
<a name="l00211"></a>00211         <span class="comment">// Get the correct position from p.</span>
<a name="l00212"></a>00212         T pval = p[col_id + p_col_id*prows];
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="comment">// Calculate the product.</span>
<a name="l00215"></a>00215         T prod = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a> * pval;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         <span class="comment">// Add the product into the correct position in q.</span>
<a name="l00218"></a>00218         q[row_id + p_col_id*prows] += prod;
<a name="l00219"></a>00219       }
<a name="l00220"></a>00220     }
<a name="l00221"></a>00221   }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 <span class="preprocessor">#ifdef DEBUG_SPARSE</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span>  vcl_cout &lt;&lt; <span class="stringliteral">&quot;Final q:\n&quot;</span>;
<a name="l00225"></a>00225   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> rr = 0; rr&lt;prows; rr++) {
<a name="l00226"></a>00226     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cc = 0; cc&lt;pcols; cc++) {
<a name="l00227"></a>00227       T pval = q[rr + cc*prows];
<a name="l00228"></a>00228       vcl_cout &lt;&lt; pval &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230     vcl_cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00231"></a>00231   }
<a name="l00232"></a>00232   vcl_cout &lt;&lt; <span class="stringliteral">&quot;nonsparse: &quot;</span> &lt;&lt; md*pd &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00233"></a>00233 <span class="preprocessor">#endif</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>}
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="comment">//------------------------------------------------------------</span>
<a name="l00238"></a>00238 <span class="comment">//: Multiply this*rhs, a vector.</span>
<a name="l00239"></a>00239 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00240"></a><a class="code" href="classvnl__sparse__matrix.html#af3862be2a0df923f480148d64ac4783a">00240</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#af3862be2a0df923f480148d64ac4783a" title="Multiply this*rhs, where rhs is a vector.">vnl_sparse_matrix&lt;T&gt;::mult</a>(<a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs, <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a>&amp; result)<span class="keyword"> const</span>
<a name="l00241"></a>00241 <span class="keyword"></span>{
<a name="l00242"></a>00242   assert(rhs.<a class="code" href="classvnl__vector.html#a11191c91a1dbb4e1d8423dad8b110712" title="Return the length, number of elements, dimension of this vector.">size</a>() == columns());
<a name="l00243"></a>00243 
<a name="l00244"></a>00244   result.<a class="code" href="classvnl__vector.html#ae34b3cfb08e104f2ac81a74dc91537cc" title="Resize to n elements.">set_size</a>( rows() );
<a name="l00245"></a>00245   result.<a class="code" href="classvnl__vector.html#a9939177982a578e13b05cc5e80f96a14" title="Set all values to v.">fill</a>(T(0));
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="keywordtype">int</span> rhs_row_id =0;
<a name="l00248"></a>00248   <span class="keyword">typename</span> vcl_vector&lt;row&gt;::const_iterator lhs_row_iter = elements.<a class="code" href="classvnl__vector.html#ade1c94ab8d54075269ef09d38e38b33b" title="Iterator pointing to start of data.">begin</a>();
<a name="l00249"></a>00249   <span class="keywordflow">for</span> ( ; lhs_row_iter != elements.end(); ++lhs_row_iter, rhs_row_id++ ) {
<a name="l00250"></a>00250     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span> &amp; lhs_row = *lhs_row_iter;
<a name="l00251"></a>00251     <span class="keywordflow">if</span> (lhs_row.empty()) <span class="keywordflow">continue</span>;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     <span class="keyword">typename</span> row::const_iterator lhs_col_iter = lhs_row.begin();
<a name="l00254"></a>00254     <span class="keywordflow">for</span> ( ; lhs_col_iter != lhs_row.end(); ++lhs_col_iter) {
<a name="l00255"></a>00255       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span> &amp; entry = *lhs_col_iter;
<a name="l00256"></a>00256       <span class="keywordtype">unsigned</span> <span class="keyword">const</span> lhs_col_id = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258       result[ rhs_row_id ] += rhs[ lhs_col_id ] * entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>;
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260   }
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="comment">//------------------------------------------------------------</span>
<a name="l00264"></a>00264 <span class="comment">//: Multiply lhs*this, where lhs is a vector</span>
<a name="l00265"></a>00265 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00266"></a><a class="code" href="classvnl__sparse__matrix.html#aa3353180daa039b6d0f53c04f43f3c58">00266</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#aa3353180daa039b6d0f53c04f43f3c58" title="Multiplies lhs*this, where lhs is a vector.">vnl_sparse_matrix&lt;T&gt;::pre_mult</a>(<span class="keyword">const</span> <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a>&amp; lhs, <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a>&amp; result)<span class="keyword"> const</span>
<a name="l00267"></a>00267 <span class="keyword"></span>{
<a name="l00268"></a>00268   assert(lhs.<a class="code" href="classvnl__vector.html#a11191c91a1dbb4e1d8423dad8b110712" title="Return the length, number of elements, dimension of this vector.">size</a>() == rows());
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   <span class="comment">// Resize and clear result vector</span>
<a name="l00271"></a>00271   result.<a class="code" href="classvnl__vector.html#ae34b3cfb08e104f2ac81a74dc91537cc" title="Resize to n elements.">set_size</a>( columns() );
<a name="l00272"></a>00272   result.<a class="code" href="classvnl__vector.html#a9939177982a578e13b05cc5e80f96a14" title="Set all values to v.">fill</a>(T(0));
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="comment">// Now, iterate over lhs values and rows of rhs</span>
<a name="l00275"></a>00275   <span class="keywordtype">unsigned</span> lhs_col_id = 0;
<a name="l00276"></a>00276   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::const_iterator rhs_row_iter = elements.begin();
<a name="l00277"></a>00277        rhs_row_iter != elements.end();
<a name="l00278"></a>00278        ++rhs_row_iter, lhs_col_id++ )
<a name="l00279"></a>00279   {
<a name="l00280"></a>00280     <span class="comment">// Get the row from rhs matrix.</span>
<a name="l00281"></a>00281     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span> &amp; rhs_row = *rhs_row_iter;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="comment">// Skip to next row if empty.</span>
<a name="l00284"></a>00284     <span class="keywordflow">if</span> (rhs_row.empty()) <span class="keywordflow">continue</span>;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="comment">// Iterate over values in rhs row</span>
<a name="l00287"></a>00287     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator rhs_col_iter = rhs_row.begin();
<a name="l00288"></a>00288          rhs_col_iter != rhs_row.end();
<a name="l00289"></a>00289          ++rhs_col_iter)
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291       <span class="comment">// Get the element from the row.</span>
<a name="l00292"></a>00292       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span>&amp; entry = *rhs_col_iter;
<a name="l00293"></a>00293       <span class="keywordtype">unsigned</span> <span class="keyword">const</span> rhs_col_id = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295       result[ rhs_col_id ] += lhs[ lhs_col_id ] * entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>;
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="comment">//------------------------------------------------------------</span>
<a name="l00301"></a>00301 <span class="comment">//: Add rhs to this.</span>
<a name="l00302"></a>00302 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00303"></a><a class="code" href="classvnl__sparse__matrix.html#aa0adf9118acdbf07b068f0b9acdc82f1">00303</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#aa0adf9118acdbf07b068f0b9acdc82f1" title="Add rhs to this.">vnl_sparse_matrix&lt;T&gt;::add</a>(<span class="keyword">const</span> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; rhs,
<a name="l00304"></a>00304                                <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; result)<span class="keyword"> const</span>
<a name="l00305"></a>00305 <span class="keyword"></span>{
<a name="l00306"></a>00306   assert((rhs.<a class="code" href="classvnl__sparse__matrix.html#ad89ccfe4dcf1fbf03a86ac5479626cf0" title="Get the number of rows in the matrix.">rows</a>() == rows()) &amp;&amp; (rhs.<a class="code" href="classvnl__sparse__matrix.html#ae9d7a556bbed7e4a521d41f85104929f" title="Get the number of columns in the matrix.">columns</a>() == columns()));
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="comment">// Clear result matrix.</span>
<a name="l00309"></a>00309   result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.clear();
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   <span class="comment">// Now give the result matrix enough rows.</span>
<a name="l00312"></a>00312   result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.resize(rows());
<a name="l00313"></a>00313   result.<a class="code" href="classvnl__sparse__matrix.html#aedc512d82472fd375534e4f135277d15">rs_</a> = rows();
<a name="l00314"></a>00314   result.<a class="code" href="classvnl__sparse__matrix.html#aa554158fca0601225a03e1f993e08fad">cs_</a> = columns();
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="comment">// Now, iterate over non-zero rows of this.</span>
<a name="l00317"></a>00317   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row_id = 0;
<a name="l00318"></a>00318   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::const_iterator row_iter = elements.begin();
<a name="l00319"></a>00319        row_iter != elements.end();
<a name="l00320"></a>00320        ++row_iter, ++row_id)
<a name="l00321"></a>00321   {
<a name="l00322"></a>00322     <span class="comment">// Get the row from this matrix (lhs).</span>
<a name="l00323"></a>00323     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span> &amp; this_row = *row_iter;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="comment">// Get the new row in the result matrix.</span>
<a name="l00326"></a>00326     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; result_row = result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[row_id];
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     <span class="comment">// Store this into result row.</span>
<a name="l00329"></a>00329     result_row = this_row;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331     <span class="comment">// If rhs row is empty, we are done.</span>
<a name="l00332"></a>00332     <span class="keywordflow">if</span> (rhs.<a class="code" href="classvnl__sparse__matrix.html#a2d5241e8cca7c575b7162bd5fe880717" title="Return whether a given row is empty.">empty_row</a>(row_id))
<a name="l00333"></a>00333       <span class="keywordflow">continue</span>;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="comment">// Get the rhs row.</span>
<a name="l00336"></a>00336     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; rhs_row = rhs.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[row_id];
<a name="l00337"></a>00337 
<a name="l00338"></a>00338     <span class="comment">// Iterate over the rhs row.</span>
<a name="l00339"></a>00339     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator col_iter = rhs_row.begin();
<a name="l00340"></a>00340          col_iter != rhs_row.end();
<a name="l00341"></a>00341          ++col_iter)
<a name="l00342"></a>00342     {
<a name="l00343"></a>00343       <span class="comment">// Get the element from the row.</span>
<a name="l00344"></a>00344       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span>&amp; entry = *col_iter;
<a name="l00345"></a>00345       <span class="keywordtype">unsigned</span> <span class="keyword">const</span> col_id = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347       <span class="comment">// So we are at (row_id,col_id) in rhs matrix.</span>
<a name="l00348"></a>00348       result(row_id,col_id) += entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>;
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350   }
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="comment">//------------------------------------------------------------</span>
<a name="l00354"></a>00354 <span class="comment">//: Subtract rhs from this.</span>
<a name="l00355"></a>00355 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00356"></a><a class="code" href="classvnl__sparse__matrix.html#ae95834d01821492b8839f73dfd9c0e56">00356</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#ae95834d01821492b8839f73dfd9c0e56" title="Subtract rhs from this.">vnl_sparse_matrix&lt;T&gt;::subtract</a>(<span class="keyword">const</span> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; rhs,
<a name="l00357"></a>00357                                     <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; result)<span class="keyword"> const</span>
<a name="l00358"></a>00358 <span class="keyword"></span>{
<a name="l00359"></a>00359   assert((rhs.<a class="code" href="classvnl__sparse__matrix.html#ad89ccfe4dcf1fbf03a86ac5479626cf0" title="Get the number of rows in the matrix.">rows</a>() == rows()) &amp;&amp; (rhs.<a class="code" href="classvnl__sparse__matrix.html#ae9d7a556bbed7e4a521d41f85104929f" title="Get the number of columns in the matrix.">columns</a>() == columns()));
<a name="l00360"></a>00360 
<a name="l00361"></a>00361   <span class="comment">// Clear result matrix.</span>
<a name="l00362"></a>00362   result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.clear();
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <span class="comment">// Now give the result matrix enough rows.</span>
<a name="l00365"></a>00365   result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.resize(rows());
<a name="l00366"></a>00366   result.<a class="code" href="classvnl__sparse__matrix.html#aedc512d82472fd375534e4f135277d15">rs_</a> = rows();
<a name="l00367"></a>00367   result.<a class="code" href="classvnl__sparse__matrix.html#aa554158fca0601225a03e1f993e08fad">cs_</a> = columns();
<a name="l00368"></a>00368 
<a name="l00369"></a>00369   <span class="comment">// Now, iterate over non-zero rows of this.</span>
<a name="l00370"></a>00370   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row_id = 0;
<a name="l00371"></a>00371   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::const_iterator row_iter = elements.begin();
<a name="l00372"></a>00372        row_iter != elements.end();
<a name="l00373"></a>00373        ++row_iter, ++row_id)
<a name="l00374"></a>00374   {
<a name="l00375"></a>00375     <span class="comment">// Get the row from this matrix (lhs).</span>
<a name="l00376"></a>00376     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; this_row = *row_iter;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     <span class="comment">// Get the new row in the result matrix.</span>
<a name="l00379"></a>00379     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; result_row = result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[row_id];
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     <span class="comment">// Store this into result row.</span>
<a name="l00382"></a>00382     result_row = this_row;
<a name="l00383"></a>00383 
<a name="l00384"></a>00384     <span class="comment">// If rhs row is empty, we are done.</span>
<a name="l00385"></a>00385     <span class="keywordflow">if</span> (rhs.<a class="code" href="classvnl__sparse__matrix.html#a2d5241e8cca7c575b7162bd5fe880717" title="Return whether a given row is empty.">empty_row</a>(row_id))
<a name="l00386"></a>00386       <span class="keywordflow">continue</span>;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     <span class="comment">// Get the rhs row.</span>
<a name="l00389"></a>00389     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; rhs_row = rhs.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[row_id];
<a name="l00390"></a>00390 
<a name="l00391"></a>00391     <span class="comment">// Iterate over the rhs row.</span>
<a name="l00392"></a>00392     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator col_iter = rhs_row.begin();
<a name="l00393"></a>00393          col_iter != rhs_row.end();
<a name="l00394"></a>00394          ++col_iter)
<a name="l00395"></a>00395     {
<a name="l00396"></a>00396       <span class="comment">// Get the element from the row.</span>
<a name="l00397"></a>00397       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span>&amp; entry = *col_iter;
<a name="l00398"></a>00398       <span class="keywordtype">unsigned</span> <span class="keyword">const</span> col_id = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400       <span class="comment">// So we are at (row_id,col_id) in rhs matrix.</span>
<a name="l00401"></a>00401       result(row_id,col_id) -= entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>;
<a name="l00402"></a>00402     }
<a name="l00403"></a>00403   }
<a name="l00404"></a>00404 }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="comment">//------------------------------------------------------------</span>
<a name="l00407"></a>00407 <span class="comment">//: Get a reference to an entry in the matrix.</span>
<a name="l00408"></a>00408 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00409"></a><a class="code" href="classvnl__sparse__matrix.html#ae22e76438ce1daa9b60c4ea6a0f0b913">00409</a> T&amp; <a class="code" href="classvnl__sparse__matrix.html#ae22e76438ce1daa9b60c4ea6a0f0b913" title="Get a reference to an entry in the matrix.">vnl_sparse_matrix&lt;T&gt;::operator()</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c)
<a name="l00410"></a>00410 {
<a name="l00411"></a>00411   assert((r &lt; rows()) &amp;&amp; (c &lt; columns()));
<a name="l00412"></a>00412   <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; rw = elements[r];
<a name="l00413"></a>00413   <span class="keyword">typename</span> row::iterator ri;
<a name="l00414"></a>00414   <span class="keywordflow">for</span> (ri = rw.begin(); (ri != rw.end()) &amp;&amp; ((*ri).first &lt; c); ++ri)
<a name="l00415"></a>00415     <span class="comment">/*nothing*/</span>;
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keywordflow">if</span> ((ri == rw.end()) || ((*ri).first != c)) {
<a name="l00418"></a>00418     <span class="comment">// Add new column to the row.</span>
<a name="l00419"></a>00419     ri = rw.insert(ri, <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>(c,T()));
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="keywordflow">return</span> (*ri).second;
<a name="l00423"></a>00423 }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 <span class="comment">//------------------------------------------------------------</span>
<a name="l00426"></a>00426 <span class="comment">//: Get the value of an entry in the matrix.</span>
<a name="l00427"></a>00427 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00428"></a><a class="code" href="classvnl__sparse__matrix.html#aa1083aa5d1cdba1cce30af6d1d097ff1">00428</a> T <a class="code" href="classvnl__sparse__matrix.html#ae22e76438ce1daa9b60c4ea6a0f0b913" title="Get a reference to an entry in the matrix.">vnl_sparse_matrix&lt;T&gt;::operator()</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c)<span class="keyword"> const</span>
<a name="l00429"></a>00429 <span class="keyword"></span>{
<a name="l00430"></a>00430   assert((r &lt; rows()) &amp;&amp; (c &lt; columns()));
<a name="l00431"></a>00431   <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; rw = elements[r];
<a name="l00432"></a>00432   <span class="keyword">typename</span> row::const_iterator ri = rw.begin();
<a name="l00433"></a>00433   <span class="keywordflow">while</span> (ri != rw.end() &amp;&amp; (*ri).first &lt; c)
<a name="l00434"></a>00434     ++ri;
<a name="l00435"></a>00435   <span class="keywordflow">if</span> (ri == rw.end() || (*ri).first != c)
<a name="l00436"></a>00436     <span class="keywordflow">return</span> T(); <span class="comment">// uninitialised value (default constructor) is returned</span>
<a name="l00437"></a>00437   <span class="keywordflow">else</span>
<a name="l00438"></a>00438     <span class="keywordflow">return</span> (*ri).second;
<a name="l00439"></a>00439 }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="comment">//------------------------------------------------------------</span>
<a name="l00442"></a>00442 <span class="comment">//: Get an entry in the matrix.</span>
<a name="l00443"></a>00443 <span class="comment">//  This is the &quot;const&quot; version of operator().</span>
<a name="l00444"></a>00444 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00445"></a><a class="code" href="classvnl__sparse__matrix.html#aa0a07f598c6b076436155c5ac19caa63">00445</a> T <a class="code" href="classvnl__sparse__matrix.html#aa0a07f598c6b076436155c5ac19caa63" title="Get an entry in the matrix.">vnl_sparse_matrix&lt;T&gt;::get</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c)<span class="keyword"> const</span>
<a name="l00446"></a>00446 <span class="keyword"></span>{
<a name="l00447"></a>00447   assert((r &lt; rows()) &amp;&amp; (c &lt; columns()));
<a name="l00448"></a>00448   <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; rw = elements[r];
<a name="l00449"></a>00449   <span class="keyword">typename</span> row::const_iterator ri = rw.begin();
<a name="l00450"></a>00450   <span class="keywordflow">while</span> (ri != rw.end() &amp;&amp; (*ri).first &lt; c)
<a name="l00451"></a>00451     ++ri;
<a name="l00452"></a>00452   <span class="keywordflow">if</span> (ri == rw.end() || (*ri).first != c)
<a name="l00453"></a>00453     <span class="keywordflow">return</span> T(); <span class="comment">// uninitialised value (default constructor) is returned</span>
<a name="l00454"></a>00454   <span class="keywordflow">else</span>
<a name="l00455"></a>00455     <span class="keywordflow">return</span> (*ri).second;
<a name="l00456"></a>00456 }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="comment">//------------------------------------------------------------</span>
<a name="l00459"></a>00459 <span class="comment">//: Put (i.e., add or overwrite) an entry into the matrix.</span>
<a name="l00460"></a>00460 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00461"></a><a class="code" href="classvnl__sparse__matrix.html#a3f9087a55d774fdbb40c079ba0b58d5f">00461</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#a3f9087a55d774fdbb40c079ba0b58d5f" title="Put (i.e., add or overwrite) an entry into the matrix.">vnl_sparse_matrix&lt;T&gt;::put</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c, T <a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>)
<a name="l00462"></a>00462 {
<a name="l00463"></a>00463   assert((r &lt; rows()) &amp;&amp; (c &lt; columns()));
<a name="l00464"></a>00464   <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; rw = elements[r];
<a name="l00465"></a>00465   <span class="keyword">typename</span> row::iterator ri = rw.begin();
<a name="l00466"></a>00466   <span class="keywordflow">while</span> (ri != rw.end() &amp;&amp; (*ri).first &lt; c)
<a name="l00467"></a>00467     ++ri;
<a name="l00468"></a>00468 
<a name="l00469"></a>00469   <span class="keywordflow">if</span> (ri == rw.end() || (*ri).first != c) {
<a name="l00470"></a>00470     <span class="comment">// Add new column to the row.</span>
<a name="l00471"></a>00471     rw.insert(ri, <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>(c,v));
<a name="l00472"></a>00472   }
<a name="l00473"></a>00473   <span class="keywordflow">else</span>
<a name="l00474"></a>00474     (*ri).second = v;
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00478"></a><a class="code" href="classvnl__sparse__matrix.html#a7e9825148c8e2daef1d25d16160ef7a1">00478</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#a7e9825148c8e2daef1d25d16160ef7a1" title="Get diag(A_transpose * A).">vnl_sparse_matrix&lt;T&gt;::diag_AtA</a>(<a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a> &amp; result)<span class="keyword"> const</span>
<a name="l00479"></a>00479 <span class="keyword"></span>{
<a name="l00480"></a>00480   result.<a class="code" href="classvnl__vector.html#ae34b3cfb08e104f2ac81a74dc91537cc" title="Resize to n elements.">set_size</a>( columns() );
<a name="l00481"></a>00481   result.<a class="code" href="classvnl__vector.html#a9939177982a578e13b05cc5e80f96a14" title="Set all values to v.">fill</a>(T(0));
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   <span class="keyword">typename</span> vcl_vector&lt;row&gt;::const_iterator row_iter = elements.<a class="code" href="classvnl__vector.html#ade1c94ab8d54075269ef09d38e38b33b" title="Iterator pointing to start of data.">begin</a>();
<a name="l00484"></a>00484   <span class="keywordflow">for</span> ( ; row_iter != elements.end(); ++row_iter) {
<a name="l00485"></a>00485     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; this_row = *row_iter;
<a name="l00486"></a>00486     <span class="keyword">typename</span> row::const_iterator col_iter = this_row.begin();
<a name="l00487"></a>00487     <span class="keywordflow">for</span> ( ; col_iter != this_row.end(); ++col_iter) {
<a name="l00488"></a>00488       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span>&amp; entry = *col_iter;
<a name="l00489"></a>00489       <span class="keywordtype">unsigned</span> <span class="keyword">const</span> col_id = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00490"></a>00490       result[col_id] += entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a> * entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>;
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492   }
<a name="l00493"></a>00493 }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 <span class="comment">//------------------------------------------------------------</span>
<a name="l00496"></a>00496 <span class="comment">//: Set row in the matrix.</span>
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00499"></a>00499 <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp;
<a name="l00500"></a><a class="code" href="classvnl__sparse__matrix.html#a53ceaec5fb6e42ad3abb76f8b881394c">00500</a> <a class="code" href="classvnl__sparse__matrix.html#a53ceaec5fb6e42ad3abb76f8b881394c" title="Set a whole row at once. Much faster. Returns *this.">vnl_sparse_matrix&lt;T&gt;::set_row</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r,
<a name="l00501"></a>00501                               vcl_vector&lt;int&gt; <span class="keyword">const</span>&amp; colz,
<a name="l00502"></a>00502                               vcl_vector&lt;T&gt; <span class="keyword">const</span>&amp; vals)
<a name="l00503"></a>00503 {
<a name="l00504"></a>00504   assert (r &lt; rows());
<a name="l00505"></a>00505   assert (colz.size() == vals.size());
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; rw = elements[r];
<a name="l00508"></a>00508   <span class="keywordflow">if</span> (rw.size() != colz.size()) rw = <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>(colz.size());
<a name="l00509"></a>00509   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; colz.size(); ++i)
<a name="l00510"></a>00510     rw[i] = <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>(colz[i], vals[i]);
<a name="l00511"></a>00511   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structvnl__sparse__matrix__pair_1_1less.html">vnl_sparse_matrix_pair&lt;T&gt;::less</a> less;
<a name="l00512"></a>00512   vcl_sort(rw.begin(), rw.end(), less());
<a name="l00513"></a>00513   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00514"></a>00514 }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00517"></a>00517 <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp;
<a name="l00518"></a><a class="code" href="classvnl__sparse__matrix.html#ab3793423b336216a7aa7b55043cdab74">00518</a> <a class="code" href="classvnl__sparse__matrix.html#ab3793423b336216a7aa7b55043cdab74" title="Laminate matrix A onto the bottom of this one.">vnl_sparse_matrix&lt;T&gt;::vcat</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; A)
<a name="l00519"></a>00519 {
<a name="l00520"></a>00520   <span class="keywordflow">if</span> (rs_ == 0) {
<a name="l00521"></a>00521     rs_ = A.<a class="code" href="classvnl__sparse__matrix.html#aedc512d82472fd375534e4f135277d15">rs_</a>;
<a name="l00522"></a>00522     cs_ = A.<a class="code" href="classvnl__sparse__matrix.html#aa554158fca0601225a03e1f993e08fad">cs_</a>;
<a name="l00523"></a>00523     elements = A.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>;
<a name="l00524"></a>00524   }
<a name="l00525"></a>00525   <span class="keywordflow">else</span> {
<a name="l00526"></a>00526     assert(cs_ == A.<a class="code" href="classvnl__sparse__matrix.html#aa554158fca0601225a03e1f993e08fad">cs_</a>);
<a name="l00527"></a>00527     rs_ += A.<a class="code" href="classvnl__sparse__matrix.html#aedc512d82472fd375534e4f135277d15">rs_</a>;
<a name="l00528"></a>00528     elements.insert(elements.end(), A.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.begin(), A.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.end());
<a name="l00529"></a>00529   }
<a name="l00530"></a>00530   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00531"></a>00531 }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 <span class="comment">//------------------------------------------------------------</span>
<a name="l00535"></a>00535 <span class="comment">//: This is occasionally useful.  Sums a row of the matrix efficiently.</span>
<a name="l00536"></a>00536 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00537"></a><a class="code" href="classvnl__sparse__matrix.html#aee970907311918f024fd83ccf149464e">00537</a> T <a class="code" href="classvnl__sparse__matrix.html#aee970907311918f024fd83ccf149464e" title="This is occasionally useful.">vnl_sparse_matrix&lt;T&gt;::sum_row</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r)
<a name="l00538"></a>00538 {
<a name="l00539"></a>00539   assert(r &lt; rows());
<a name="l00540"></a>00540   <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> &amp; rw = elements[r];
<a name="l00541"></a>00541   T sum = T(0);
<a name="l00542"></a>00542   <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::iterator ri = rw.begin(); ri != rw.end(); ++ri)
<a name="l00543"></a>00543     sum += (*ri).second;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keywordflow">return</span> sum;
<a name="l00546"></a>00546 }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00549"></a>00549 <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp;
<a name="l00550"></a><a class="code" href="classvnl__sparse__matrix.html#a874f070927e737d5b0c8f82876d01b48">00550</a> <a class="code" href="classvnl__sparse__matrix.html#a874f070927e737d5b0c8f82876d01b48" title="Useful for normalizing row sums in convolution operators.">vnl_sparse_matrix&lt;T&gt;::scale_row</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r, T scale)
<a name="l00551"></a>00551 {
<a name="l00552"></a>00552   assert(r &lt; rows());
<a name="l00553"></a>00553   <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; rw = elements[r];
<a name="l00554"></a>00554   <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::iterator ri = rw.begin(); ri != rw.end(); ++ri)
<a name="l00555"></a>00555     (*ri).second *= scale;
<a name="l00556"></a>00556   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00557"></a>00557 }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="comment">//------------------------------------------------------------</span>
<a name="l00560"></a>00560 <span class="comment">//: Resizes the matrix so that it has r rows and c columns, clearing the current contents.</span>
<a name="l00561"></a>00561 <span class="comment">//</span>
<a name="l00562"></a>00562 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00563"></a><a class="code" href="classvnl__sparse__matrix.html#a4975320bd3b36d2c91600089bba37053">00563</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#a4975320bd3b36d2c91600089bba37053" title="Resizes the array to have r rows and c cols -- sets elements to null.">vnl_sparse_matrix&lt;T&gt;::set_size</a>( <span class="keywordtype">int</span> r, <span class="keywordtype">int</span> c)
<a name="l00564"></a>00564 {
<a name="l00565"></a>00565   rs_ = r;
<a name="l00566"></a>00566   cs_ = c;
<a name="l00567"></a>00567   elements.resize(r);
<a name="l00568"></a>00568   <span class="keyword">typename</span> vnl_sparse_matrix_elements::iterator ie;
<a name="l00569"></a>00569   <span class="keywordflow">for</span> (ie = elements.begin(); ie != elements.end(); ++ie)
<a name="l00570"></a>00570   {
<a name="l00571"></a>00571     <span class="comment">// just set matrix to 0</span>
<a name="l00572"></a>00572     ie-&gt;clear();
<a name="l00573"></a>00573   }
<a name="l00574"></a>00574   reset(); <span class="comment">// reset iterator</span>
<a name="l00575"></a>00575 }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 <span class="comment">//------------------------------------------------------------</span>
<a name="l00578"></a>00578 <span class="comment">//: Resizes the matrix so that it has r rows and c columns, leaving the current contents.</span>
<a name="l00579"></a>00579 <span class="comment">// This is more wasteful of resources than set_size, but it preserves the contents.</span>
<a name="l00580"></a>00580 <span class="comment">//</span>
<a name="l00581"></a>00581 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00582"></a><a class="code" href="classvnl__sparse__matrix.html#a34e2c18dfaba7faee10ebc15f1d925e8">00582</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#a34e2c18dfaba7faee10ebc15f1d925e8" title="Resizes the array to have r rows and c cols.">vnl_sparse_matrix&lt;T&gt;::resize</a>( <span class="keywordtype">int</span> r, <span class="keywordtype">int</span> c)
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldCs = cs_;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586   rs_ = r;
<a name="l00587"></a>00587   cs_ = c;
<a name="l00588"></a>00588   elements.resize(r);
<a name="l00589"></a>00589 
<a name="l00590"></a>00590   <span class="comment">// If the array has fewer columns now, we also need to cut them out</span>
<a name="l00591"></a>00591   <span class="keywordflow">if</span> (oldCs &gt; cs_) {
<a name="l00592"></a>00592     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; elements.size(); ++i) {
<a name="l00593"></a>00593       <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; rw = elements[i];
<a name="l00594"></a>00594       <span class="keyword">typename</span> row::iterator iter;
<a name="l00595"></a>00595       <span class="keywordflow">for</span> (iter = rw.begin(); iter != rw.end() &amp;&amp; (*iter).first&lt;cs_ ; ++iter)
<a name="l00596"></a>00596         <span class="comment">/*nothing*/</span>;
<a name="l00597"></a>00597       <span class="keywordflow">if</span> (iter != rw.end()) rw.erase(iter,rw.end());
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599   }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   reset(); <span class="comment">// reset iterator</span>
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 <span class="comment">//------------------------------------------------------------</span>
<a name="l00605"></a>00605 <span class="comment">//: Resets the internal iterator</span>
<a name="l00606"></a>00606 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00607"></a><a class="code" href="classvnl__sparse__matrix.html#a0bc7856063d6b236021d7f38ec7c9fda">00607</a> <span class="keywordtype">void</span> <a class="code" href="classvnl__sparse__matrix.html#a0bc7856063d6b236021d7f38ec7c9fda" title="Resets the internal iterator.">vnl_sparse_matrix&lt;T&gt;::reset</a>()<span class="keyword"> const</span>
<a name="l00608"></a>00608 <span class="keyword"></span>{
<a name="l00609"></a>00609   itr_isreset = <span class="keyword">true</span>;
<a name="l00610"></a>00610   itr_row = 0;
<a name="l00611"></a>00611 }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="comment">//------------------------------------------------------------</span>
<a name="l00614"></a>00614 <span class="comment">//: Moves the internal iterator to next non-zero entry in matrix.</span>
<a name="l00615"></a>00615 <span class="comment">// Returns true if there is another value, false otherwise. Use</span>
<a name="l00616"></a>00616 <span class="comment">// in combination with methods reset, getrow, getcolumn, and value.</span>
<a name="l00617"></a>00617 <span class="comment">//</span>
<a name="l00618"></a>00618 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00619"></a><a class="code" href="classvnl__sparse__matrix.html#abf63be6e62d80219e254fd87fc210387">00619</a> <span class="keywordtype">bool</span> <a class="code" href="classvnl__sparse__matrix.html#abf63be6e62d80219e254fd87fc210387" title="Moves the internal iterator to next non-zero entry in matrix.">vnl_sparse_matrix&lt;T&gt;::next</a>()<span class="keyword"> const</span>
<a name="l00620"></a>00620 <span class="keyword"></span>{
<a name="l00621"></a>00621   <span class="keywordflow">if</span> ( itr_row &gt;= rows() )
<a name="l00622"></a>00622     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="keywordflow">if</span> ( itr_isreset ) {
<a name="l00625"></a>00625     <span class="comment">// itr_cur is not pointing to an entry</span>
<a name="l00626"></a>00626     itr_row = 0;
<a name="l00627"></a>00627     itr_isreset = <span class="keyword">false</span>;
<a name="l00628"></a>00628   }
<a name="l00629"></a>00629   <span class="keywordflow">else</span> {
<a name="l00630"></a>00630     <span class="comment">// itr_cur is pointing to an entry.</span>
<a name="l00631"></a>00631     <span class="comment">// Try to move to next entry in current row.</span>
<a name="l00632"></a>00632     itr_cur++;
<a name="l00633"></a>00633     <span class="keywordflow">if</span> ( itr_cur != elements[itr_row].end() )
<a name="l00634"></a>00634       <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// found next entry in current row</span>
<a name="l00635"></a>00635     <span class="keywordflow">else</span>
<a name="l00636"></a>00636       itr_row++;
<a name="l00637"></a>00637   }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639   <span class="comment">// search for next entry starting at row itr_row</span>
<a name="l00640"></a>00640   <span class="keywordflow">while</span> ( itr_row &lt; rows() ) {
<a name="l00641"></a>00641     itr_cur = elements[itr_row].begin();
<a name="l00642"></a>00642     <span class="keywordflow">if</span> ( itr_cur != elements[itr_row].end() )
<a name="l00643"></a>00643       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00644"></a>00644     <span class="keywordflow">else</span>
<a name="l00645"></a>00645       itr_row++;
<a name="l00646"></a>00646   }
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   <span class="keywordflow">return</span> itr_row &lt; rows();
<a name="l00649"></a>00649 }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="comment">//------------------------------------------------------------</span>
<a name="l00652"></a>00652 <span class="comment">//: Returns the row of the entry pointed to by internal iterator.</span>
<a name="l00653"></a>00653 <span class="comment">//</span>
<a name="l00654"></a>00654 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00655"></a><a class="code" href="classvnl__sparse__matrix.html#ac6f39e1b750aa1d1f7e6f1576b4ea3f7">00655</a> <span class="keywordtype">int</span> <a class="code" href="classvnl__sparse__matrix.html#ac6f39e1b750aa1d1f7e6f1576b4ea3f7" title="Returns the row of the entry pointed to by internal iterator.">vnl_sparse_matrix&lt;T&gt;::getrow</a>()<span class="keyword"> const</span>
<a name="l00656"></a>00656 <span class="keyword"></span>{
<a name="l00657"></a>00657   <span class="keywordflow">return</span> itr_row;
<a name="l00658"></a>00658 }
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="comment">//------------------------------------------------------------</span>
<a name="l00661"></a>00661 <span class="comment">//: Returns the column of the entry pointed to by internal iterator.</span>
<a name="l00662"></a>00662 <span class="comment">//</span>
<a name="l00663"></a>00663 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00664"></a><a class="code" href="classvnl__sparse__matrix.html#a5757a8e001333203b183c0f807d022d1">00664</a> <span class="keywordtype">int</span> <a class="code" href="classvnl__sparse__matrix.html#a5757a8e001333203b183c0f807d022d1" title="Returns the column of the entry pointed to by internal iterator.">vnl_sparse_matrix&lt;T&gt;::getcolumn</a>()<span class="keyword"> const</span>
<a name="l00665"></a>00665 <span class="keyword"></span>{
<a name="l00666"></a>00666   <span class="keywordflow">return</span> (*itr_cur).first;
<a name="l00667"></a>00667 }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 <span class="comment">//------------------------------------------------------------</span>
<a name="l00670"></a>00670 <span class="comment">//: Returns the value pointed to by the internal iterator.</span>
<a name="l00671"></a>00671 <span class="comment">//</span>
<a name="l00672"></a>00672 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00673"></a><a class="code" href="classvnl__sparse__matrix.html#ad0a0dd6743d914b4a0926d60dc8c6cae">00673</a> T <a class="code" href="classvnl__sparse__matrix.html#ad0a0dd6743d914b4a0926d60dc8c6cae" title="Returns the value pointed to by the internal iterator.">vnl_sparse_matrix&lt;T&gt;::value</a>()<span class="keyword"> const</span>
<a name="l00674"></a>00674 <span class="keyword"></span>{
<a name="l00675"></a>00675   <span class="keywordflow">return</span> (*itr_cur).second;
<a name="l00676"></a>00676 }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 <span class="comment">//------------------------------------------------------------</span>
<a name="l00679"></a>00679 <span class="comment">//: Comparison</span>
<a name="l00680"></a>00680 <span class="comment">//</span>
<a name="l00681"></a>00681 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00682"></a><a class="code" href="classvnl__sparse__matrix.html#a4bc6cbcc88d55634764062778a2d2f36">00682</a> <span class="keywordtype">bool</span> <a class="code" href="classvnl__sparse__matrix.html#a4bc6cbcc88d55634764062778a2d2f36" title="Comparison.">vnl_sparse_matrix&lt;T&gt;::operator==</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs)<span class="keyword"> const</span>
<a name="l00683"></a>00683 <span class="keyword"></span>{
<a name="l00684"></a>00684   <span class="comment">// first of all, sizes must match:</span>
<a name="l00685"></a>00685   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvnl__sparse__matrix.html#ad89ccfe4dcf1fbf03a86ac5479626cf0" title="Get the number of rows in the matrix.">rows</a>() != rows() || rhs.<a class="code" href="classvnl__sparse__matrix.html#ae9d7a556bbed7e4a521d41f85104929f" title="Get the number of columns in the matrix.">columns</a>() != columns()) {
<a name="l00686"></a>00686 <span class="preprocessor">#ifdef DEBUG_SPARSE</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span>    vcl_cerr &lt;&lt; <span class="stringliteral">&quot;Sizes are different: &quot;</span> &lt;&lt; rows() &lt;&lt; <span class="charliteral">&#39;x&#39;</span> &lt;&lt; columns() &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; rhs.<a class="code" href="classvnl__sparse__matrix.html#ad89ccfe4dcf1fbf03a86ac5479626cf0" title="Get the number of rows in the matrix.">rows</a>() &lt;&lt; <span class="charliteral">&#39;x&#39;</span> &lt;&lt; rhs.<a class="code" href="classvnl__sparse__matrix.html#ae9d7a556bbed7e4a521d41f85104929f" title="Get the number of columns in the matrix.">columns</a>() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00688"></a>00688 <span class="preprocessor">#endif</span>
<a name="l00689"></a>00689 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00690"></a>00690   }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   <span class="comment">// Now, iterate over non-zero rows of this and of rhs.</span>
<a name="l00693"></a>00693   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row_id = 0;
<a name="l00694"></a>00694   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::const_iterator row_iter = elements.begin();
<a name="l00695"></a>00695        row_iter != elements.end();
<a name="l00696"></a>00696        ++row_iter, ++row_id)
<a name="l00697"></a>00697   {
<a name="l00698"></a>00698     <span class="comment">// Get the row from this matrix (lhs).</span>
<a name="l00699"></a>00699     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; this_row = *row_iter;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701     <span class="comment">// Get the rhs row.</span>
<a name="l00702"></a>00702     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; rhs_row = rhs.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[row_id];
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="comment">// first of all, row sizes must match:</span>
<a name="l00705"></a>00705     <span class="keywordflow">if</span> (rhs_row.size() != this_row.size())
<a name="l00706"></a>00706       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     <span class="comment">// Iterate over the rhs row.</span>
<a name="l00709"></a>00709     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator col_iter = rhs_row.begin();
<a name="l00710"></a>00710          col_iter != rhs_row.end();
<a name="l00711"></a>00711          ++col_iter)
<a name="l00712"></a>00712     {
<a name="l00713"></a>00713       <span class="comment">// Get the element from the row.</span>
<a name="l00714"></a>00714       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span>&amp; entry = *col_iter;
<a name="l00715"></a>00715       <span class="keywordtype">unsigned</span> <span class="keyword">const</span> col_id = entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717       <span class="comment">// So we are at (row_id,col_id) in rhs matrix.</span>
<a name="l00718"></a>00718       <span class="keywordflow">if</span> (<span class="keyword">get</span>(row_id,col_id) != entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>)
<a name="l00719"></a>00719         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721   }
<a name="l00722"></a>00722   <span class="comment">// if we reach this point, all comparisons succeeded:</span>
<a name="l00723"></a>00723   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00724"></a>00724 }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 <span class="comment">//: Unary minus</span>
<a name="l00727"></a>00727 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00728"></a><a class="code" href="classvnl__sparse__matrix.html#a781cff63a7254a60d7b548b9cfe93926">00728</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <a class="code" href="classvnl__sparse__matrix.html#a781cff63a7254a60d7b548b9cfe93926" title="Unary minus.">vnl_sparse_matrix&lt;T&gt;::operator-</a>()<span class="keyword"> const</span>
<a name="l00729"></a>00729 <span class="keyword"></span>{
<a name="l00730"></a>00730   <span class="comment">// The matrix to be returned:</span>
<a name="l00731"></a>00731   <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> result(rows(), columns());
<a name="l00732"></a>00732 
<a name="l00733"></a>00733   <span class="comment">// Iterate over non-zero rows of this matrix.</span>
<a name="l00734"></a>00734   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row_id = 0;
<a name="l00735"></a>00735   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::const_iterator row_iter = elements.begin();
<a name="l00736"></a>00736        row_iter != elements.end();
<a name="l00737"></a>00737        ++row_iter, ++row_id)
<a name="l00738"></a>00738   {
<a name="l00739"></a>00739     <span class="comment">// Get the row.</span>
<a name="l00740"></a>00740     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; this_row = *row_iter;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     <span class="comment">// Iterate over the row.</span>
<a name="l00743"></a>00743     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator col_iter = this_row.begin();
<a name="l00744"></a>00744          col_iter != this_row.end();
<a name="l00745"></a>00745          ++col_iter)
<a name="l00746"></a>00746     {
<a name="l00747"></a>00747       <span class="comment">// Assign the corresponding result element.</span>
<a name="l00748"></a>00748       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> <span class="keyword">const</span>&amp; entry = *col_iter;
<a name="l00749"></a>00749       result(row_id, entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>) = - entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>;
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751   }
<a name="l00752"></a>00752   <span class="keywordflow">return</span> result;
<a name="l00753"></a>00753 }
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 <span class="comment">//: addition</span>
<a name="l00756"></a>00756 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00757"></a><a class="code" href="classvnl__sparse__matrix.html#aabf170bc1edd20e16da798b674fb250f">00757</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <a class="code" href="classvnl__sparse__matrix.html#aabf170bc1edd20e16da798b674fb250f" title="addition.">vnl_sparse_matrix&lt;T&gt;::operator+</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs)<span class="keyword"> const</span>
<a name="l00758"></a>00758 <span class="keyword"></span>{
<a name="l00759"></a>00759   <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> result(rows(), columns());
<a name="l00760"></a>00760   <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">add</a>(rhs, result);
<a name="l00761"></a>00761   <span class="keywordflow">return</span> result;
<a name="l00762"></a>00762 }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764 <span class="comment">//: subtraction</span>
<a name="l00765"></a>00765 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00766"></a><a class="code" href="classvnl__sparse__matrix.html#a175b310ab50d5944120a1765b2cbd256">00766</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <a class="code" href="classvnl__sparse__matrix.html#a781cff63a7254a60d7b548b9cfe93926" title="Unary minus.">vnl_sparse_matrix&lt;T&gt;::operator-</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs)<span class="keyword"> const</span>
<a name="l00767"></a>00767 <span class="keyword"></span>{
<a name="l00768"></a>00768   <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> result(rows(), columns());
<a name="l00769"></a>00769   <a class="code" href="vnl__bignum_8cxx.html#a988f164e804bb58231f9fceceb7c07c8" title="subtract bmin from bmax (unsigned, non-infinite), result in diff.">subtract</a>(rhs, result);
<a name="l00770"></a>00770   <span class="keywordflow">return</span> result;
<a name="l00771"></a>00771 }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 <span class="comment">//: multiplication</span>
<a name="l00774"></a>00774 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00775"></a><a class="code" href="classvnl__sparse__matrix.html#a4d0990be6c17b0d0a49460914cc59f60">00775</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <a class="code" href="classvnl__sparse__matrix.html#a4d0990be6c17b0d0a49460914cc59f60" title="multiplication.">vnl_sparse_matrix&lt;T&gt;::operator*</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs)<span class="keyword"> const</span>
<a name="l00776"></a>00776 <span class="keyword"></span>{
<a name="l00777"></a>00777   <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> result(rows(), rhs.<a class="code" href="classvnl__sparse__matrix.html#ae9d7a556bbed7e4a521d41f85104929f" title="Get the number of columns in the matrix.">columns</a>());
<a name="l00778"></a>00778   mult(rhs, result);
<a name="l00779"></a>00779   <span class="keywordflow">return</span> result;
<a name="l00780"></a>00780 }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="comment">//: in-place scalar multiplication</span>
<a name="l00783"></a>00783 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00784"></a><a class="code" href="classvnl__sparse__matrix.html#a792928e07459c5b61c7a3c8ee1dfb31c">00784</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; <a class="code" href="classvnl__sparse__matrix.html#a384b19e76741aab6334ffce93995d84a" title="in-place multiplication.">vnl_sparse_matrix&lt;T&gt;::operator*=</a>(T <span class="keyword">const</span>&amp; rhs)
<a name="l00785"></a>00785 {
<a name="l00786"></a>00786   <span class="comment">// Iterate over non-zero rows of this matrix.</span>
<a name="l00787"></a>00787   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::iterator row_iter = elements.begin();
<a name="l00788"></a>00788        row_iter != elements.end();
<a name="l00789"></a>00789        ++row_iter)
<a name="l00790"></a>00790   {
<a name="l00791"></a>00791     <span class="comment">// Get the row.</span>
<a name="l00792"></a>00792     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; this_row = *row_iter;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794     <span class="comment">// Iterate over the row.</span>
<a name="l00795"></a>00795     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::iterator col_iter = this_row.begin();
<a name="l00796"></a>00796          col_iter != this_row.end();
<a name="l00797"></a>00797          ++col_iter)
<a name="l00798"></a>00798     {
<a name="l00799"></a>00799       <span class="comment">// Change the corresponding element.</span>
<a name="l00800"></a>00800       col_iter-&gt;second *= rhs;
<a name="l00801"></a>00801     }
<a name="l00802"></a>00802   }
<a name="l00803"></a>00803   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00804"></a>00804 }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="comment">//: in-place scalar division</span>
<a name="l00807"></a>00807 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00808"></a><a class="code" href="classvnl__sparse__matrix.html#ae7cb46dc42fdea4c6557beb8abc62ddc">00808</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; <a class="code" href="classvnl__sparse__matrix.html#ae7cb46dc42fdea4c6557beb8abc62ddc" title="in-place scalar division.">vnl_sparse_matrix&lt;T&gt;::operator/=</a>(T <span class="keyword">const</span>&amp; rhs)
<a name="l00809"></a>00809 {
<a name="l00810"></a>00810   <span class="comment">// Iterate over non-zero rows of this matrix.</span>
<a name="l00811"></a>00811   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::iterator row_iter = elements.begin();
<a name="l00812"></a>00812        row_iter != elements.end();
<a name="l00813"></a>00813        ++row_iter)
<a name="l00814"></a>00814   {
<a name="l00815"></a>00815     <span class="comment">// Get the row.</span>
<a name="l00816"></a>00816     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; this_row = *row_iter;
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="comment">// Iterate over the row.</span>
<a name="l00819"></a>00819     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::iterator col_iter = this_row.begin();
<a name="l00820"></a>00820          col_iter != this_row.end();
<a name="l00821"></a>00821          ++col_iter)
<a name="l00822"></a>00822     {
<a name="l00823"></a>00823       <span class="comment">// Change the corresponding element.</span>
<a name="l00824"></a>00824       col_iter-&gt;second /= rhs;
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00828"></a>00828 }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830 <span class="comment">//: scalar multiplication</span>
<a name="l00831"></a>00831 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00832"></a><a class="code" href="classvnl__sparse__matrix.html#afba47bb263cc24f03d5aec768da4a8a9">00832</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <a class="code" href="classvnl__sparse__matrix.html#a4d0990be6c17b0d0a49460914cc59f60" title="multiplication.">vnl_sparse_matrix&lt;T&gt;::operator*</a>(T <span class="keyword">const</span>&amp; rhs)<span class="keyword"> const</span>
<a name="l00833"></a>00833 <span class="keyword"></span>{
<a name="l00834"></a>00834   <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> result = *<span class="keyword">this</span>;
<a name="l00835"></a>00835   <span class="keywordflow">return</span> result *= rhs;
<a name="l00836"></a>00836 }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 <span class="comment">//: scalar division</span>
<a name="l00839"></a>00839 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00840"></a><a class="code" href="classvnl__sparse__matrix.html#a97a92798aa6d9ff75d877d3b880e2fff">00840</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <a class="code" href="classvnl__sparse__matrix.html#a97a92798aa6d9ff75d877d3b880e2fff" title="scalar division.">vnl_sparse_matrix&lt;T&gt;::operator/</a>(T <span class="keyword">const</span>&amp; rhs)<span class="keyword"> const</span>
<a name="l00841"></a>00841 <span class="keyword"></span>{
<a name="l00842"></a>00842   <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> result = *<span class="keyword">this</span>;
<a name="l00843"></a>00843   <span class="keywordflow">return</span> result /= rhs;
<a name="l00844"></a>00844 }
<a name="l00845"></a>00845 
<a name="l00846"></a>00846 <span class="comment">//: in-place addition</span>
<a name="l00847"></a>00847 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00848"></a><a class="code" href="classvnl__sparse__matrix.html#a39f071d35a119e6381efa73f5bd06704">00848</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; <a class="code" href="classvnl__sparse__matrix.html#a39f071d35a119e6381efa73f5bd06704" title="in-place addition.">vnl_sparse_matrix&lt;T&gt;::operator+=</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs)
<a name="l00849"></a>00849 {
<a name="l00850"></a>00850   <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="classvnl__bignum.html#a156e7963508bf8aa5407858bdd8de1a0" title="Returns the sum of two bignum numbers.">operator+</a>(rhs);
<a name="l00851"></a>00851 }
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="comment">//: in-place subtraction</span>
<a name="l00854"></a>00854 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00855"></a><a class="code" href="classvnl__sparse__matrix.html#a9dd4c1172040321ff69d76a3df51e1d6">00855</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; <a class="code" href="classvnl__sparse__matrix.html#a9dd4c1172040321ff69d76a3df51e1d6" title="in-place subtraction.">vnl_sparse_matrix&lt;T&gt;::operator-=</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs)
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857   <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="classvnl__bignum.html#a85b79ded6b4c572653e806446976b611" title="Returns the difference of two bignum numbers.">operator-</a>(rhs);
<a name="l00858"></a>00858 }
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 <span class="comment">//: in-place multiplication</span>
<a name="l00861"></a>00861 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00862"></a><a class="code" href="classvnl__sparse__matrix.html#a384b19e76741aab6334ffce93995d84a">00862</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; <a class="code" href="classvnl__sparse__matrix.html#a384b19e76741aab6334ffce93995d84a" title="in-place multiplication.">vnl_sparse_matrix&lt;T&gt;::operator*=</a>(<a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; rhs)
<a name="l00863"></a>00863 {
<a name="l00864"></a>00864   <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>(rhs);
<a name="l00865"></a>00865 }
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="comment">//: Make each row of the matrix have unit norm.</span>
<a name="l00868"></a>00868 <span class="comment">// All-zero rows are ignored.</span>
<a name="l00869"></a>00869 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00870"></a><a class="code" href="classvnl__sparse__matrix.html#ad36f137bf817eda8a258d0af34c20850">00870</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; <a class="code" href="classvnl__sparse__matrix.html#ad36f137bf817eda8a258d0af34c20850" title="Normalizes each row so it is a unit vector, and returns &quot;*this&quot;.">vnl_sparse_matrix&lt;T&gt;::normalize_rows</a>()
<a name="l00871"></a>00871 {
<a name="l00872"></a>00872   <span class="keyword">typedef</span> <span class="keyword">typename</span> vnl_numeric_traits&lt;T&gt;::abs_t Abs_t;
<a name="l00873"></a>00873   <span class="keyword">typedef</span> <span class="keyword">typename</span> vnl_numeric_traits&lt;T&gt;::real_t Real_t;
<a name="l00874"></a>00874   <span class="keyword">typedef</span> <span class="keyword">typename</span> vnl_numeric_traits&lt;Real_t&gt;::abs_t abs_real_t;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="comment">// Iterate through the matrix rows, and normalize one at a time:</span>
<a name="l00877"></a>00877   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::iterator row_iter = elements.begin();
<a name="l00878"></a>00878        row_iter != elements.end();
<a name="l00879"></a>00879        ++row_iter)
<a name="l00880"></a>00880   {
<a name="l00881"></a>00881     <span class="comment">// Get the row.</span>
<a name="l00882"></a>00882     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; this_row = *row_iter;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     Abs_t norm(0); <span class="comment">// double will not do for all types.</span>
<a name="l00885"></a>00885 
<a name="l00886"></a>00886     <span class="comment">// Iterate over the row</span>
<a name="l00887"></a>00887     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::iterator col_iter = this_row.begin();
<a name="l00888"></a>00888          col_iter != this_row.end();
<a name="l00889"></a>00889          ++col_iter)
<a name="l00890"></a>00890     {
<a name="l00891"></a>00891       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>&amp; entry = *col_iter;
<a name="l00892"></a>00892       norm += <a class="code" href="classvnl__finite__int.html#a19fdafee5692378173ed70bbaac3e238">vnl_math_squared_magnitude</a>(entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>);
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894     <span class="keywordflow">if</span> (norm != 0) {
<a name="l00895"></a>00895       abs_real_t scale = abs_real_t(1)/(vcl_sqrt((abs_real_t)norm));
<a name="l00896"></a>00896       <span class="comment">// Iterate again over the row</span>
<a name="l00897"></a>00897       <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::iterator col_iter = this_row.begin();
<a name="l00898"></a>00898            col_iter != this_row.end();
<a name="l00899"></a>00899            ++col_iter)
<a name="l00900"></a>00900       {
<a name="l00901"></a>00901         <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>&amp; entry = *col_iter;
<a name="l00902"></a>00902         entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a> = T(Real_t(entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>) * scale);
<a name="l00903"></a>00903       }
<a name="l00904"></a>00904     }
<a name="l00905"></a>00905   }
<a name="l00906"></a>00906   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00907"></a>00907 }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909 <span class="comment">//: Fill this matrix with 1s on the main diagonal and 0s elsewhere.</span>
<a name="l00910"></a>00910 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00911"></a><a class="code" href="classvnl__sparse__matrix.html#a09177d02feed3ed8870184586ee4ba2e">00911</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a>&amp; <a class="code" href="classvnl__sparse__matrix.html#a09177d02feed3ed8870184586ee4ba2e" title="Sets this matrix to an identity matrix, then returns &quot;*this&quot;.">vnl_sparse_matrix&lt;T&gt;::set_identity</a>()
<a name="l00912"></a>00912 {
<a name="l00913"></a>00913   <span class="comment">// Iterate through the matrix rows, and set one at a time:</span>
<a name="l00914"></a>00914   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rownum = 0;
<a name="l00915"></a>00915   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::iterator row_iter = elements.begin();
<a name="l00916"></a>00916        row_iter != elements.end() &amp;&amp; rownum &lt; cols();
<a name="l00917"></a>00917        ++row_iter, ++rownum)
<a name="l00918"></a>00918   {
<a name="l00919"></a>00919     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; rw = *row_iter;
<a name="l00920"></a>00920     rw.<a class="code" href="classvnl__sparse__matrix.html#a25ed3f712fd7d3eddcc6ba8ad6f2fc80" title="Set all elements to null.">clear</a>();
<a name="l00921"></a>00921     rw[0] = <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>(rownum,T(1));
<a name="l00922"></a>00922   }
<a name="l00923"></a>00923   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00924"></a>00924 }
<a name="l00925"></a>00925 
<a name="l00926"></a>00926 <span class="comment">//: returns a new sparse matrix, viz. the transpose of this</span>
<a name="l00927"></a>00927 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00928"></a><a class="code" href="classvnl__sparse__matrix.html#a8041264210d0cad34e38c3513fc11d41">00928</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <a class="code" href="classvnl__sparse__matrix.html#a8041264210d0cad34e38c3513fc11d41" title="returns a new sparse matrix, viz. the transpose of this.">vnl_sparse_matrix&lt;T&gt;::transpose</a>()<span class="keyword"> const</span>
<a name="l00929"></a>00929 <span class="keyword"></span>{
<a name="l00930"></a>00930   <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> result(cols(), rows());
<a name="l00931"></a>00931   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rownum = 0; <span class="comment">// row number in this matrix</span>
<a name="l00932"></a>00932   <span class="comment">// iterate through the rows of this matrix,</span>
<a name="l00933"></a>00933   <span class="comment">// and add every element thus found to the new result matrix</span>
<a name="l00934"></a>00934   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::const_iterator row_iter = elements.begin();
<a name="l00935"></a>00935        row_iter != elements.end();
<a name="l00936"></a>00936        ++row_iter, ++rownum)
<a name="l00937"></a>00937   {
<a name="l00938"></a>00938     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a> <span class="keyword">const</span>&amp; this_row = *row_iter;
<a name="l00939"></a>00939     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::const_iterator col_iter = this_row.begin();
<a name="l00940"></a>00940          col_iter != this_row.end();
<a name="l00941"></a>00941          ++col_iter)
<a name="l00942"></a>00942     {
<a name="l00943"></a>00943       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a> entry = *col_iter; <span class="comment">// new copy of element</span>
<a name="l00944"></a>00944       <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; rw = result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>[entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a>];
<a name="l00945"></a>00945       entry.<a class="code" href="classvnl__sparse__matrix__pair.html#a502b995cb91ea6b3c34482b37180b974">first</a> = rownum; <span class="comment">// modify element: its column number is now rownum</span>
<a name="l00946"></a>00946       rw.insert(rw.end(), entry); <span class="comment">// insert at the end of the row</span>
<a name="l00947"></a>00947     }
<a name="l00948"></a>00948   }
<a name="l00949"></a>00949   <span class="keywordflow">return</span> result;
<a name="l00950"></a>00950 }
<a name="l00951"></a>00951 
<a name="l00952"></a>00952 <span class="comment">//: returns a new sparse matrix, viz. the conjugate (or Hermitian) transpose of this</span>
<a name="l00953"></a>00953 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00954"></a><a class="code" href="classvnl__sparse__matrix.html#ae977e322596937c15a09184e9d0b5f93">00954</a> <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> <a class="code" href="classvnl__sparse__matrix.html#ae977e322596937c15a09184e9d0b5f93" title="returns a new sparse matrix, viz. the conjugate (or Hermitian) transpose of this.">vnl_sparse_matrix&lt;T&gt;::conjugate_transpose</a>()<span class="keyword"> const</span>
<a name="l00955"></a>00955 <span class="keyword"></span>{
<a name="l00956"></a>00956   <a class="code" href="classvnl__sparse__matrix.html" title="Simple sparse matrix.">vnl_sparse_matrix&lt;T&gt;</a> result(transpose());
<a name="l00957"></a>00957   <span class="keywordflow">for</span> (<span class="keyword">typename</span> vcl_vector&lt;row&gt;::iterator row_iter = result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.begin();
<a name="l00958"></a>00958        row_iter != result.<a class="code" href="classvnl__sparse__matrix.html#a212c047fb512cb40ccd6cfb686b04e91">elements</a>.end();
<a name="l00959"></a>00959        ++row_iter)
<a name="l00960"></a>00960   {
<a name="l00961"></a>00961     <a class="code" href="classvnl__sparse__matrix.html#aa46b72d39fc6d4b6ab4c34068f5db20e">row</a>&amp; this_row = *row_iter;
<a name="l00962"></a>00962     <span class="keywordflow">for</span> (<span class="keyword">typename</span> row::iterator col_iter = this_row.begin();
<a name="l00963"></a>00963          col_iter != this_row.end();
<a name="l00964"></a>00964          ++col_iter)
<a name="l00965"></a>00965     {
<a name="l00966"></a>00966       <a class="code" href="classvnl__sparse__matrix__pair.html" title="Stores elements of sparse matrix.">vnl_sparse_matrix_pair&lt;T&gt;</a>&amp; entry = *col_iter;
<a name="l00967"></a>00967       entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a> = vnl_complex_traits&lt;T&gt;::conjugate(entry.<a class="code" href="classvnl__sparse__matrix__pair.html#ae1afac1497c067a2cd9d571c4b52cdc3">second</a>);
<a name="l00968"></a>00968     }
<a name="l00969"></a>00969   }
<a name="l00970"></a>00970   <span class="keywordflow">return</span> result;
<a name="l00971"></a>00971 }
<a name="l00972"></a>00972 
<a name="l00973"></a><a class="code" href="vnl__sparse__matrix_8txx.html#aa9d28ae3490d70883ca96ca56bb82482">00973</a> <span class="preprocessor">#define VNL_SPARSE_MATRIX_INSTANTIATE(T) \</span>
<a name="l00974"></a>00974 <span class="preprocessor">template class vnl_sparse_matrix&lt;T &gt;</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>
<a name="l00976"></a>00976 <span class="preprocessor">#endif // vnl_sparse_matrix_txx_</span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:31:02 for core/vnl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
