<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>core/vnl/algo/vnl_convolve.h File Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">core/vnl/algo/vnl_convolve.h File Reference</div>  </div>
</div>
<div class="contents">

<p>Templated 1D and 2D convolution.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vnl__vector_8h_source.html">vnl/vnl_vector.h</a>&gt;</code><br/>
</div>
<p><a href="vnl__convolve_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#ae6ad46f486a8a44087626c607e4c8261">VNL_CONVOLVE_INSTANTIATE</a>(T)&#160;&#160;&#160;extern &quot;please include vnl/algo/vnl_convolve.txx first&quot;</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#ab5ae26b46411a846c62865594be91f42">vnl_convolve</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T1 &gt; const &amp;v1, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T2 &gt; const &amp;v2, U *, int use_fft=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve two vnl_vector&lt;T&gt;'s, possibly with different base types T.  <a href="#ab5ae26b46411a846c62865594be91f42"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#a016340cffc002bd114db3f7ee4f5ae6e">vnl_convolve</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T &gt; const &amp;v1, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T &gt; const &amp;v2, int use_fft=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve two vnl_vector&lt;T&gt;'s, with the same base type T.  <a href="#a016340cffc002bd114db3f7ee4f5ae6e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#a0da800a3b0e3b949cdfc9b323bb55ebb">vnl_convolve_cyclic</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T1 &gt; const &amp;v1, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T2 &gt; const &amp;v2, U *, bool use_fft=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cyclically convolve two vnl_vector&lt;T&gt;'s of the same length.  <a href="#a0da800a3b0e3b949cdfc9b323bb55ebb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#a31190874a6008eb1dbb504c6b47c6dae">vnl_convolve</a> (<a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T1 &gt; const &amp;v1, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T2 &gt; const &amp;v2, U *, int use_fft=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#ab31eac89665f43e35050c5c59bb52205">vnl_convolve</a> (<a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T &gt; const &amp;v1, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T &gt; const &amp;v2, int use_fft=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#a982aa531758643364b8b27541a6f4712">vnl_convolve_cyclic</a> (<a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T1 &gt; const &amp;v1, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T2 &gt; const &amp;v2, U *, bool use_fft=false)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#a8a0b99a75024c3e2ea0945b2231d3865">vnl_convolve</a> (<a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T1 &gt; const &amp;v1, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T2 &gt; const &amp;v2, U *, int use_fft=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vnl__convolve_8h.html#a61a3a5c290e678964fd1f075d001ec90">vnl_convolve</a> (<a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T &gt; const &amp;v1, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T &gt; const &amp;v2, int use_fft=0)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Templated 1D and 2D convolution. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Peter Vanroose </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>22 August 2001</dd></dl>
<p>This file contains function declarations for 1D and 2D convolutions, both cyclic and non-cyclic, of vnl_vectors and vnl_matrices. One can choose between straightforward `time-domain' implementations or using FFT to do a `frequency-domain' calculation. </p>

<p>Definition in file <a class="el" href="vnl__convolve_8h_source.html">vnl_convolve.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="ae6ad46f486a8a44087626c607e4c8261"></a><!-- doxytag: member="vnl_convolve.h::VNL_CONVOLVE_INSTANTIATE" ref="ae6ad46f486a8a44087626c607e4c8261" args="(T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VNL_CONVOLVE_INSTANTIATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;extern &quot;please include vnl/algo/vnl_convolve.txx first&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__convolve_8h_source.html#l00107">107</a> of file <a class="el" href="vnl__convolve_8h_source.html">vnl_convolve.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab5ae26b46411a846c62865594be91f42"></a><!-- doxytag: member="vnl_convolve.h::vnl_convolve" ref="ab5ae26b46411a846c62865594be91f42" args="(vnl_vector&lt; T1 &gt; const &amp;v1, vnl_vector&lt; T2 &gt; const &amp;v2, U *, int use_fft=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt;U&gt; vnl_convolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_fft</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolve two vnl_vector&lt;T&gt;'s, possibly with different base types T. </p>
<p><img class="formulaInl" alt="$res[k] := \displaystyle\sum_{i=-\infty}^{+\infty} v1[k-i] \cdot v2[i]$" src="form_6.png"/>.</p>
<p>The returned <a class="el" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector</a> has base type U (the third argument). All calculations are done with type U, so take care! To specify the third argument, pass e.g. a null pointer, casted to U*. Thus: vnl_convolve(v1, v2, (double*)0) would convolve v1 and v2, and return a <a class="el" href="classvnl__vector.html">vnl_vector&lt;double&gt;</a>.</p>
<p>This convolution is non-cyclic, and the length of the result is one less than the sum of the lengths of the two input vectors. But if one of the arguments has length 0, the result has length 0.</p>
<p>When specifying a non-zero 4th argument, FFTs are used to compute the result (see below), which should be identical. The speed of execution may of course differ. In this case both vectors are padded with a sufficient number of zeros, making the length at least that 4th argument, then <a class="el" href="classvnl__vector.html#a0da800a3b0e3b949cdfc9b323bb55ebb" title="Cyclically convolve two vnl_vector&lt;T&gt;&#39;s of the same length.">vnl_convolve_cyclic()</a> is applied. </p>

<p>Definition at line <a class="el" href="vnl__convolve_8txx_source.html#l00115">115</a> of file <a class="el" href="vnl__convolve_8txx_source.html">vnl_convolve.txx</a>.</p>

</div>
</div>
<a class="anchor" id="a016340cffc002bd114db3f7ee4f5ae6e"></a><!-- doxytag: member="vnl_convolve.h::vnl_convolve" ref="a016340cffc002bd114db3f7ee4f5ae6e" args="(vnl_vector&lt; T &gt; const &amp;v1, vnl_vector&lt; T &gt; const &amp;v2, int use_fft=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T &gt; vnl_convolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_fft</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolve two vnl_vector&lt;T&gt;'s, with the same base type T. </p>
<p>The returned <a class="el" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector</a> has the same base type T, and is identical to the return value of the previous function when T1 = T2 = U. </p>

<p>Definition at line <a class="el" href="vnl__convolve_8txx_source.html#l00091">91</a> of file <a class="el" href="vnl__convolve_8txx_source.html">vnl_convolve.txx</a>.</p>

</div>
</div>
<a class="anchor" id="a31190874a6008eb1dbb504c6b47c6dae"></a><!-- doxytag: member="vnl_convolve.h::vnl_convolve" ref="a31190874a6008eb1dbb504c6b47c6dae" args="(vnl_matrix&lt; T1 &gt; const &amp;v1, vnl_matrix&lt; T2 &gt; const &amp;v2, U *, int use_fft=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt;U&gt; vnl_convolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_fft</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab31eac89665f43e35050c5c59bb52205"></a><!-- doxytag: member="vnl_convolve.h::vnl_convolve" ref="ab31eac89665f43e35050c5c59bb52205" args="(vnl_matrix&lt; T &gt; const &amp;v1, vnl_matrix&lt; T &gt; const &amp;v2, int use_fft=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt;T&gt; vnl_convolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_fft</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a0b99a75024c3e2ea0945b2231d3865"></a><!-- doxytag: member="vnl_convolve.h::vnl_convolve" ref="a8a0b99a75024c3e2ea0945b2231d3865" args="(vnl_matrix&lt; T1 &gt; const &amp;v1, vnl_vector&lt; T2 &gt; const &amp;v2, U *, int use_fft=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt;U&gt; vnl_convolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_fft</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a61a3a5c290e678964fd1f075d001ec90"></a><!-- doxytag: member="vnl_convolve.h::vnl_convolve" ref="a61a3a5c290e678964fd1f075d001ec90" args="(vnl_matrix&lt; T &gt; const &amp;v1, vnl_vector&lt; T &gt; const &amp;v2, int use_fft=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt;T&gt; vnl_convolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_fft</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0da800a3b0e3b949cdfc9b323bb55ebb"></a><!-- doxytag: member="vnl_convolve.h::vnl_convolve_cyclic" ref="a0da800a3b0e3b949cdfc9b323bb55ebb" args="(vnl_vector&lt; T1 &gt; const &amp;v1, vnl_vector&lt; T2 &gt; const &amp;v2, U *, bool use_fft=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; U &gt; vnl_convolve_cyclic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_fft</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cyclically convolve two vnl_vector&lt;T&gt;'s of the same length. </p>
<p><img class="formulaInl" alt="$res[k] := \displaystyle\sum_{i=0}^{n-1} v1[k-i] \cdot v2[i]$" src="form_7.png"/>.</p>
<p>A cyclic convolution requires that the lengths of the input vectors are identical. If this is not the case, an assert failure occurs. The length of the returned vector equals the length of the inputs.</p>
<p>Since the convolution theorem states that a cyclic convolution followed by an FFT is the same as an FFT followed by a multiplication, a cyclic convolution can also be implemented using 3 FFTs on n points and n complex multiplications. By default, vnl_convolve_cyclic does not use FFTs. By specifying "true" as the fourth argument, calculation of the convolution is done using FFTs. This will generally be faster for large n, especially if the vectors are not sparse, and/or if n is a power of 2. </p>

<p>Definition at line <a class="el" href="vnl__convolve_8txx_source.html#l00039">39</a> of file <a class="el" href="vnl__convolve_8txx_source.html">vnl_convolve.txx</a>.</p>

</div>
</div>
<a class="anchor" id="a982aa531758643364b8b27541a6f4712"></a><!-- doxytag: member="vnl_convolve.h::vnl_convolve_cyclic" ref="a982aa531758643364b8b27541a6f4712" args="(vnl_matrix&lt; T1 &gt; const &amp;v1, vnl_matrix&lt; T2 &gt; const &amp;v2, U *, bool use_fft=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt;U&gt; vnl_convolve_cyclic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_fft</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:31:02 for core/vnl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
