<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>core/vnl/vnl_matrix_fixed.h Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">core/vnl/vnl_matrix_fixed.h</div>  </div>
</div>
<div class="contents">
<a href="vnl__matrix__fixed_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This is core/vnl/vnl_matrix_fixed.h</span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef vnl_matrix_fixed_h_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#define vnl_matrix_fixed_h_</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor">#ifdef VCL_NEEDS_PRAGMA_INTERFACE</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span><span class="preprocessor">#pragma interface</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="comment">//:</span>
<a name="l00008"></a>00008 <span class="comment">// \file</span>
<a name="l00009"></a>00009 <span class="comment">// \brief fixed size matrix</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00011"></a>00011 <span class="comment">// \author Andrew W. Fitzgibbon, Oxford RRG</span>
<a name="l00012"></a>00012 <span class="comment">// \date   04 Aug 96</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// \verbatim</span>
<a name="l00015"></a>00015 <span class="comment">//  Modifications</span>
<a name="l00016"></a>00016 <span class="comment">//   Peter Vanroose, 23 Nov 1996:  added explicit copy constructor</span>
<a name="l00017"></a>00017 <span class="comment">//   LSB (Manchester) 15/03/2001:  added Binary I/O and tidied up the documentation</span>
<a name="l00018"></a>00018 <span class="comment">//   Feb.2002 - Peter Vanroose - brief doxygen comment placed on single line</span>
<a name="l00019"></a>00019 <span class="comment">//   Oct.2002 - Amitha Perera  - separated vnl_matrix and vnl_matrix_fixed,</span>
<a name="l00020"></a>00020 <span class="comment">//                               removed necessity for vnl_matrix_fixed_ref</span>
<a name="l00021"></a>00021 <span class="comment">//   Oct.2002 - Peter Vanroose - added inplace_transpose() method</span>
<a name="l00022"></a>00022 <span class="comment">//   Jul.2003 - Paul Smyth     - fixed end() bug, made op*=() more general</span>
<a name="l00023"></a>00023 <span class="comment">//   Mar.2009 - Peter Vanroose - added arg_min() and arg_max()</span>
<a name="l00024"></a>00024 <span class="comment">//   Oct.2010 - Peter Vanroose - mutators and filling methods now return *this</span>
<a name="l00025"></a>00025 <span class="comment">//   Jan.2011 - Peter Vanroose - added methods set_diagonal() &amp; get_diagonal()</span>
<a name="l00026"></a>00026 <span class="comment">// \endverbatim</span>
<a name="l00027"></a>00027 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;vcl_cstring.h&gt;</span> <span class="comment">// memcpy()</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;vcl_cassert.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;vcl_iosfwd.h&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="vnl__matrix_8h.html" title="An ordinary mathematical matrix.">vnl_matrix.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="vnl__matrix__ref_8h.html" title="vnl_matrix reference to user-supplied storage.">vnl_matrix_ref.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="vnl__vector_8h.html">vnl/vnl_vector.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="vnl__vector__fixed_8h.html" title="Fixed length stack-stored vector.">vnl/vnl_vector_fixed.h</a>&gt;</span> <span class="comment">// needed for e.g. vnl_matrix_fixed_mat_vec_mult()</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="vnl__c__vector_8h.html" title="Math on blocks of memory.">vnl/vnl_c_vector.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;vnl/vnl_config.h&gt;</span> <span class="comment">// for VNL_CONFIG_CHECK_BOUNDS</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 export <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_rows, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_cols&gt; <span class="keyword">class </span>vnl_matrix_fixed;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="comment">// This mess is for a MSVC6 workaround.</span>
<a name="l00043"></a>00043 <span class="comment">//</span>
<a name="l00044"></a>00044 <span class="comment">// The problem: the matrix-matrix operator* should be written as a</span>
<a name="l00045"></a>00045 <span class="comment">// non-member function since vxl (currently) forbids the use of member</span>
<a name="l00046"></a>00046 <span class="comment">// templates. However, when declared as</span>
<a name="l00047"></a>00047 <span class="comment">// \code</span>
<a name="l00048"></a>00048 <span class="comment">//     template &lt;class T, unsigned m, unsigned n, unsigned o&gt;</span>
<a name="l00049"></a>00049 <span class="comment">//     matrix&lt;T,m,o&gt; operator*( matrix&lt;T,m,n&gt;, matrix&lt;T,n,o&gt; );</span>
<a name="l00050"></a>00050 <span class="comment">// \endcode</span>
<a name="l00051"></a>00051 <span class="comment">// MSVC6 does not find it. A solution is to declare it as a member</span>
<a name="l00052"></a>00052 <span class="comment">// template. However, the obvious</span>
<a name="l00053"></a>00053 <span class="comment">// \code</span>
<a name="l00054"></a>00054 <span class="comment">//     template &lt;unsigned o&gt;</span>
<a name="l00055"></a>00055 <span class="comment">//     matrix&lt;T,num_rows,o&gt; operator*( matrix&lt;T,num_cols,o&gt; );</span>
<a name="l00056"></a>00056 <span class="comment">// \endcode</span>
<a name="l00057"></a>00057 <span class="comment">// causes an internal compiler error. It turns out that if the new</span>
<a name="l00058"></a>00058 <span class="comment">// template parameter &quot;o&quot; comes _first_, then all is okay. Now, we</span>
<a name="l00059"></a>00059 <span class="comment">// can&#39;t change the signature of vnl_matrix_fixed to &lt;unsigned num_cols,</span>
<a name="l00060"></a>00060 <span class="comment">// unsigned num_rows, type&gt;, so we use a &quot;hidden&quot; helper matrix. Except</span>
<a name="l00061"></a>00061 <span class="comment">// that user defined conversion operators and conversion constructors</span>
<a name="l00062"></a>00062 <span class="comment">// are not called for templated functions. So we have to use a helper</span>
<a name="l00063"></a>00063 <span class="comment">// base class. The base class is empty, which means that there is no</span>
<a name="l00064"></a>00064 <span class="comment">// loss in space or time efficiency. Finally, we have:</span>
<a name="l00065"></a>00065 <span class="comment">// \code</span>
<a name="l00066"></a>00066 <span class="comment">//   template &lt;unsigned num_cols, unsigned num_rows, class T&gt;</span>
<a name="l00067"></a>00067 <span class="comment">//   class fake_base { };</span>
<a name="l00068"></a>00068 <span class="comment">//</span>
<a name="l00069"></a>00069 <span class="comment">//   template &lt;class T, unsigned num_rows, unsigned num_cols&gt;</span>
<a name="l00070"></a>00070 <span class="comment">//   class matrix : public fake_base&lt;num_cols,num_rows,T&gt;</span>
<a name="l00071"></a>00071 <span class="comment">//   {</span>
<a name="l00072"></a>00072 <span class="comment">//      template &lt;unsigned o&gt;</span>
<a name="l00073"></a>00073 <span class="comment">//      matrix&lt;T,num_rows,o&gt;  operator*( fake_base&lt;o,num_cols,T&gt; );</span>
<a name="l00074"></a>00074 <span class="comment">//   };</span>
<a name="l00075"></a>00075 <span class="comment">// \endcode</span>
<a name="l00076"></a>00076 <span class="comment">// Notice how &quot;o&quot; is first in the list of template parameters. Since</span>
<a name="l00077"></a>00077 <span class="comment">// base class conversions _are_ performed during template matching,</span>
<a name="l00078"></a>00078 <span class="comment">// matrix&lt;T,m,n&gt; is matched as fake_base&lt;n,m,T&gt;, and all is good. For</span>
<a name="l00079"></a>00079 <span class="comment">// some values of good.</span>
<a name="l00080"></a>00080 <span class="comment">//</span>
<a name="l00081"></a>00081 <span class="comment">// Of course, all this trickery is pre-processed away for conforming</span>
<a name="l00082"></a>00082 <span class="comment">// compilers.</span>
<a name="l00083"></a>00083 <span class="comment">//</span>
<a name="l00084"></a>00084 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_rows, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_cols&gt;
<a name="l00085"></a>00085 <span class="keyword">class </span>vnl_matrix_fixed;
<a name="l00086"></a>00086 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N&gt;
<a name="l00087"></a>00087 <span class="keyword">inline</span>
<a name="l00088"></a>00088 <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T, M&gt;</a> <a class="code" href="vnl__matrix__fixed_8h.html#ac1f53c48975e700614581fc513254696">vnl_matrix_fixed_mat_vec_mult</a>(<span class="keyword">const</span> vnl_matrix_fixed&lt;T, M, N&gt;&amp; a, <span class="keyword">const</span> <a class="code" href="classvnl__vector__fixed.html">vnl_vector_fixed&lt;T, N&gt;</a>&amp; b);
<a name="l00089"></a>00089 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N, <span class="keywordtype">unsigned</span> O&gt;
<a name="l00090"></a>00090 <span class="keyword">inline</span>
<a name="l00091"></a>00091 vnl_matrix_fixed&lt;T, M, O&gt; <a class="code" href="vnl__matrix__fixed_8h.html#a82b89b1bd951e088ffb3baf7a6059872">vnl_matrix_fixed_mat_mat_mult</a>(<span class="keyword">const</span> vnl_matrix_fixed&lt;T, M, N&gt;&amp; a, <span class="keyword">const</span> vnl_matrix_fixed&lt;T, N, O&gt;&amp; b);
<a name="l00092"></a>00092 <span class="preprocessor">#ifdef VCL_VC_6</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> num_cols, <span class="keywordtype">unsigned</span> num_rows, <span class="keyword">class</span> T&gt;
<a name="l00094"></a>00094 <span class="keyword">class </span>vnl_matrix_fixed_fake_base
<a name="l00095"></a>00095 {
<a name="l00096"></a>00096 };
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="preprocessor">#define VNL_MATRIX_FIXED_VCL60_WORKAROUND : public vnl_matrix_fixed_fake_base&lt;num_cols,num_rows,T&gt;</span>
<a name="l00099"></a><a class="code" href="vnl__matrix__fixed_8h.html#a53c93d16ca8e57cb0db24bba560d9de9">00099</a> <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#define VNL_MATRIX_FIXED_VCL60_WORKAROUND </span><span class="comment">/* no workaround. Phew. */</span>
<a name="l00101"></a>00101 <span class="preprocessor">#endif</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="comment">//: Fixed size, stack-stored, space-efficient matrix.</span>
<a name="l00104"></a>00104 <span class="comment">// vnl_matrix_fixed is a fixed-length, stack storage vector. It has</span>
<a name="l00105"></a>00105 <span class="comment">// the same storage size as a C-style array. It is not related via</span>
<a name="l00106"></a>00106 <span class="comment">// inheritance to vnl_matrix. However, it can be converted cheaply to</span>
<a name="l00107"></a>00107 <span class="comment">// a vnl_matrix_ref.</span>
<a name="l00108"></a>00108 <span class="comment">//</span>
<a name="l00109"></a>00109 <span class="comment">// Read the overview documentation of vnl_vector_fixed.</span>
<a name="l00110"></a>00110 <span class="comment">// The text there applies here.</span>
<a name="l00111"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html">00111</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_rows, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_cols&gt;
<a name="l00112"></a>00112 <span class="keyword">class </span>vnl_matrix_fixed  <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html" title="Fixed size, stack-stored, space-efficient matrix.">VNL_MATRIX_FIXED_VCL60_WORKAROUND</a>
<a name="l00113"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a1a08524b63b74276a1894c4d7907a940">00113</a> {
<a name="l00114"></a>00114   T data_[num_rows][num_cols]; <span class="comment">// Local storage</span>
<a name="l00115"></a>00115 
<a name="l00116"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a9b050ca7986376353a969c3040f2e8d5">00116</a>  <span class="keyword">public</span>:
<a name="l00117"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aac3f7b4aba747d233016b1e752ae5c9f">00117</a>   <span class="keyword">typedef</span> vnl_matrix_fixed&lt;T,num_rows,num_cols&gt; <span class="keyword">self</span>;
<a name="l00118"></a>00118   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aac3f7b4aba747d233016b1e752ae5c9f">size_type</a>;
<a name="l00119"></a>00119 
<a name="l00120"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa5cbbb330060087fee32e03dff96fad7">00120</a>   <span class="comment">//: Construct an empty num_rows*num_cols matrix</span>
<a name="l00121"></a>00121   vnl_matrix_fixed() {}
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="comment">//: Construct an empty num_rows*num_cols matrix</span>
<a name="l00124"></a>00124   <span class="comment">//</span>
<a name="l00125"></a>00125   <span class="comment">// The sole purpose of this constructor is to match the interface of</span>
<a name="l00126"></a>00126   <span class="comment">// vnl_matrix, so that algorithms can template over the matrix type</span>
<a name="l00127"></a>00127   <span class="comment">// itself.  It is illegal to call this constructor without</span>
<a name="l00128"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a4cc27decfc5d1b8cb9e10194f18d0d35">00128</a>   <span class="comment">// &lt;tt&gt;n==num_rows&lt;/tt&gt; and &lt;tt&gt;m==num_cols&lt;/tt&gt;.</span>
<a name="l00129"></a>00129   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a4cc27decfc5d1b8cb9e10194f18d0d35" title="Construct an empty num_rows*num_cols matrix.">vnl_matrix_fixed</a>( <span class="keywordtype">unsigned</span> n, <span class="keywordtype">unsigned</span> <a class="code" href="vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a> )
<a name="l00130"></a>00130   {
<a name="l00131"></a>00131     assert( n == num_rows &amp;&amp; m == num_cols );
<a name="l00132"></a>00132   }
<a name="l00133"></a>00133 
<a name="l00134"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa040ebdba4b501562d65deb2097a7e81">00134</a>   <span class="comment">//: Construct an m*n matrix and fill with value</span>
<a name="l00135"></a>00135   <span class="keyword">explicit</span> <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa040ebdba4b501562d65deb2097a7e81" title="Construct an m*n matrix and fill with value.">vnl_matrix_fixed</a>(T value)
<a name="l00136"></a>00136   {
<a name="l00137"></a>00137     T* p = data_[0];
<a name="l00138"></a>00138     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = num_rows * num_cols;
<a name="l00139"></a>00139     <span class="keywordflow">while</span> (n--)
<a name="l00140"></a>00140       *p++ = value;
<a name="l00141"></a>00141   }
<a name="l00142"></a>00142 
<a name="l00143"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aac0c0a908c79a9e19af19dba912e5710">00143</a>   <span class="comment">//: Construct an m*n Matrix and copy data into it row-wise.</span>
<a name="l00144"></a>00144   <span class="keyword">explicit</span> <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aac0c0a908c79a9e19af19dba912e5710" title="Construct an m*n Matrix and copy data into it row-wise.">vnl_matrix_fixed</a>(<span class="keyword">const</span> T* datablck)
<a name="l00145"></a>00145   {
<a name="l00146"></a>00146     vcl_memcpy(data_[0], datablck, num_rows*num_cols*<span class="keyword">sizeof</span>(T));
<a name="l00147"></a>00147   }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   <span class="comment">//: Construct an m*n Matrix and copy rhs into it.</span>
<a name="l00150"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#afecf4bb1a6f6009ef465e3bdbcf3c4a8">00150</a>   <span class="comment">//  Abort if rhs is not the same size.</span>
<a name="l00151"></a>00151   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#afecf4bb1a6f6009ef465e3bdbcf3c4a8" title="Construct an m*n Matrix and copy rhs into it.">vnl_matrix_fixed</a>(<span class="keyword">const</span> vnl_matrix_fixed&amp; rhs)
<a name="l00152"></a>00152   {
<a name="l00153"></a>00153     vcl_memcpy(data_[0], rhs.data_block(), num_rows*num_cols*<span class="keyword">sizeof</span>(T));
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="comment">//: Construct an m*n Matrix and copy rhs into it.</span>
<a name="l00157"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#abddfa348b6d495d246f0f61d22815e9e">00157</a>   <span class="comment">//  Abort if rhs is not the same size.</span>
<a name="l00158"></a>00158   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#abddfa348b6d495d246f0f61d22815e9e" title="Construct an m*n Matrix and copy rhs into it.">vnl_matrix_fixed</a>(<span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; rhs)
<a name="l00159"></a>00159   {
<a name="l00160"></a>00160     assert(rhs.<a class="code" href="classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7" title="Return number of rows.">rows</a>() == num_rows &amp;&amp; rhs.<a class="code" href="classvnl__matrix.html#a4a7d869d8750ba5056f6c6551575fa23" title="Return number of columns.">columns</a>() == num_cols);
<a name="l00161"></a>00161     vcl_memcpy(data_[0], rhs.<a class="code" href="classvnl__matrix.html#ab1fd1abcbe7fc909d57ca83b1e4a1713" title="Access the contiguous block storing the elements in the matrix row-wise. O(1).">data_block</a>(), num_rows*num_cols*<span class="keyword">sizeof</span>(T));
<a name="l00162"></a>00162   }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164   <span class="comment">//  Destruct the m*n matrix.</span>
<a name="l00165"></a>00165   <span class="comment">// An explicit destructor seems to be necessary, at least for gcc 3.0.0,</span>
<a name="l00166"></a>00166   <span class="comment">// to avoid the compiler generating multiple versions of it.</span>
<a name="l00167"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a8bf656b788953c0f9a5e53693f26a4c7">00167</a>   <span class="comment">// (This way, a weak symbol is generated; otherwise not.  A bug of gcc 3.0.)</span>
<a name="l00168"></a>00168   ~vnl_matrix_fixed() {}
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="comment">//: Set all elements to value v</span>
<a name="l00171"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a0d30b9297a353c23f27e11f06515f880">00171</a>   <span class="comment">// Complexity $O(r.c)$</span>
<a name="l00172"></a>00172   vnl_matrix_fixed&amp; operator= (T <span class="keyword">const</span>&amp;<a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>) { fill(v); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="comment">//: Copy a vnl_matrix into this.</span>
<a name="l00175"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a823d9e99d53eefe6c388987ca387c807">00175</a>   <span class="comment">//  Abort if rhs is not the same size.</span>
<a name="l00176"></a>00176   vnl_matrix_fixed&amp; <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a823d9e99d53eefe6c388987ca387c807" title="Copy a vnl_matrix into this.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; rhs)
<a name="l00177"></a>00177   {
<a name="l00178"></a>00178     assert(rhs.<a class="code" href="classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7" title="Return number of rows.">rows</a>() == num_rows &amp;&amp; rhs.<a class="code" href="classvnl__matrix.html#a4a7d869d8750ba5056f6c6551575fa23" title="Return number of columns.">columns</a>() == num_cols);
<a name="l00179"></a>00179     vcl_memcpy(data_[0], rhs.<a class="code" href="classvnl__matrix.html#ab1fd1abcbe7fc909d57ca83b1e4a1713" title="Access the contiguous block storing the elements in the matrix row-wise. O(1).">data_block</a>(), num_rows*num_cols*<span class="keyword">sizeof</span>(T));
<a name="l00180"></a>00180     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00181"></a>00181   }
<a name="l00182"></a>00182 
<a name="l00183"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#ad22b73baea06c757528b834d56e6d2a4">00183</a>   <span class="comment">//: Copy another vnl_matrix_fixed&lt;T,m,n&gt; into this.</span>
<a name="l00184"></a>00184   vnl_matrix_fixed&amp; <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#ad22b73baea06c757528b834d56e6d2a4" title="Copy another vnl_matrix_fixed&lt;T,m,n&gt; into this.">operator=</a>(<span class="keyword">const</span> vnl_matrix_fixed&amp; rhs)
<a name="l00185"></a>00185   {
<a name="l00186"></a>00186     vcl_memcpy(data_[0], rhs.data_block(), num_rows*num_cols*<span class="keyword">sizeof</span>(T));
<a name="l00187"></a>00187     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00188"></a>00188   }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="comment">// Basic 2D-Array functionality-------------------------------------------</span>
<a name="l00191"></a>00191 
<a name="l00192"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#ac58782de799f66d999f12ebf5225c7da">00192</a>   <span class="comment">//: Return number of rows</span>
<a name="l00193"></a>00193   <span class="keywordtype">unsigned</span> rows()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> num_rows; }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   <span class="comment">//: Return number of columns</span>
<a name="l00196"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a4202da6bf6512fc9169606d056e9f667">00196</a>   <span class="comment">// A synonym for cols()</span>
<a name="l00197"></a>00197   <span class="keywordtype">unsigned</span> columns()<span class="keyword">  const </span>{ <span class="keywordflow">return</span> num_cols; }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199   <span class="comment">//: Return number of columns</span>
<a name="l00200"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa10ed7556ad1b7272bd7f49a293b4742">00200</a>   <span class="comment">// A synonym for columns()</span>
<a name="l00201"></a>00201   <span class="keywordtype">unsigned</span> cols()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> num_cols; }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="comment">//: Return number of elements</span>
<a name="l00204"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a64f611141a54fa195962157bf649f2d1">00204</a>   <span class="comment">// This equals rows() * cols()</span>
<a name="l00205"></a>00205   <span class="keywordtype">unsigned</span> size()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> num_rows*num_cols; }
<a name="l00206"></a>00206 
<a name="l00207"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aad666dceee71371d950a2c388883e510">00207</a>   <span class="comment">//: set element</span>
<a name="l00208"></a>00208   <span class="keywordtype">void</span> put (<span class="keywordtype">unsigned</span> r, <span class="keywordtype">unsigned</span> c, T <span class="keyword">const</span>&amp; <a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>) { (*this)(r,c) = v; }
<a name="l00209"></a>00209 
<a name="l00210"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a4cb50685df35793a4dfd87f5728dcb31">00210</a>   <span class="comment">//: set element, and return *this</span>
<a name="l00211"></a>00211   vnl_matrix_fixed&amp; <span class="keyword">set</span> (<span class="keywordtype">unsigned</span> r, <span class="keywordtype">unsigned</span> c, T <span class="keyword">const</span>&amp; <a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>) { (*this)(r,c) = <a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a5e031129b2c3f9e9ee4e56c5935fb8d1">00213</a>   <span class="comment">//: get element</span>
<a name="l00214"></a>00214   T    <span class="keyword">get</span> (<span class="keywordtype">unsigned</span> r, <span class="keywordtype">unsigned</span> c) <span class="keyword">const</span> { <span class="keywordflow">return</span> (*<span class="keyword">this</span>)(r,c); }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="comment">//: return pointer to given row</span>
<a name="l00217"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a44bb4d18df54726074eca2e85593fe8d">00217</a>   <span class="comment">// No boundary checking here.</span>
<a name="l00218"></a>00218   T       * operator[] (<span class="keywordtype">unsigned</span> r) { <span class="keywordflow">return</span> data_[r]; }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   <span class="comment">//: return pointer to given row</span>
<a name="l00221"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a89576c6df9ab6b7e40589867279c7402">00221</a>   <span class="comment">// No boundary checking here.</span>
<a name="l00222"></a>00222   T <span class="keyword">const</span> * operator[] (<span class="keywordtype">unsigned</span> r)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_[r]; }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="comment">//: Access an element for reading or writing</span>
<a name="l00225"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#abe12842fc650f8ea3bbf559ce08aef7f">00225</a>   <span class="comment">// There are assert style boundary checks - #define NDEBUG to turn them off.</span>
<a name="l00226"></a>00226   T       &amp; operator() (<span class="keywordtype">unsigned</span> r, <span class="keywordtype">unsigned</span> c)
<a name="l00227"></a>00227   {
<a name="l00228"></a>00228 <span class="preprocessor">#if VNL_CONFIG_CHECK_BOUNDS  &amp;&amp; (!defined NDEBUG)</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span>    assert(r&lt;rows());   <span class="comment">// Check the row index is valid</span>
<a name="l00230"></a>00230     assert(c&lt;cols());   <span class="comment">// Check the column index is valid</span>
<a name="l00231"></a>00231 <span class="preprocessor">#endif</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>    <span class="keywordflow">return</span> this-&gt;data_[r][c];
<a name="l00233"></a>00233   }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="comment">//: Access an element for reading</span>
<a name="l00236"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a4ff931e21fbab07b98959c3bfcff6ddb">00236</a>   <span class="comment">// There are assert style boundary checks - #define NDEBUG to turn them off.</span>
<a name="l00237"></a>00237   T <span class="keyword">const</span> &amp; operator() (<span class="keywordtype">unsigned</span> r, <span class="keywordtype">unsigned</span> c)<span class="keyword"> const</span>
<a name="l00238"></a>00238 <span class="keyword">  </span>{
<a name="l00239"></a>00239 <span class="preprocessor">#if VNL_CONFIG_CHECK_BOUNDS  &amp;&amp; (!defined NDEBUG)</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span>    assert(r&lt;rows());   <span class="comment">// Check the row index is valid</span>
<a name="l00241"></a>00241     assert(c&lt;cols());   <span class="comment">// Check the column index is valid</span>
<a name="l00242"></a>00242 <span class="preprocessor">#endif</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span>    <span class="keywordflow">return</span> this-&gt;data_[r][c];
<a name="l00244"></a>00244   }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246   <span class="comment">// ----------------------- Filling and copying -----------------------</span>
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="comment">//: Sets all elements of matrix to specified value, and returns &quot;*this&quot;.</span>
<a name="l00249"></a>00249   <span class="comment">//  Complexity $O(r.c)$</span>
<a name="l00250"></a>00250   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00251"></a>00251   <span class="comment">//  e.g., to set a matrix to a column-normalized all-elements-equal matrix, say</span>
<a name="l00252"></a>00252   <span class="comment">//  \code</span>
<a name="l00253"></a>00253   <span class="comment">//     M.fill(1).normalize_columns();</span>
<a name="l00254"></a>00254   <span class="comment">//  \endcode</span>
<a name="l00255"></a>00255   <span class="comment">//  Returning &quot;*this&quot; also allows passing such a matrix as argument</span>
<a name="l00256"></a>00256   <span class="comment">//  to a function f, without having to name the constructed matrix:</span>
<a name="l00257"></a>00257   <span class="comment">//  \code</span>
<a name="l00258"></a>00258   <span class="comment">//     f(vnl_matrix_fixed&lt;double,5,5&gt;(1.0).normalize_columns());</span>
<a name="l00259"></a>00259   <span class="comment">//  \endcode</span>
<a name="l00260"></a>00260   vnl_matrix_fixed&amp; fill(T);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   <span class="comment">//: Sets all diagonal elements of matrix to specified value; returns &quot;*this&quot;.</span>
<a name="l00263"></a>00263   <span class="comment">//  Complexity $O(\min(r,c))$</span>
<a name="l00264"></a>00264   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00265"></a>00265   <span class="comment">//  e.g., to set a 3x3 matrix to [5 0 0][0 10 0][0 0 15], just say</span>
<a name="l00266"></a>00266   <span class="comment">//  \code</span>
<a name="l00267"></a>00267   <span class="comment">//     M.fill_diagonal(5).scale_row(1,2).scale_column(2,3);</span>
<a name="l00268"></a>00268   <span class="comment">//  \endcode</span>
<a name="l00269"></a>00269   <span class="comment">//  Returning &quot;*this&quot; also allows passing a diagonal-filled matrix as argument</span>
<a name="l00270"></a>00270   <span class="comment">//  to a function f, without having to name the constructed matrix:</span>
<a name="l00271"></a>00271   <span class="comment">//  \code</span>
<a name="l00272"></a>00272   <span class="comment">//     f(vnl_matrix_fixed&lt;double,3,3&gt;().fill_diagonal(5));</span>
<a name="l00273"></a>00273   <span class="comment">//  \endcode</span>
<a name="l00274"></a>00274   vnl_matrix_fixed&amp; fill_diagonal(T);
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   <span class="comment">//: Sets the diagonal elements of this matrix to the specified list of values.</span>
<a name="l00277"></a>00277   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations: see the</span>
<a name="l00278"></a>00278   <span class="comment">//  reasoning (and the examples) in the documentation for method</span>
<a name="l00279"></a>00279   <span class="comment">//  fill_diagonal().</span>
<a name="l00280"></a>00280   vnl_matrix_fixed&amp; set_diagonal(<a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a> <span class="keyword">const</span>&amp;);
<a name="l00281"></a>00281 
<a name="l00282"></a>00282   <span class="comment">//: Fills (laminates) this matrix with the given data, then returns it.</span>
<a name="l00283"></a>00283   <span class="comment">//  We assume that the argument points to a contiguous rows*cols array, stored rowwise.</span>
<a name="l00284"></a>00284   <span class="comment">//  No bounds checking on the array.</span>
<a name="l00285"></a>00285   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00286"></a>00286   <span class="comment">//  e.g., to fill a square matrix column-wise, fill it rowwise then transpose:</span>
<a name="l00287"></a>00287   <span class="comment">//  \code</span>
<a name="l00288"></a>00288   <span class="comment">//     M.copy_in(array).inplace_transpose();</span>
<a name="l00289"></a>00289   <span class="comment">//  \endcode</span>
<a name="l00290"></a>00290   <span class="comment">//  Returning &quot;*this&quot; also allows passing a filled-in matrix as argument</span>
<a name="l00291"></a>00291   <span class="comment">//  to a function f, without having to name the constructed matrix:</span>
<a name="l00292"></a>00292   <span class="comment">//  \code</span>
<a name="l00293"></a>00293   <span class="comment">//     f(vnl_matrix_fixed&lt;double,3,3&gt;().copy_in(array));</span>
<a name="l00294"></a>00294   <span class="comment">//  \endcode</span>
<a name="l00295"></a>00295   vnl_matrix_fixed&amp; copy_in(T <span class="keyword">const</span> *);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297   <span class="comment">//: Fills (laminates) this matrix with the given data, then returns it.</span>
<a name="l00298"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aab2f506cbbd878b3ce05073c6aa8659a">00298</a>   <span class="comment">//  A synonym for copy_in()</span>
<a name="l00299"></a>00299   vnl_matrix_fixed&amp; <span class="keyword">set</span>(T <span class="keyword">const</span> *d) { <span class="keywordflow">return</span> copy_in(d); }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="comment">//: Fills the given array with this matrix.</span>
<a name="l00302"></a>00302   <span class="comment">//  We assume that the argument points to a contiguous rows*cols array, stored rowwise.</span>
<a name="l00303"></a>00303   <span class="comment">//  No bounds checking on the array.</span>
<a name="l00304"></a>00304   <span class="keywordtype">void</span> copy_out(T *) <span class="keyword">const</span>;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="comment">//: Transposes this matrix efficiently, if it is square, and returns it.</span>
<a name="l00307"></a>00307   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00308"></a>00308   <span class="comment">//  e.g., to fill a square matrix column-wise, fill it rowwise then transpose:</span>
<a name="l00309"></a>00309   <span class="comment">//  \code</span>
<a name="l00310"></a>00310   <span class="comment">//     M.copy_in(array).inplace_transpose();</span>
<a name="l00311"></a>00311   <span class="comment">//  \endcode</span>
<a name="l00312"></a>00312   vnl_matrix_fixed&amp; inplace_transpose();
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   <span class="comment">// ----------------------- Arithmetic --------------------------------</span>
<a name="l00315"></a>00315   <span class="comment">// note that these functions should not pass scalar as a const&amp;.</span>
<a name="l00316"></a>00316   <span class="comment">// Look what would happen to A /= A(0,0).</span>
<a name="l00317"></a>00317 
<a name="l00318"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a58f48af68bc2ecbc616cc10bc83cc914">00318</a>   <span class="comment">//: Add \a s to each element of lhs matrix in situ</span>
<a name="l00319"></a>00319   vnl_matrix_fixed&amp; operator+= (T s)
<a name="l00320"></a>00320   {
<a name="l00321"></a>00321     <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">self::add</a>( data_block(), s, data_block() ); <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00322"></a>00322   }
<a name="l00323"></a>00323 
<a name="l00324"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a2d674e996f3e5c6e616de52d6ab6a455">00324</a>   <span class="comment">//: Subtract \a s from each element of lhs matrix in situ</span>
<a name="l00325"></a>00325   vnl_matrix_fixed&amp; operator-= (T s)
<a name="l00326"></a>00326   {
<a name="l00327"></a>00327     self::sub( data_block(), s, data_block() ); <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00328"></a>00328   }
<a name="l00329"></a>00329 
<a name="l00330"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a92abd26e503c2146467c1bb98020f015">00330</a>   <span class="comment">//:</span>
<a name="l00331"></a>00331   vnl_matrix_fixed&amp; operator*= (T s)
<a name="l00332"></a>00332   {
<a name="l00333"></a>00333     self::mul( data_block(), s, data_block() ); <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335 
<a name="l00336"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#ac6e1ab4acf45929ed207608a695c804e">00336</a>   <span class="comment">//:</span>
<a name="l00337"></a>00337   vnl_matrix_fixed&amp; operator/= (T s)
<a name="l00338"></a>00338   {
<a name="l00339"></a>00339     self::div( data_block(), s, data_block() ); <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00340"></a>00340   }
<a name="l00341"></a>00341 
<a name="l00342"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a15c6948410af31376f0595005c769f3e">00342</a>   <span class="comment">//:</span>
<a name="l00343"></a>00343   vnl_matrix_fixed&amp; operator+= (vnl_matrix_fixed <span class="keyword">const</span>&amp; <a class="code" href="vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>)
<a name="l00344"></a>00344   {
<a name="l00345"></a>00345     <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">self::add</a>( data_block(), m.data_block(), data_block() ); <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00346"></a>00346   }
<a name="l00347"></a>00347 
<a name="l00348"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a79ef4d8729948e18f60661dcbd247bf1">00348</a>   <span class="comment">//:</span>
<a name="l00349"></a>00349   vnl_matrix_fixed&amp; operator+= (<a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; <a class="code" href="vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>)
<a name="l00350"></a>00350   {
<a name="l00351"></a>00351     assert( m.<a class="code" href="classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7" title="Return number of rows.">rows</a>() == rows() &amp;&amp; m.<a class="code" href="classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867" title="Return number of columns.">cols</a>() == cols() );
<a name="l00352"></a>00352     <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">self::add</a>( data_block(), m.<a class="code" href="classvnl__matrix.html#ab1fd1abcbe7fc909d57ca83b1e4a1713" title="Access the contiguous block storing the elements in the matrix row-wise. O(1).">data_block</a>(), data_block() ); <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00353"></a>00353   }
<a name="l00354"></a>00354 
<a name="l00355"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#ac54abbedeb90c2fcd6ca7dd14d4d8250">00355</a>   <span class="comment">//:</span>
<a name="l00356"></a>00356   vnl_matrix_fixed&amp; operator-= (vnl_matrix_fixed <span class="keyword">const</span>&amp; <a class="code" href="vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>)
<a name="l00357"></a>00357   {
<a name="l00358"></a>00358     self::sub( data_block(), m.data_block(), data_block() ); <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00359"></a>00359   }
<a name="l00360"></a>00360 
<a name="l00361"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa23219a184b2189b3437739867c2d8ec">00361</a>   <span class="comment">//:</span>
<a name="l00362"></a>00362   vnl_matrix_fixed&amp; operator-= (<a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; <a class="code" href="vnl__vector_8h.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>)
<a name="l00363"></a>00363   {
<a name="l00364"></a>00364     assert( m.<a class="code" href="classvnl__matrix.html#a840b1c4c74689f19b0496d476c5cc2d7" title="Return number of rows.">rows</a>() == rows() &amp;&amp; m.<a class="code" href="classvnl__matrix.html#a4d3c7b58bf1dd7325262a2f6e4e57867" title="Return number of columns.">cols</a>() == cols() );
<a name="l00365"></a>00365     self::sub( data_block(), m.<a class="code" href="classvnl__matrix.html#ab1fd1abcbe7fc909d57ca83b1e4a1713" title="Access the contiguous block storing the elements in the matrix row-wise. O(1).">data_block</a>(), data_block() );
<a name="l00366"></a>00366     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00367"></a>00367   }
<a name="l00368"></a>00368 
<a name="l00369"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a2c7d8ef9d49393d4902833f356f4dbd2">00369</a>   <span class="comment">//: Negate all elements of matrix</span>
<a name="l00370"></a>00370   vnl_matrix_fixed <a class="code" href="vnl__bignum_8h.html#a85b79ded6b4c572653e806446976b611" title="Returns the difference of two bignum numbers.">operator- </a>()<span class="keyword"> const</span>
<a name="l00371"></a>00371 <span class="keyword">  </span>{
<a name="l00372"></a>00372     vnl_matrix_fixed r;
<a name="l00373"></a>00373     self::sub( T(0), data_block(), r.data_block() );
<a name="l00374"></a>00374     <span class="keywordflow">return</span> r;
<a name="l00375"></a>00375   }
<a name="l00376"></a>00376 
<a name="l00377"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#acb2e133f519b0a9350255e27d1795e30">00377</a>   <span class="comment">//:</span>
<a name="l00378"></a>00378   vnl_matrix_fixed&amp; operator*= (vnl_matrix_fixed&lt;T,num_cols,num_cols&gt; <span class="keyword">const</span>&amp; s)
<a name="l00379"></a>00379   {
<a name="l00380"></a>00380     vnl_matrix_fixed&lt;T, num_rows, num_cols&gt; out;
<a name="l00381"></a>00381     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_rows; ++i)
<a name="l00382"></a>00382       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; num_cols; ++j)
<a name="l00383"></a>00383       {
<a name="l00384"></a>00384         T accum = this-&gt;data_[i][0] * s(0,j);
<a name="l00385"></a>00385         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 1; k &lt; num_cols; ++k)
<a name="l00386"></a>00386           accum += this-&gt;data_[i][k] * s(k,j);
<a name="l00387"></a>00387         out(i,j) = accum;
<a name="l00388"></a>00388       }
<a name="l00389"></a>00389     <span class="keywordflow">return</span> *<span class="keyword">this</span> = out;
<a name="l00390"></a>00390   }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 <span class="preprocessor">#ifdef VCL_VC_6</span>
<a name="l00393"></a>00393 <span class="preprocessor"></span>  <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> o&gt;
<a name="l00394"></a>00394   vnl_matrix_fixed&lt;T,num_rows,o&gt; <a class="code" href="vnl__matrix__inverse_8h.html#a5e81b5d8eaf9e13731ef6a7d7be95cee">operator*</a>( vnl_matrix_fixed_fake_base&lt;o,num_cols,T&gt; <span class="keyword">const</span>&amp; mat )<span class="keyword"> const</span>
<a name="l00395"></a>00395 <span class="keyword">  </span>{
<a name="l00396"></a>00396     vnl_matrix_fixed&lt;T,num_cols,o&gt; <span class="keyword">const</span>&amp; b = <span class="keyword">static_cast&lt;</span>vnl_matrix_fixed&lt;T,num_cols,o&gt; const&amp;<span class="keyword">&gt;</span>(mat);
<a name="l00397"></a>00397     <span class="keywordflow">return</span> vnl_matrix_fixed_mat_mat_mult&lt;T,num_rows,num_cols,o&gt;( *<span class="keyword">this</span>, b );
<a name="l00398"></a>00398   }
<a name="l00399"></a>00399   <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T, num_rows&gt;</a> <a class="code" href="vnl__matrix__inverse_8h.html#a5e81b5d8eaf9e13731ef6a7d7be95cee">operator*</a>( <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T, num_cols&gt;</a> <span class="keyword">const</span>&amp; b)<span class="keyword"> const</span>
<a name="l00400"></a>00400 <span class="keyword">  </span>{
<a name="l00401"></a>00401     <span class="keywordflow">return</span> vnl_matrix_fixed_mat_vec_mult&lt;T,num_rows,num_cols&gt;(*<span class="keyword">this</span>,b);
<a name="l00402"></a>00402   }
<a name="l00403"></a>00403 <span class="preprocessor">#endif</span>
<a name="l00404"></a>00404 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00405"></a>00405 <span class="comment">  ////--------------------------- Additions ----------------------------</span>
<a name="l00406"></a>00406 <span class="comment"></span>
<a name="l00407"></a>00407   <span class="comment">//: Make a new matrix by applying function to each element.</span>
<a name="l00408"></a>00408   vnl_matrix_fixed apply(T (*f)(T)) <span class="keyword">const</span>;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   <span class="comment">//: Make a new matrix by applying function to each element.</span>
<a name="l00411"></a>00411   vnl_matrix_fixed apply(T (*f)(T <span class="keyword">const</span>&amp;)) <span class="keyword">const</span>;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="comment">//: Return transpose</span>
<a name="l00414"></a>00414   vnl_matrix_fixed&lt;T,num_cols,num_rows&gt; transpose() <span class="keyword">const</span>;
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="comment">//: Return conjugate transpose</span>
<a name="l00417"></a>00417   vnl_matrix_fixed&lt;T,num_cols,num_rows&gt; conjugate_transpose() <span class="keyword">const</span>;
<a name="l00418"></a>00418 
<a name="l00419"></a>00419   <span class="comment">//: Set values of this matrix to those of M, starting at [top,left]</span>
<a name="l00420"></a>00420   vnl_matrix_fixed&amp; update(<a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp;, <span class="keywordtype">unsigned</span> top=0, <span class="keywordtype">unsigned</span> left=0);
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="comment">//: Set the elements of the i&#39;th column to v[i]  (No bounds checking)</span>
<a name="l00423"></a>00423   vnl_matrix_fixed&amp; set_column(<span class="keywordtype">unsigned</span> i, T <span class="keyword">const</span> * <a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="comment">//: Set the elements of the i&#39;th column to value, then return *this.</span>
<a name="l00426"></a>00426   vnl_matrix_fixed&amp; set_column(<span class="keywordtype">unsigned</span> i, T value );
<a name="l00427"></a>00427 
<a name="l00428"></a>00428   <span class="comment">//: Set j-th column to v, then return *this.</span>
<a name="l00429"></a>00429   vnl_matrix_fixed&amp; set_column(<span class="keywordtype">unsigned</span> j, <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a> <span class="keyword">const</span>&amp; <a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431   <span class="comment">//: Set j-th column to v, then return *this.</span>
<a name="l00432"></a>00432   vnl_matrix_fixed&amp; set_column(<span class="keywordtype">unsigned</span> j, <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,num_rows&gt;</a> <span class="keyword">const</span>&amp; <a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>);
<a name="l00433"></a>00433 
<a name="l00434"></a>00434   <span class="comment">//: Set columns to those in M, starting at starting_column, then return *this.</span>
<a name="l00435"></a>00435   vnl_matrix_fixed&amp; set_columns(<span class="keywordtype">unsigned</span> starting_column, <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <span class="keyword">const</span>&amp; M);
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   <span class="comment">//: Set the elements of the i&#39;th row to v[i]  (No bounds checking)</span>
<a name="l00438"></a>00438   vnl_matrix_fixed&amp; set_row   (<span class="keywordtype">unsigned</span> i, T <span class="keyword">const</span> * <a class="code" href="vnl__vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v</a>);
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="comment">//: Set the elements of the i&#39;th row to value, then return *this.</span>
<a name="l00441"></a>00441   vnl_matrix_fixed&amp; set_row   (<span class="keywordtype">unsigned</span> i, T value );
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="comment">//: Set the i-th row, then return *this.</span>
<a name="l00444"></a>00444   vnl_matrix_fixed&amp; set_row   (<span class="keywordtype">unsigned</span> i, <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a> <span class="keyword">const</span>&amp;);
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <span class="comment">//: Set the i-th row, then return *this.</span>
<a name="l00447"></a>00447   vnl_matrix_fixed&amp; set_row   (<span class="keywordtype">unsigned</span> i, <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,num_cols&gt;</a> <span class="keyword">const</span>&amp;);
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   <span class="comment">//: Extract a sub-matrix of size r x c, starting at (top,left)</span>
<a name="l00450"></a>00450   <span class="comment">//  Thus it contains elements  [top,top+r-1][left,left+c-1]</span>
<a name="l00451"></a>00451   <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> extract (<span class="keywordtype">unsigned</span> r,  <span class="keywordtype">unsigned</span> c,
<a name="l00452"></a>00452                          <span class="keywordtype">unsigned</span> top=0, <span class="keywordtype">unsigned</span> left=0) <span class="keyword">const</span>;
<a name="l00453"></a>00453 
<a name="l00454"></a>00454   <span class="comment">//: Extract a sub-matrix starting at (top,left)</span>
<a name="l00455"></a>00455   <span class="comment">//</span>
<a name="l00456"></a>00456   <span class="comment">//  The output is stored in \a sub_matrix, and it should have the</span>
<a name="l00457"></a>00457   <span class="comment">//  required size on entry.  Thus the result will contain elements</span>
<a name="l00458"></a>00458   <span class="comment">//  [top,top+sub_matrix.rows()-1][left,left+sub_matrix.cols()-1]</span>
<a name="l00459"></a>00459   <span class="keywordtype">void</span> extract ( <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; sub_matrix,
<a name="l00460"></a>00460                  <span class="keywordtype">unsigned</span> top=0, <span class="keywordtype">unsigned</span> left=0) <span class="keyword">const</span>;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462   <span class="comment">//: Get a vector equal to the given row</span>
<a name="l00463"></a>00463   <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,num_cols&gt;</a> get_row   (<span class="keywordtype">unsigned</span> row) <span class="keyword">const</span>;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="comment">//: Get a vector equal to the given column</span>
<a name="l00466"></a>00466   <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,num_rows&gt;</a> get_column(<span class="keywordtype">unsigned</span> col) <span class="keyword">const</span>;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="comment">//: Get n rows beginning at rowstart</span>
<a name="l00469"></a>00469   <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> get_n_rows   (<span class="keywordtype">unsigned</span> rowstart, <span class="keywordtype">unsigned</span> n) <span class="keyword">const</span>;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <span class="comment">//: Get n columns beginning at colstart</span>
<a name="l00472"></a>00472   <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> get_n_columns(<span class="keywordtype">unsigned</span> colstart, <span class="keywordtype">unsigned</span> n) <span class="keyword">const</span>;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474   <span class="comment">//: Return a vector with the content of the (main) diagonal</span>
<a name="l00475"></a>00475   <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a> get_diagonal() <span class="keyword">const</span>;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477   <span class="comment">// ==== mutators ====</span>
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <span class="comment">//: Sets this matrix to an identity matrix, then returns &quot;*this&quot;.</span>
<a name="l00480"></a>00480   <span class="comment">//  Returning &quot;*this&quot; allows e.g. passing an identity matrix as argument to</span>
<a name="l00481"></a>00481   <span class="comment">//  a function f, without having to name the constructed matrix:</span>
<a name="l00482"></a>00482   <span class="comment">//  \code</span>
<a name="l00483"></a>00483   <span class="comment">//     f(vnl_matrix_fixed&lt;double,5,5&gt;().set_identity());</span>
<a name="l00484"></a>00484   <span class="comment">//  \endcode</span>
<a name="l00485"></a>00485   <span class="comment">//  Returning &quot;*this&quot; also allows &quot;chaining&quot; two or more operations:</span>
<a name="l00486"></a>00486   <span class="comment">//  e.g., to set a 3x3 matrix to [3 0 0][0 2 0][0 0 1], one could say</span>
<a name="l00487"></a>00487   <span class="comment">//  \code</span>
<a name="l00488"></a>00488   <span class="comment">//     M.set_identity().scale_row(0,3).scale_column(1,2);</span>
<a name="l00489"></a>00489   <span class="comment">//  \endcode</span>
<a name="l00490"></a>00490   <span class="comment">//  If the matrix is not square, anyhow set main diagonal to 1, the rest to 0.</span>
<a name="l00491"></a>00491   vnl_matrix_fixed&amp; set_identity();
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="comment">//: Reverses the order of rows, and returns &quot;*this&quot;.</span>
<a name="l00494"></a>00494   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00495"></a>00495   <span class="comment">//  e.g., to flip both up-down and left-right, one could just say</span>
<a name="l00496"></a>00496   <span class="comment">//  \code</span>
<a name="l00497"></a>00497   <span class="comment">//     M.flipud().fliplr();</span>
<a name="l00498"></a>00498   <span class="comment">//  \endcode</span>
<a name="l00499"></a>00499   vnl_matrix_fixed&amp; flipud();
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   <span class="comment">//: Reverses the order of columns, and returns &quot;*this&quot;.</span>
<a name="l00502"></a>00502   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00503"></a>00503   <span class="comment">//  e.g., to flip both up-down and left-right, one could just say</span>
<a name="l00504"></a>00504   <span class="comment">//  \code</span>
<a name="l00505"></a>00505   <span class="comment">//     M.flipud().fliplr();</span>
<a name="l00506"></a>00506   <span class="comment">//  \endcode</span>
<a name="l00507"></a>00507   vnl_matrix_fixed&amp; fliplr();
<a name="l00508"></a>00508 
<a name="l00509"></a>00509   <span class="comment">//: Normalizes each row so it is a unit vector, and returns &quot;*this&quot;.</span>
<a name="l00510"></a>00510   <span class="comment">//  Zero rows are not modified</span>
<a name="l00511"></a>00511   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00512"></a>00512   <span class="comment">//  e.g., to set a matrix to a row-normalized all-elements-equal matrix, say</span>
<a name="l00513"></a>00513   <span class="comment">//  \code</span>
<a name="l00514"></a>00514   <span class="comment">//     M.fill(1).normalize_rows();</span>
<a name="l00515"></a>00515   <span class="comment">//  \endcode</span>
<a name="l00516"></a>00516   <span class="comment">//  Returning &quot;*this&quot; also allows passing such a matrix as argument</span>
<a name="l00517"></a>00517   <span class="comment">//  to a function f, without having to name the constructed matrix:</span>
<a name="l00518"></a>00518   <span class="comment">//  \code</span>
<a name="l00519"></a>00519   <span class="comment">//     f(vnl_matrix_fixed&lt;double,5,5&gt;(1.0).normalize_rows());</span>
<a name="l00520"></a>00520   <span class="comment">//  \endcode</span>
<a name="l00521"></a>00521   vnl_matrix_fixed&amp; normalize_rows();
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <span class="comment">//: Normalizes each column so it is a unit vector, and returns &quot;*this&quot;.</span>
<a name="l00524"></a>00524   <span class="comment">//  Zero columns are not modified</span>
<a name="l00525"></a>00525   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00526"></a>00526   <span class="comment">//  e.g., to set a matrix to a column-normalized all-elements-equal matrix, say</span>
<a name="l00527"></a>00527   <span class="comment">//  \code</span>
<a name="l00528"></a>00528   <span class="comment">//     M.fill(1).normalize_columns();</span>
<a name="l00529"></a>00529   <span class="comment">//  \endcode</span>
<a name="l00530"></a>00530   <span class="comment">//  Returning &quot;*this&quot; also allows passing such a matrix as argument</span>
<a name="l00531"></a>00531   <span class="comment">//  to a function f, without having to name the constructed matrix:</span>
<a name="l00532"></a>00532   <span class="comment">//  \code</span>
<a name="l00533"></a>00533   <span class="comment">//     f(vnl_matrix_fixed&lt;double,5,5&gt;(1.0).normalize_columns());</span>
<a name="l00534"></a>00534   <span class="comment">//  \endcode</span>
<a name="l00535"></a>00535   vnl_matrix_fixed&amp; normalize_columns();
<a name="l00536"></a>00536 
<a name="l00537"></a>00537   <span class="comment">//: Scales elements in given row by a factor T, and returns &quot;*this&quot;.</span>
<a name="l00538"></a>00538   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00539"></a>00539   <span class="comment">//  e.g., to set a 3x3 matrix to [3 0 0][0 2 0][0 0 1], one could say</span>
<a name="l00540"></a>00540   <span class="comment">//  \code</span>
<a name="l00541"></a>00541   <span class="comment">//     M.set_identity().scale_row(0,3).scale_column(1,2);</span>
<a name="l00542"></a>00542   <span class="comment">//  \endcode</span>
<a name="l00543"></a>00543   vnl_matrix_fixed&amp; scale_row   (<span class="keywordtype">unsigned</span> row, T value);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="comment">//: Scales elements in given column by a factor T, and returns &quot;*this&quot;.</span>
<a name="l00546"></a>00546   <span class="comment">//  Returning &quot;*this&quot; allows &quot;chaining&quot; two or more operations:</span>
<a name="l00547"></a>00547   <span class="comment">//  e.g., to set a 3x3 matrix to [3 0 0][0 2 0][0 0 1], one could say</span>
<a name="l00548"></a>00548   <span class="comment">//  \code</span>
<a name="l00549"></a>00549   <span class="comment">//     M.set_identity().scale_row(0,3).scale_column(1,2);</span>
<a name="l00550"></a>00550   <span class="comment">//  \endcode</span>
<a name="l00551"></a>00551   vnl_matrix_fixed&amp; scale_column(<span class="keywordtype">unsigned</span> col, T value);
<a name="l00552"></a>00552 
<a name="l00553"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968">00553</a>   <span class="comment">//: Type def for norms.</span>
<a name="l00554"></a>00554   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvnl__c__vector.html#adf7c52405913784de7867448bdf40a71">vnl_c_vector&lt;T&gt;::abs_t</a> <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a>;
<a name="l00555"></a>00555 
<a name="l00556"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a92764a8b688f588d31fb20ccd2f8881b">00556</a>   <span class="comment">//: Return sum of absolute values of elements</span>
<a name="l00557"></a>00557   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a> array_one_norm()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::one_norm</a>(begin(), size()); }
<a name="l00558"></a>00558 
<a name="l00559"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a2963b4b497d93e2b44b39733bc8814ab">00559</a>   <span class="comment">//: Return square root of sum of squared absolute element values</span>
<a name="l00560"></a>00560   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a> array_two_norm()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::two_norm</a>(begin(), size()); }
<a name="l00561"></a>00561 
<a name="l00562"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a82ad51d59d853972eba68e2676f33048">00562</a>   <span class="comment">//: Return largest absolute element value</span>
<a name="l00563"></a>00563   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a> array_inf_norm()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::inf_norm</a>(begin(), size()); }
<a name="l00564"></a>00564 
<a name="l00565"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a00ce6461a872b91c437470d0ca4cb6b8">00565</a>   <span class="comment">//: Return sum of absolute values of elements</span>
<a name="l00566"></a>00566   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a> absolute_value_sum()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> array_one_norm(); }
<a name="l00567"></a>00567 
<a name="l00568"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a49c46b9f22643d64e4f5f5015e47911c">00568</a>   <span class="comment">//: Return largest absolute value</span>
<a name="l00569"></a>00569   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a> absolute_value_max()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> array_inf_norm(); }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   <span class="comment">// $ || M ||_1 := \max_j \sum_i | M_{ij} | $</span>
<a name="l00572"></a>00572   abs_t operator_one_norm() <span class="keyword">const</span>;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <span class="comment">// $ || M ||_\inf := \max_i \sum_j | M_{ij} | $</span>
<a name="l00575"></a>00575   abs_t operator_inf_norm() <span class="keyword">const</span>;
<a name="l00576"></a>00576 
<a name="l00577"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a251638e0484e385f0ffb40c76ff0e432">00577</a>   <span class="comment">//: Return Frobenius norm of matrix (sqrt of sum of squares of its elements)</span>
<a name="l00578"></a>00578   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a> frobenius_norm()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::two_norm</a>(begin(), size()); }
<a name="l00579"></a>00579 
<a name="l00580"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a471b19cf3afbed4653aed9d2c9400e1b">00580</a>   <span class="comment">//: Return Frobenius norm of matrix (sqrt of sum of squares of its elements)</span>
<a name="l00581"></a>00581   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a> fro_norm()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> frobenius_norm(); }
<a name="l00582"></a>00582 
<a name="l00583"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a33c776aa3edb9e668d72aa3fa80ef539">00583</a>   <span class="comment">//: Return RMS of all elements</span>
<a name="l00584"></a>00584   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#af763abc215bc50c94538612914114968" title="Type def for norms.">abs_t</a> rms()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::rms_norm</a>(begin(), size()); }
<a name="l00585"></a>00585 
<a name="l00586"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a4d845ab5df83982657d33a5430708792">00586</a>   <span class="comment">//: Return minimum value of elements</span>
<a name="l00587"></a>00587   T min_value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::min_value</a>(begin(), size()); }
<a name="l00588"></a>00588 
<a name="l00589"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a1b721b06b3a07d3ca1a2606a60fe458a">00589</a>   <span class="comment">//: Return maximum value of elements</span>
<a name="l00590"></a>00590   T max_value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::max_value</a>(begin(), size()); }
<a name="l00591"></a>00591 
<a name="l00592"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a8effafbdec2870f9160de05c4602eb0c">00592</a>   <span class="comment">//: Return location of minimum value of elements</span>
<a name="l00593"></a>00593   <span class="keywordtype">unsigned</span> arg_min()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::arg_min</a>(begin(), size()); }
<a name="l00594"></a>00594 
<a name="l00595"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a993a3b5f1bc9dc37e69238cc6846b2d0">00595</a>   <span class="comment">//: Return location of maximum value of elements</span>
<a name="l00596"></a>00596   <span class="keywordtype">unsigned</span> arg_max()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::arg_max</a>(begin(), size()); }
<a name="l00597"></a>00597 
<a name="l00598"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a85e4365d986f87e502cd6d7778c75ad5">00598</a>   <span class="comment">//: Return mean of all matrix elements</span>
<a name="l00599"></a>00599   T mean()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__c__vector.html" title="vnl_c_vector interfaces to lowlevel memory-block operations.">vnl_c_vector&lt;T&gt;::mean</a>(begin(), size()); }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   <span class="comment">// predicates</span>
<a name="l00602"></a>00602 
<a name="l00603"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a5a4822e9fcf94ff55b28d18b2f9a9d6f">00603</a>   <span class="comment">//: Return true iff the size is zero.</span>
<a name="l00604"></a>00604   <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> num_rows==0 &amp;&amp; num_cols==0; }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="comment">//:  Return true if all elements equal to identity.</span>
<a name="l00607"></a>00607   <span class="keywordtype">bool</span> is_identity() <span class="keyword">const</span>;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   <span class="comment">//:  Return true if all elements equal to identity, within given tolerance</span>
<a name="l00610"></a>00610   <span class="keywordtype">bool</span> is_identity(<span class="keywordtype">double</span> tol) <span class="keyword">const</span>;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="comment">//: Return true if all elements equal to zero.</span>
<a name="l00613"></a>00613   <span class="keywordtype">bool</span> is_zero() <span class="keyword">const</span>;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="comment">//: Return true if all elements equal to zero, within given tolerance</span>
<a name="l00616"></a>00616   <span class="keywordtype">bool</span> is_zero(<span class="keywordtype">double</span> tol) <span class="keyword">const</span>;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618   <span class="comment">//: Return true if finite</span>
<a name="l00619"></a>00619   <span class="keywordtype">bool</span> is_finite() <span class="keyword">const</span>;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   <span class="comment">//: Return true if matrix contains NaNs</span>
<a name="l00622"></a>00622   <span class="keywordtype">bool</span> has_nans() <span class="keyword">const</span>;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="comment">//: abort if size is not as expected</span>
<a name="l00625"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#acf7c46850ba5e31b3cf09d099370bbaf">00625</a>   <span class="comment">// This function does or tests nothing if NDEBUG is defined</span>
<a name="l00626"></a>00626   <span class="keywordtype">void</span> <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#acf7c46850ba5e31b3cf09d099370bbaf" title="abort if size is not as expected.">assert_size</a>(<span class="keywordtype">unsigned</span> nr_rows, <span class="keywordtype">unsigned</span> nr_cols)<span class="keyword"> const</span>
<a name="l00627"></a>00627 <span class="keyword">  </span>{
<a name="l00628"></a>00628 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00629"></a>00629 <span class="preprocessor"></span>    assert_size_internal(nr_rows, nr_cols);
<a name="l00630"></a>00630 <span class="preprocessor">#endif</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span>  }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   <span class="comment">//: abort if matrix contains any INFs or NANs.</span>
<a name="l00634"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa6e13d0bc4ec4d80de63eeb4e87db5e7">00634</a>   <span class="comment">// This function does or tests nothing if NDEBUG is defined</span>
<a name="l00635"></a>00635   <span class="keywordtype">void</span> <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa6e13d0bc4ec4d80de63eeb4e87db5e7" title="abort if matrix contains any INFs or NANs.">assert_finite</a>()<span class="keyword"> const</span>
<a name="l00636"></a>00636 <span class="keyword">  </span>{
<a name="l00637"></a>00637 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00638"></a>00638 <span class="preprocessor"></span>    assert_finite_internal();
<a name="l00639"></a>00639 <span class="preprocessor">#endif</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span>  }
<a name="l00641"></a>00641 <span class="comment"></span>
<a name="l00642"></a>00642 <span class="comment">  ////----------------------- Input/Output ----------------------------</span>
<a name="l00643"></a>00643 <span class="comment"></span>
<a name="l00644"></a>00644   <span class="comment">// : Read a vnl_matrix from an ascii vcl_istream, automatically determining file size if the input matrix has zero size.</span>
<a name="l00645"></a>00645   <span class="keywordtype">bool</span> read_ascii(vcl_istream&amp; s);
<a name="l00646"></a>00646 
<a name="l00647"></a>00647   <span class="comment">//--------------------------------------------------------------------------------</span>
<a name="l00648"></a>00648 
<a name="l00649"></a>00649   <span class="comment">//: Access the contiguous block storing the elements in the matrix row-wise. O(1).</span>
<a name="l00650"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a20307c4067e8b342c0ca570a1bd82593">00650</a>   <span class="comment">// 1d array, row-major order.</span>
<a name="l00651"></a>00651   T <span class="keyword">const</span>* data_block ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_[0]; }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <span class="comment">//: Access the contiguous block storing the elements in the matrix row-wise. O(1).</span>
<a name="l00654"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aabc5cab78f7a79b2fe0610d318ee8e1a">00654</a>   <span class="comment">// 1d array, row-major order.</span>
<a name="l00655"></a>00655   T      * data_block () { <span class="keywordflow">return</span> data_[0]; }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <span class="comment">//----------------------------------------------------------------------</span>
<a name="l00659"></a>00659   <span class="comment">// Conversion to vnl_matrix_ref.</span>
<a name="l00660"></a>00660 
<a name="l00661"></a>00661   <span class="comment">// The const version of as_ref should return a const vnl_matrix_ref</span>
<a name="l00662"></a>00662   <span class="comment">// so that the vnl_matrix_ref::non_const() cannot be used on</span>
<a name="l00663"></a>00663   <span class="comment">// it. This prevents a const vnl_matrix_fixed from being cast into a</span>
<a name="l00664"></a>00664   <span class="comment">// non-const vnl_matrix reference, giving a slight increase in type safety.</span>
<a name="l00665"></a>00665 
<a name="l00666"></a>00666   <span class="comment">//: Explicit conversion to a vnl_matrix_ref.</span>
<a name="l00667"></a>00667   <span class="comment">// This is a cheap conversion for those functions that have an interface</span>
<a name="l00668"></a>00668   <span class="comment">// for vnl_matrix but not for vnl_matrix_fixed. There is also a</span>
<a name="l00669"></a>00669   <span class="comment">// conversion operator that should work most of the time.</span>
<a name="l00670"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a8b31407ef0d7f48b2c17fa087862b3ee">00670</a>   <span class="comment">// \sa vnl_matrix_ref::non_const</span>
<a name="l00671"></a>00671   <a class="code" href="classvnl__matrix__ref.html" title="vnl_matrix reference to user-supplied storage.">vnl_matrix_ref&lt;T&gt;</a> as_ref() { <span class="keywordflow">return</span> <a class="code" href="classvnl__matrix__ref.html" title="vnl_matrix reference to user-supplied storage.">vnl_matrix_ref&lt;T&gt;</a>( num_rows, num_cols, data_block() ); }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   <span class="comment">//: Explicit conversion to a vnl_matrix_ref.</span>
<a name="l00674"></a>00674   <span class="comment">// This is a cheap conversion for those functions that have an interface</span>
<a name="l00675"></a>00675   <span class="comment">// for vnl_matrix but not for vnl_matrix_fixed. There is also a</span>
<a name="l00676"></a>00676   <span class="comment">// conversion operator that should work most of the time.</span>
<a name="l00677"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a9eb0dbbc7ae73ed766d033e794161f9a">00677</a>   <span class="comment">// \sa vnl_matrix_ref::non_const</span>
<a name="l00678"></a>00678   <span class="keyword">const</span> <a class="code" href="classvnl__matrix__ref.html" title="vnl_matrix reference to user-supplied storage.">vnl_matrix_ref&lt;T&gt;</a> as_ref()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__matrix__ref.html" title="vnl_matrix reference to user-supplied storage.">vnl_matrix_ref&lt;T&gt;</a>( num_rows, num_cols, <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(data_block()) ); }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   <span class="comment">//: Cheap conversion to vnl_matrix_ref</span>
<a name="l00681"></a>00681   <span class="comment">// Sometimes, such as with templated functions, the compiler cannot</span>
<a name="l00682"></a>00682   <span class="comment">// use this user-defined conversion. For those cases, use the</span>
<a name="l00683"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aedd0b120a525ab892a50ba5ec865dc5f">00683</a>   <span class="comment">// explicit as_ref() method instead.</span>
<a name="l00684"></a>00684   operator const vnl_matrix_ref&lt;T&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__matrix__ref.html" title="vnl_matrix reference to user-supplied storage.">vnl_matrix_ref&lt;T&gt;</a>( num_rows, num_cols, <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(data_block()) ); }
<a name="l00685"></a>00685 
<a name="l00686"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a299bdb305073febd246dd033aae9914f">00686</a>   <span class="comment">//: Convert to a vnl_matrix.</span>
<a name="l00687"></a>00687   <span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> as_matrix()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>(<span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(data_block()),num_rows,num_cols); }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   <span class="comment">//----------------------------------------------------------------------</span>
<a name="l00690"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a8e51776e2db32eccedac519abeccb0be">00690</a> 
<a name="l00691"></a>00691   <span class="keyword">typedef</span> T <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a8e51776e2db32eccedac519abeccb0be">element_type</a>;
<a name="l00692"></a>00692 
<a name="l00693"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa449724bf5b1a8ee7bbcebe5733ed60c">00693</a>   <span class="comment">//: Iterators</span>
<a name="l00694"></a>00694   <span class="keyword">typedef</span> T       *<a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa449724bf5b1a8ee7bbcebe5733ed60c" title="Iterators.">iterator</a>;
<a name="l00695"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa5aeda27109668e94f0e7dc7c599eb46">00695</a>   <span class="comment">//: Iterator pointing to start of data</span>
<a name="l00696"></a>00696   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa449724bf5b1a8ee7bbcebe5733ed60c" title="Iterators.">iterator</a>       begin() { <span class="keywordflow">return</span> data_[0]; }
<a name="l00697"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a92665cc138a76f5e55df0e698ee8055e">00697</a>   <span class="comment">//: Iterator pointing to element beyond end of data</span>
<a name="l00698"></a>00698   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa449724bf5b1a8ee7bbcebe5733ed60c" title="Iterators.">iterator</a>       end() { <span class="keywordflow">return</span> begin() + size(); }
<a name="l00699"></a>00699 
<a name="l00700"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a2b6b193a1916aef50b0e0fb2d52ad22b">00700</a>   <span class="comment">//: Const iterators</span>
<a name="l00701"></a>00701   <span class="keyword">typedef</span> T <span class="keyword">const</span> *<a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a2b6b193a1916aef50b0e0fb2d52ad22b" title="Const iterators.">const_iterator</a>;
<a name="l00702"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa6015f5fe36674cabb1120a70b920d09">00702</a>   <span class="comment">//: Iterator pointing to start of data</span>
<a name="l00703"></a>00703   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a2b6b193a1916aef50b0e0fb2d52ad22b" title="Const iterators.">const_iterator</a> begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_[0]; }
<a name="l00704"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a8b26caeabbcb7a1f07bf2542fa56b17c">00704</a>   <span class="comment">//: Iterator pointing to element beyond end of data</span>
<a name="l00705"></a>00705   <a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a2b6b193a1916aef50b0e0fb2d52ad22b" title="Const iterators.">const_iterator</a> end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> begin() + size(); }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="comment">//--------------------------------------------------------------------------------</span>
<a name="l00708"></a>00708 
<a name="l00709"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a0386e6725356b54419af79ac461b8339">00709</a>   <span class="comment">//: Return true if *this == rhs</span>
<a name="l00710"></a>00710   <span class="keywordtype">bool</span> operator_eq (vnl_matrix_fixed <span class="keyword">const</span> &amp; rhs)<span class="keyword"> const</span>
<a name="l00711"></a>00711 <span class="keyword">  </span>{
<a name="l00712"></a>00712     <span class="keywordflow">return</span> equal( this-&gt;data_block(), rhs.data_block() );
<a name="l00713"></a>00713   }
<a name="l00714"></a>00714 
<a name="l00715"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a5565dd6ccb137d3078c5404924a54280">00715</a>   <span class="comment">//: Equality operator</span>
<a name="l00716"></a>00716   <span class="keywordtype">bool</span> <a class="code" href="vnl__amoeba_8cxx.html#a7595ee1332f48b828d6179c7c5b08c44">operator==</a>(vnl_matrix_fixed <span class="keyword">const</span> &amp;that)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>  this-&gt;operator_eq(that); }
<a name="l00717"></a>00717 
<a name="l00718"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#ac907fb87cacba23021dc1b71b758b20b">00718</a>   <span class="comment">//: Inequality operator</span>
<a name="l00719"></a>00719   <span class="keywordtype">bool</span> <a class="code" href="vnl__bignum_8h.html#abaeae437ee325d201bc8d03931d7323e">operator!=</a>(vnl_matrix_fixed <span class="keyword">const</span> &amp;that)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !this-&gt;operator_eq(that); }
<a name="l00720"></a>00720 
<a name="l00721"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#a9a017a40d82eb3d80fc79d90f46966c7">00721</a>   <span class="comment">//: Equality operator</span>
<a name="l00722"></a>00722   <span class="keywordtype">bool</span> <a class="code" href="vnl__amoeba_8cxx.html#a7595ee1332f48b828d6179c7c5b08c44">operator==</a>(<a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <span class="keyword">const</span> &amp;that)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>  this-&gt;operator_eq(that); }
<a name="l00723"></a>00723 
<a name="l00724"></a><a class="code" href="classVNL__MATRIX__FIXED__VCL60__WORKAROUND.html#aa64e20721332b0bb702780c848ae641e">00724</a>   <span class="comment">//: Inequality operator</span>
<a name="l00725"></a>00725   <span class="keywordtype">bool</span> <a class="code" href="vnl__bignum_8h.html#abaeae437ee325d201bc8d03931d7323e">operator!=</a>(<a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <span class="keyword">const</span> &amp;that)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !this-&gt;operator_eq(that); }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="comment">//: Print matrix to os in some hopefully sensible format</span>
<a name="l00728"></a>00728   <span class="keywordtype">void</span> print(vcl_ostream&amp; os) <span class="keyword">const</span>;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730 <span class="comment">//--------------------------------------------------------------------------------</span>
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 
<a name="l00733"></a>00733   <span class="comment">// Helper routines for arithmetic. These routines know the size from</span>
<a name="l00734"></a>00734   <span class="comment">// the template parameters. The vector-vector operations are</span>
<a name="l00735"></a>00735   <span class="comment">// element-wise.</span>
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">add</a>( <span class="keyword">const</span> T* a, <span class="keyword">const</span> T* b, T* r );
<a name="l00738"></a>00738   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">add</a>( <span class="keyword">const</span> T* a, T b, T* r );
<a name="l00739"></a>00739   <span class="keyword">static</span> <span class="keywordtype">void</span> sub( <span class="keyword">const</span> T* a, <span class="keyword">const</span> T* b, T* r );
<a name="l00740"></a>00740   <span class="keyword">static</span> <span class="keywordtype">void</span> sub( <span class="keyword">const</span> T* a, T b, T* r );
<a name="l00741"></a>00741   <span class="keyword">static</span> <span class="keywordtype">void</span> sub( T a, <span class="keyword">const</span> T* b, T* r );
<a name="l00742"></a>00742   <span class="keyword">static</span> <span class="keywordtype">void</span> mul( <span class="keyword">const</span> T* a, <span class="keyword">const</span> T* b, T* r );
<a name="l00743"></a>00743   <span class="keyword">static</span> <span class="keywordtype">void</span> mul( <span class="keyword">const</span> T* a, T b, T* r );
<a name="l00744"></a>00744   <span class="keyword">static</span> <span class="keywordtype">void</span> div( <span class="keyword">const</span> T* a, <span class="keyword">const</span> T* b, T* r );
<a name="l00745"></a>00745   <span class="keyword">static</span> <span class="keywordtype">void</span> div( <span class="keyword">const</span> T* a, T b, T* r );
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="keyword">static</span> <span class="keywordtype">bool</span> equal( <span class="keyword">const</span> T* a, <span class="keyword">const</span> T* b );
<a name="l00748"></a>00748 
<a name="l00749"></a>00749  <span class="keyword">private</span>:
<a name="l00750"></a>00750   <span class="keywordtype">void</span> assert_finite_internal() <span class="keyword">const</span>;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   <span class="keywordtype">void</span> assert_size_internal(<span class="keywordtype">unsigned</span>, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;
<a name="l00753"></a>00753 };
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 <span class="preprocessor">#undef VNL_MATRIX_FIXED_VCL60_WORKAROUND</span>
<a name="l00756"></a>00756 <span class="preprocessor"></span>
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 <span class="comment">// Make the operators below inline because (1) they are small and</span>
<a name="l00759"></a>00759 <span class="comment">// (2) we then have less explicit instantiation trouble.</span>
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 <span class="comment">// --- Matrix-scalar -------------------------------------------------------------</span>
<a name="l00763"></a>00763 
<a name="l00764"></a>00764 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00765"></a><a class="code" href="vnl__matrix__fixed_8h.html#a635cef78e3a0e8a5beb98d3132339c6c">00765</a> <span class="keyword">inline</span>
<a name="l00766"></a>00766 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a156e7963508bf8aa5407858bdd8de1a0" title="Returns the sum of two bignum numbers.">operator+</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat1, <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat2 )
<a name="l00767"></a>00767 {
<a name="l00768"></a>00768   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00769"></a>00769   <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">vnl_matrix_fixed&lt;T,m,n&gt;::add</a>( mat1.data_block(), mat2.data_block(), r.data_block() );
<a name="l00770"></a>00770   <span class="keywordflow">return</span> r;
<a name="l00771"></a>00771 }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00774"></a><a class="code" href="vnl__matrix__fixed_8h.html#ad4e3c63af0596420b318991188c8e8b5">00774</a> <span class="keyword">inline</span>
<a name="l00775"></a>00775 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a156e7963508bf8aa5407858bdd8de1a0" title="Returns the sum of two bignum numbers.">operator+</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat, T s )
<a name="l00776"></a>00776 {
<a name="l00777"></a>00777   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00778"></a>00778   <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">vnl_matrix_fixed&lt;T,m,n&gt;::add</a>( mat.data_block(), s, r.data_block() );
<a name="l00779"></a>00779   <span class="keywordflow">return</span> r;
<a name="l00780"></a>00780 }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00783"></a><a class="code" href="vnl__matrix__fixed_8h.html#a1c9061916b5bb17fd4c57e0fd2a2d7a0">00783</a> <span class="keyword">inline</span>
<a name="l00784"></a>00784 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a156e7963508bf8aa5407858bdd8de1a0" title="Returns the sum of two bignum numbers.">operator+</a>( <span class="keyword">const</span> T&amp; s,
<a name="l00785"></a>00785                                    <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat )
<a name="l00786"></a>00786 {
<a name="l00787"></a>00787   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00788"></a>00788   <a class="code" href="vnl__bignum_8cxx.html#a19c8917d449fe18d6eb6d381b6979d86" title="add two non-infinite vnl_bignum values and save their sum.">vnl_matrix_fixed&lt;T,m,n&gt;::add</a>( mat.data_block(), s, r.data_block() );
<a name="l00789"></a>00789   <span class="keywordflow">return</span> r;
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00793"></a><a class="code" href="vnl__matrix__fixed_8h.html#a4f6f7acc9d060e833b679b5c01bcbf62">00793</a> <span class="keyword">inline</span>
<a name="l00794"></a>00794 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a85b79ded6b4c572653e806446976b611" title="Returns the difference of two bignum numbers.">operator-</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat1, <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat2 )
<a name="l00795"></a>00795 {
<a name="l00796"></a>00796   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00797"></a>00797   vnl_matrix_fixed&lt;T,m,n&gt;::sub( mat1.data_block(), mat2.data_block(), r.data_block() );
<a name="l00798"></a>00798   <span class="keywordflow">return</span> r;
<a name="l00799"></a>00799 }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00802"></a><a class="code" href="vnl__matrix__fixed_8h.html#adc94ede9a406939d7cf1b437b5ac8a6a">00802</a> <span class="keyword">inline</span>
<a name="l00803"></a>00803 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a85b79ded6b4c572653e806446976b611" title="Returns the difference of two bignum numbers.">operator-</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat, T s )
<a name="l00804"></a>00804 {
<a name="l00805"></a>00805   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00806"></a>00806   vnl_matrix_fixed&lt;T,m,n&gt;::sub( mat.data_block(), s, r.data_block() );
<a name="l00807"></a>00807   <span class="keywordflow">return</span> r;
<a name="l00808"></a>00808 }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00811"></a><a class="code" href="vnl__matrix__fixed_8h.html#a41c42c1910e09ce10782c5b0c974f23b">00811</a> <span class="keyword">inline</span>
<a name="l00812"></a>00812 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a85b79ded6b4c572653e806446976b611" title="Returns the difference of two bignum numbers.">operator-</a>( <span class="keyword">const</span> T&amp; s,
<a name="l00813"></a>00813                                    <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat )
<a name="l00814"></a>00814 {
<a name="l00815"></a>00815   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00816"></a>00816   vnl_matrix_fixed&lt;T,m,n&gt;::sub( s, mat.data_block(), r.data_block() );
<a name="l00817"></a>00817   <span class="keywordflow">return</span> r;
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00821"></a><a class="code" href="vnl__matrix__fixed_8h.html#ad7cfa13c4d7e3a537b6795f8f4235cba">00821</a> <span class="keyword">inline</span>
<a name="l00822"></a>00822 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat, T s )
<a name="l00823"></a>00823 {
<a name="l00824"></a>00824   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00825"></a>00825   vnl_matrix_fixed&lt;T,m,n&gt;::mul( mat.data_block(), s, r.data_block() );
<a name="l00826"></a>00826   <span class="keywordflow">return</span> r;
<a name="l00827"></a>00827 }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00830"></a><a class="code" href="vnl__matrix__fixed_8h.html#aeb362c00d8ef372799d1e18dd35f5c63">00830</a> <span class="keyword">inline</span>
<a name="l00831"></a>00831 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>( <span class="keyword">const</span> T&amp; s,
<a name="l00832"></a>00832                                    <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat )
<a name="l00833"></a>00833 {
<a name="l00834"></a>00834   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00835"></a>00835   vnl_matrix_fixed&lt;T,m,n&gt;::mul( mat.data_block(), s, r.data_block() );
<a name="l00836"></a>00836   <span class="keywordflow">return</span> r;
<a name="l00837"></a>00837 }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00840"></a><a class="code" href="vnl__matrix__fixed_8h.html#acab7114de783320a772af2e86117066d">00840</a> <span class="keyword">inline</span>
<a name="l00841"></a>00841 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__bignum.html#a3913778317c3f85f2b2c4ab0f302785f" title="Returns the division of two bignum numbers.">operator/</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat, T s )
<a name="l00842"></a>00842 {
<a name="l00843"></a>00843   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00844"></a>00844   vnl_matrix_fixed&lt;T,m,n&gt;::div( mat.data_block(), s, r.data_block() );
<a name="l00845"></a>00845   <span class="keywordflow">return</span> r;
<a name="l00846"></a>00846 }
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00850"></a><a class="code" href="vnl__matrix__fixed_8h.html#a94328befc8eec0acde5957ac4b4b905a">00850</a> <span class="keyword">inline</span>
<a name="l00851"></a>00851 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__vector__fixed.html#ac3e1898fadf8ffb5ae1c9f983ab24b00">element_product</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat1,
<a name="l00852"></a>00852                                          <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat2 )
<a name="l00853"></a>00853 {
<a name="l00854"></a>00854   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00855"></a>00855   vnl_matrix_fixed&lt;T,m,n&gt;::mul( mat1.data_block(), mat2.data_block(), r.data_block() );
<a name="l00856"></a>00856   <span class="keywordflow">return</span> r;
<a name="l00857"></a>00857 }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00861"></a><a class="code" href="vnl__matrix__fixed_8h.html#aca63897135378e7bace81c5ba619e59f">00861</a> <span class="keyword">inline</span>
<a name="l00862"></a>00862 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__vector__fixed.html#a7753d12e8c63f67739c36026256df263">element_quotient</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat1,
<a name="l00863"></a>00863                                           <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat2)
<a name="l00864"></a>00864 {
<a name="l00865"></a>00865   vnl_matrix_fixed&lt;T,m,n&gt; r;
<a name="l00866"></a>00866   vnl_matrix_fixed&lt;T,m,n&gt;::div( mat1.data_block(), mat2.data_block(), r.data_block() );
<a name="l00867"></a>00867   <span class="keywordflow">return</span> r;
<a name="l00868"></a>00868 }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870 
<a name="l00871"></a>00871 <span class="comment">// The following two functions are helper functions keep the</span>
<a name="l00872"></a>00872 <span class="comment">// matrix-matrix and matrix-vector multiplication code in one place,</span>
<a name="l00873"></a>00873 <span class="comment">// so that bug fixes, etc, can be localized.</span>
<a name="l00874"></a>00874 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N&gt;
<a name="l00875"></a>00875 <span class="keyword">inline</span>
<a name="l00876"></a><a class="code" href="vnl__matrix__fixed_8h.html#ac1f53c48975e700614581fc513254696">00876</a> <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T, M&gt;</a>
<a name="l00877"></a>00877 <a class="code" href="vnl__matrix__fixed_8h.html#ac1f53c48975e700614581fc513254696">vnl_matrix_fixed_mat_vec_mult</a>(<span class="keyword">const</span> vnl_matrix_fixed&lt;T, M, N&gt;&amp; a,
<a name="l00878"></a>00878                               <span class="keyword">const</span> <a class="code" href="classvnl__vector__fixed.html">vnl_vector_fixed&lt;T, N&gt;</a>&amp; b)
<a name="l00879"></a>00879 {
<a name="l00880"></a>00880   <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T, M&gt;</a> out;
<a name="l00881"></a>00881   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; M; ++i)
<a name="l00882"></a>00882   {
<a name="l00883"></a>00883     T accum = a(i,0) * b(0);
<a name="l00884"></a>00884     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 1; k &lt; N; ++k)
<a name="l00885"></a>00885       accum += a(i,k) * b(k);
<a name="l00886"></a>00886     out(i) = accum;
<a name="l00887"></a>00887   }
<a name="l00888"></a>00888   <span class="keywordflow">return</span> out;
<a name="l00889"></a>00889 }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N&gt;
<a name="l00892"></a>00892 <span class="keyword">inline</span>
<a name="l00893"></a><a class="code" href="vnl__matrix__fixed_8h.html#aa417f4b20f15e273f816746816ced21e">00893</a> <a class="code" href="classvnl__vector__fixed.html">vnl_vector_fixed&lt;T, N&gt;</a>
<a name="l00894"></a>00894 <a class="code" href="vnl__matrix__fixed_8h.html#aa417f4b20f15e273f816746816ced21e">vnl_matrix_fixed_vec_mat_mult</a>(<span class="keyword">const</span> <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T, M&gt;</a>&amp; a,
<a name="l00895"></a>00895                               <span class="keyword">const</span> vnl_matrix_fixed&lt;T, M, N&gt;&amp; b)
<a name="l00896"></a>00896 {
<a name="l00897"></a>00897   <a class="code" href="classvnl__vector__fixed.html">vnl_vector_fixed&lt;T, N&gt;</a> out;
<a name="l00898"></a>00898   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; N; ++i)
<a name="l00899"></a>00899   {
<a name="l00900"></a>00900     T accum = a(0) * b(0,i);
<a name="l00901"></a>00901     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 1; k &lt; M; ++k)
<a name="l00902"></a>00902       accum += a(k) * b(k,i);
<a name="l00903"></a>00903     out(i) = accum;
<a name="l00904"></a>00904   }
<a name="l00905"></a>00905   <span class="keywordflow">return</span> out;
<a name="l00906"></a>00906 }
<a name="l00907"></a>00907 
<a name="l00908"></a>00908 <span class="comment">// see comment above</span>
<a name="l00909"></a>00909 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N, <span class="keywordtype">unsigned</span> O&gt;
<a name="l00910"></a>00910 <span class="keyword">inline</span>
<a name="l00911"></a><a class="code" href="vnl__matrix__fixed_8h.html#a82b89b1bd951e088ffb3baf7a6059872">00911</a> vnl_matrix_fixed&lt;T, M, O&gt;
<a name="l00912"></a>00912 <a class="code" href="vnl__matrix__fixed_8h.html#a82b89b1bd951e088ffb3baf7a6059872">vnl_matrix_fixed_mat_mat_mult</a>(<span class="keyword">const</span> vnl_matrix_fixed&lt;T, M, N&gt;&amp; a,
<a name="l00913"></a>00913                               <span class="keyword">const</span> vnl_matrix_fixed&lt;T, N, O&gt;&amp; b)
<a name="l00914"></a>00914 {
<a name="l00915"></a>00915   vnl_matrix_fixed&lt;T, M, O&gt; out;
<a name="l00916"></a>00916   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; M; ++i)
<a name="l00917"></a>00917     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; O; ++j)
<a name="l00918"></a>00918     {
<a name="l00919"></a>00919       T accum = a(i,0) * b(0,j);
<a name="l00920"></a>00920       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 1; k &lt; N; ++k)
<a name="l00921"></a>00921         accum += a(i,k) * b(k,j);
<a name="l00922"></a>00922       out(i,j) = accum;
<a name="l00923"></a>00923     }
<a name="l00924"></a>00924   <span class="keywordflow">return</span> out;
<a name="l00925"></a>00925 }
<a name="l00926"></a>00926 
<a name="l00927"></a>00927 <span class="preprocessor">#ifndef VCL_VC_6</span>
<a name="l00928"></a>00928 <span class="preprocessor"></span><span class="comment">// The version for correct compilers</span>
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="comment">//: Multiply  conformant vnl_matrix_fixed (M x N) and vector_fixed (N)</span>
<a name="l00931"></a>00931 <span class="comment">// \relatesalso vnl_vector_fixed</span>
<a name="l00932"></a>00932 <span class="comment">// \relatesalso vnl_matrix_fixed</span>
<a name="l00933"></a>00933 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N&gt;
<a name="l00934"></a><a class="code" href="vnl__matrix__fixed_8h.html#a2bf2e47553615d221a369c428e8f89be">00934</a> <span class="keyword">inline</span>
<a name="l00935"></a>00935 <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T, M&gt;</a> <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>(<span class="keyword">const</span> vnl_matrix_fixed&lt;T, M, N&gt;&amp; a, <span class="keyword">const</span> <a class="code" href="classvnl__vector__fixed.html">vnl_vector_fixed&lt;T, N&gt;</a>&amp; b)
<a name="l00936"></a>00936 {
<a name="l00937"></a>00937   <span class="keywordflow">return</span> <a class="code" href="vnl__matrix__fixed_8h.html#ac1f53c48975e700614581fc513254696">vnl_matrix_fixed_mat_vec_mult</a>(a, b);
<a name="l00938"></a>00938 }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940 <span class="comment">//: Multiply  conformant vector_fixed (M) and vnl_matrix_fixed (M x N)</span>
<a name="l00941"></a>00941 <span class="comment">// \relatesalso vnl_vector_fixed</span>
<a name="l00942"></a>00942 <span class="comment">// \relatesalso vnl_matrix_fixed</span>
<a name="l00943"></a>00943 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N&gt;
<a name="l00944"></a><a class="code" href="vnl__matrix__fixed_8h.html#a93ea97d3f0094a53050a5d48d21b38d7">00944</a> <span class="keyword">inline</span>
<a name="l00945"></a>00945 <a class="code" href="classvnl__vector__fixed.html">vnl_vector_fixed&lt;T, N&gt;</a> <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>(<span class="keyword">const</span> <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T, M&gt;</a>&amp; a, <span class="keyword">const</span> vnl_matrix_fixed&lt;T, M, N&gt;&amp; b)
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947   <span class="keywordflow">return</span> <a class="code" href="vnl__matrix__fixed_8h.html#aa417f4b20f15e273f816746816ced21e">vnl_matrix_fixed_vec_mat_mult</a>(a, b);
<a name="l00948"></a>00948 }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950 <span class="comment">//: Multiply two conformant vnl_matrix_fixed (M x N) times (N x O)</span>
<a name="l00951"></a>00951 <span class="comment">// \relatesalso vnl_matrix_fixed</span>
<a name="l00952"></a>00952 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N, <span class="keywordtype">unsigned</span> O&gt;
<a name="l00953"></a><a class="code" href="vnl__matrix__fixed_8h.html#ac6b1febc018518aa3579cfdb8aa08351">00953</a> <span class="keyword">inline</span>
<a name="l00954"></a>00954 vnl_matrix_fixed&lt;T, M, O&gt; <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>(<span class="keyword">const</span> vnl_matrix_fixed&lt;T, M, N&gt;&amp; a, <span class="keyword">const</span> vnl_matrix_fixed&lt;T, N, O&gt;&amp; b)
<a name="l00955"></a>00955 {
<a name="l00956"></a>00956   <span class="keywordflow">return</span> <a class="code" href="vnl__matrix__fixed_8h.html#a82b89b1bd951e088ffb3baf7a6059872">vnl_matrix_fixed_mat_mat_mult</a>(a, b);
<a name="l00957"></a>00957 }
<a name="l00958"></a>00958 <span class="preprocessor">#endif // VCL_VC_6</span>
<a name="l00959"></a>00959 <span class="preprocessor"></span>
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="comment">// These overloads for the common case of mixing a fixed with a</span>
<a name="l00962"></a>00962 <span class="comment">// non-fixed. Because the operator* are templated, the fixed will not</span>
<a name="l00963"></a>00963 <span class="comment">// be automatically converted to a non-fixed-ref. These do it for you.</span>
<a name="l00964"></a>00964 
<a name="l00965"></a><a class="code" href="vnl__matrix__fixed_8h.html#aaebec715b4a52851f76db99250ef7f40">00965</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00966"></a>00966 <span class="keyword">inline</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <a class="code" href="classvnl__bignum.html#a156e7963508bf8aa5407858bdd8de1a0" title="Returns the sum of two bignum numbers.">operator+</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; a, <span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; b )
<a name="l00967"></a>00967 {
<a name="l00968"></a>00968   <span class="keywordflow">return</span> a.as_ref() + b;
<a name="l00969"></a>00969 }
<a name="l00970"></a>00970 
<a name="l00971"></a><a class="code" href="vnl__matrix__fixed_8h.html#a2373850b0ad81b2c28d0d2255a79da7b">00971</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00972"></a>00972 <span class="keyword">inline</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <a class="code" href="classvnl__bignum.html#a156e7963508bf8aa5407858bdd8de1a0" title="Returns the sum of two bignum numbers.">operator+</a>( <span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; a, <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; b )
<a name="l00973"></a>00973 {
<a name="l00974"></a>00974   <span class="keywordflow">return</span> a + b.as_ref();
<a name="l00975"></a>00975 }
<a name="l00976"></a>00976 
<a name="l00977"></a><a class="code" href="vnl__matrix__fixed_8h.html#ac19f1b7c7c3fa91c31390af14259c06f">00977</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00978"></a>00978 <span class="keyword">inline</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <a class="code" href="classvnl__bignum.html#a85b79ded6b4c572653e806446976b611" title="Returns the difference of two bignum numbers.">operator-</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; a, <span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; b )
<a name="l00979"></a>00979 {
<a name="l00980"></a>00980   <span class="keywordflow">return</span> a.as_ref() - b;
<a name="l00981"></a>00981 }
<a name="l00982"></a>00982 
<a name="l00983"></a><a class="code" href="vnl__matrix__fixed_8h.html#a435629730e91353ec568e5d1eaf01475">00983</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00984"></a>00984 <span class="keyword">inline</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <a class="code" href="classvnl__bignum.html#a85b79ded6b4c572653e806446976b611" title="Returns the difference of two bignum numbers.">operator-</a>( <span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; a, <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; b )
<a name="l00985"></a>00985 {
<a name="l00986"></a>00986   <span class="keywordflow">return</span> a - b.as_ref();
<a name="l00987"></a>00987 }
<a name="l00988"></a>00988 
<a name="l00989"></a><a class="code" href="vnl__matrix__fixed_8h.html#ab84fc7011071c6917971b05e02e56d2b">00989</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00990"></a>00990 <span class="keyword">inline</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; a, <span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; b )
<a name="l00991"></a>00991 {
<a name="l00992"></a>00992   <span class="keywordflow">return</span> a.as_ref() * b;
<a name="l00993"></a>00993 }
<a name="l00994"></a>00994 
<a name="l00995"></a><a class="code" href="vnl__matrix__fixed_8h.html#a3c3db0fa963979b7bb7264e0490a79b4">00995</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00996"></a>00996 <span class="keyword">inline</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a> <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>( <span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; a, <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; b )
<a name="l00997"></a>00997 {
<a name="l00998"></a>00998   <span class="keywordflow">return</span> a * b.as_ref();
<a name="l00999"></a>00999 }
<a name="l01000"></a>01000 
<a name="l01001"></a><a class="code" href="vnl__matrix__fixed_8h.html#aef8576b22bdc94ad32137a5186e925c0">01001</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l01002"></a>01002 <span class="keyword">inline</span> <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a> <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>( <span class="keyword">const</span> vnl_matrix_fixed&lt;T,m,n&gt;&amp; a, <span class="keyword">const</span> <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a>&amp; b )
<a name="l01003"></a>01003 {
<a name="l01004"></a>01004   <span class="keywordflow">return</span> a.as_ref() * b;
<a name="l01005"></a>01005 }
<a name="l01006"></a>01006 
<a name="l01007"></a><a class="code" href="vnl__matrix__fixed_8h.html#a822d0b21c185da2868fcb71b30de244a">01007</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> n&gt;
<a name="l01008"></a>01008 <span class="keyword">inline</span> <a class="code" href="classvnl__vector.html" title="Mathematical vector class, templated by type of element.">vnl_vector&lt;T&gt;</a> <a class="code" href="classvnl__bignum.html#a02e48dba7a541b67bec3b91669a788be" title="Returns the product of two bignum numbers.">operator*</a>( <span class="keyword">const</span> <a class="code" href="classvnl__matrix.html" title="An ordinary mathematical matrix.">vnl_matrix&lt;T&gt;</a>&amp; a, <span class="keyword">const</span> <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,n&gt;</a>&amp; b )
<a name="l01009"></a>01009 {
<a name="l01010"></a>01010   <span class="keywordflow">return</span> a * b.<a class="code" href="classvnl__vector__fixed.html#a442efcf1abd662857298990f29879cc1" title="Explicit conversion to a vnl_vector_ref.">as_ref</a>();
<a name="l01011"></a>01011 }
<a name="l01012"></a>01012 
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 <span class="comment">// --- I/O operations ------------------------------------------------------------</span>
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l01017"></a><a class="code" href="vnl__matrix__fixed_8h.html#a23026380def92629331b552494cb9772">01017</a> <span class="keyword">inline</span>
<a name="l01018"></a>01018 vcl_ostream&amp; operator&lt;&lt; (vcl_ostream&amp; os, vnl_matrix_fixed&lt;T,m,n&gt; <span class="keyword">const</span>&amp; mat)
<a name="l01019"></a>01019 {
<a name="l01020"></a>01020   mat.print(os);
<a name="l01021"></a>01021   <span class="keywordflow">return</span> os;
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l01025"></a><a class="code" href="vnl__matrix__fixed_8h.html#a4741f8837627725668d653b7b22eea61">01025</a> <span class="keyword">inline</span>
<a name="l01026"></a>01026 vcl_istream&amp; <a class="code" href="classvnl__decnum.html#ab34c8cf6db48769ec7d6cbd00f68b6af" title="decimal input.">operator&gt;&gt; </a>(vcl_istream&amp; is, vnl_matrix_fixed&lt;T,m,n&gt;&amp; mat)
<a name="l01027"></a>01027 {
<a name="l01028"></a>01028   mat.read_ascii(is);
<a name="l01029"></a>01029   <span class="keywordflow">return</span> is;
<a name="l01030"></a>01030 }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="comment">// More workarounds for Visual C++ 6.0. The problem is that VC6 cannot</span>
<a name="l01033"></a>01033 <span class="comment">// automatically determine the m of the second parameter, for some</span>
<a name="l01034"></a>01034 <span class="comment">// reason. Also, VC6 can&#39;t figure out that vector_fixed::SIZE is a</span>
<a name="l01035"></a>01035 <span class="comment">// compile time constant when used in the return parameter. So, we</span>
<a name="l01036"></a>01036 <span class="comment">// have to introduce a helper class to do it.</span>
<a name="l01037"></a>01037 <span class="comment">//</span>
<a name="l01038"></a>01038 <span class="preprocessor">#if defined(VCL_VC_6) &amp;&amp; !defined(__GCCXML__)</span>
<a name="l01039"></a>01039 <span class="preprocessor"></span>
<a name="l01040"></a>01040 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keyword">class</span> FixedVector&gt;
<a name="l01041"></a>01041 <span class="keyword">struct </span>outer_product_fixed_type_helper
<a name="l01042"></a>01042 {
<a name="l01043"></a>01043   <span class="keyword">typedef</span> vnl_matrix_fixed&lt;T,m,FixedVector::SIZE&gt; result_matrix;
<a name="l01044"></a>01044 };
<a name="l01045"></a>01045 
<a name="l01046"></a>01046 <span class="keyword">template</span>&lt;<span class="keyword">class</span> V1, <span class="keyword">class</span> V2, <span class="keyword">class</span> RM&gt;
<a name="l01047"></a>01047 <span class="keyword">struct </span>outer_product_fixed_calc_helper
<a name="l01048"></a>01048 {
<a name="l01049"></a>01049   <span class="keyword">static</span> RM calc( V1 <span class="keyword">const</span>&amp; a, V2 <span class="keyword">const</span>&amp; b );
<a name="l01050"></a>01050 };
<a name="l01051"></a>01051 
<a name="l01052"></a>01052 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keyword">class</span> SecondFixedVector&gt;
<a name="l01053"></a>01053 outer_product_fixed_type_helper&lt;T,m,SecondFixedVector&gt;::result_matrix
<a name="l01054"></a>01054 <a class="code" href="classvnl__vector__fixed.html#a0cc5d421ea334a8feac696d7385d4a8e">outer_product</a>(<a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,m&gt;</a> <span class="keyword">const</span>&amp; a, SecondFixedVector <span class="keyword">const</span>&amp; b)
<a name="l01055"></a>01055 {
<a name="l01056"></a>01056   <span class="keyword">typedef</span> <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,m&gt;</a> VecA;
<a name="l01057"></a>01057   <span class="keyword">typedef</span> <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,SecondFixedVector::SIZE&gt;</a> VecB;
<a name="l01058"></a>01058   <span class="keyword">typedef</span> outer_product_fixed_type_helper&lt;T,m,SecondFixedVector&gt;::result_matrix ResultMat;
<a name="l01059"></a>01059   <span class="keywordflow">return</span> outer_product_fixed_calc_helper&lt;VecA,VecB,ResultMat&gt;::calc(a,b);
<a name="l01060"></a>01060 }
<a name="l01061"></a>01061 
<a name="l01062"></a>01062 <span class="preprocessor">#else // no need for VC6 workaround for outer_product</span>
<a name="l01063"></a>01063 <span class="preprocessor"></span>
<a name="l01064"></a>01064 <span class="comment">//:</span>
<a name="l01065"></a>01065 <span class="comment">// \relatesalso vnl_vector_fixed</span>
<a name="l01066"></a>01066 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n&gt;
<a name="l01067"></a>01067 vnl_matrix_fixed&lt;T,m,n&gt; <a class="code" href="classvnl__vector__fixed.html#a0cc5d421ea334a8feac696d7385d4a8e">outer_product</a>(<a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,m&gt;</a> <span class="keyword">const</span>&amp; a, <a class="code" href="classvnl__vector__fixed.html" title="Fixed length stack-stored, space-efficient vector.">vnl_vector_fixed&lt;T,n&gt;</a> <span class="keyword">const</span>&amp; b);
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 <span class="preprocessor">#endif // VC6 workaround for outer_product</span>
<a name="l01070"></a><a class="code" href="vnl__matrix__fixed_8h.html#a11a7670aafd3b0be9f83836b26b918db">01070</a> <span class="preprocessor"></span>
<a name="l01071"></a>01071 <span class="preprocessor">#define VNL_MATRIX_FIXED_INSTANTIATE(T, M, N) \</span>
<a name="l01072"></a>01072 <span class="preprocessor">extern &quot;please include vnl/vnl_matrix_fixed.txx instead&quot;</span>
<a name="l01073"></a>01073 <span class="preprocessor"></span>
<a name="l01074"></a>01074 <span class="preprocessor">#endif // vnl_matrix_fixed_h_</span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:31:01 for core/vnl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
