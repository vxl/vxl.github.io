<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>vnl_sparse_lst_sqr_function Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">vnl_sparse_lst_sqr_function Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="vnl_sparse_lst_sqr_function" -->
<p>Abstract base for sparse least squares functions.  
 <a href="classvnl__sparse__lst__sqr__function.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>&gt;</code></p>

<p><a href="classvnl__sparse__lst__sqr__function-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569b">UseGradient</a> { <a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569bae990b02cef098d80b5c2dd4ee6dcc777">no_gradient</a>, 
<a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569baada1fa7cbbec1030915b57b0dc34bca1">use_gradient</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1b">UseWeights</a> { <a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1ba2ee7ea7ab050e13d076db90812394491">no_weights</a>, 
<a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1ba2eaadae26a2fe24eef761c05bbd2aa78">use_weights</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a225d1f672a902804ee875c2068115742">vnl_sparse_lst_sqr_function</a> (unsigned int num_a, unsigned int num_params_per_a, unsigned int num_b, unsigned int num_params_per_b, unsigned int num_params_c, unsigned int num_residuals_per_e, <a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569b">UseGradient</a> g=use_gradient, <a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1b">UseWeights</a> w=no_weights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="classvnl__sparse__lst__sqr__function.html" title="Abstract base for sparse least squares functions.">vnl_sparse_lst_sqr_function</a>.  <a href="#a225d1f672a902804ee875c2068115742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#af4b03e3a8fd78244d1e300be537a5beb">vnl_sparse_lst_sqr_function</a> (unsigned int num_a, unsigned int num_params_per_a, unsigned int num_b, unsigned int num_params_per_b, unsigned int num_params_c, const vcl_vector&lt; vcl_vector&lt; bool &gt; &gt; &amp;xmask, unsigned int num_residuals_per_e, <a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569b">UseGradient</a> g=use_gradient, <a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1b">UseWeights</a> w=no_weights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="classvnl__sparse__lst__sqr__function.html" title="Abstract base for sparse least squares functions.">vnl_sparse_lst_sqr_function</a>.  <a href="#af4b03e3a8fd78244d1e300be537a5beb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a6a9ca98cf4b5bd9bc12aab1e8169febd">vnl_sparse_lst_sqr_function</a> (const vcl_vector&lt; unsigned int &gt; &amp;a_sizes, const vcl_vector&lt; unsigned int &gt; &amp;b_sizes, unsigned int num_params_c, const vcl_vector&lt; unsigned int &gt; &amp;e_sizes, const vcl_vector&lt; vcl_vector&lt; bool &gt; &gt; &amp;xmask, <a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569b">UseGradient</a> g=use_gradient, <a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1b">UseWeights</a> w=no_weights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="classvnl__sparse__lst__sqr__function.html" title="Abstract base for sparse least squares functions.">vnl_sparse_lst_sqr_function</a>.  <a href="#a6a9ca98cf4b5bd9bc12aab1e8169febd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a95a99527b961ffdfe04174dfc6c06f4e">~vnl_sparse_lst_sqr_function</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a732102ffae0e6edf6bdc4f055c69d870">throw_failure</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a58a26cbe2fc962addf77c048a85629a7">clear_failure</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a6565a0886db607a05d919ce441f46760">f</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;a, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;b, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all residuals.  <a href="#a6565a0886db607a05d919ce441f46760"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#adff5800a571932385afcb3b05e581cf7">jac_blocks</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;a, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;b, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;A, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;B, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sparse Jacobian in block form.  <a href="#adff5800a571932385afcb3b05e581cf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#ac4f5d5929317eee273e899941d293a26">fd_jac_blocks</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;a, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;b, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;A, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;B, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;C, double stepsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sparse Jacobian in block form using a finite difference approximation.  <a href="#ac4f5d5929317eee273e899941d293a26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a356cde9f3976a10132aa29d0a560c4f0">compute_weights</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;a, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;b, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;f, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;weights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If using weighted least squares, compute the weights for each i and j.  <a href="#a356cde9f3976a10132aa29d0a560c4f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a63940159f2acf016c9d0f54ca418dc15">apply_weights</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;weights, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If using weighted least squares, apply the weights to residuals f.  <a href="#a63940159f2acf016c9d0f54ca418dc15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a1c07d9c723d8983cbd38121a1dde8eab">apply_weights</a> (<a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;weights, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;A, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;B, vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If using weighted least squares, apply the weights to residuals A, B, C.  <a href="#a1c07d9c723d8983cbd38121a1dde8eab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#ae1b137070a9669a787496318e46e4e32">fij</a> (int i, int j, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;ai, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;bj, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;fij)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the residuals from the ith component of a, the jth component of b.  <a href="#ae1b137070a9669a787496318e46e4e32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#ab88e96eb149a1d3229cf66db3451d735">jac_Aij</a> (int i, int j, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;ai, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;bj, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Aij)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Jacobian A_ij, given the parameter vectors a_i, b_j, and c.  <a href="#ab88e96eb149a1d3229cf66db3451d735"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a96b00b8b39c9eff4942e95e429e6ceb4">jac_Bij</a> (int i, int j, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;ai, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;bj, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Bij)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Jacobian B_ij, given the parameter vectors a_i, b_j, and c.  <a href="#a96b00b8b39c9eff4942e95e429e6ceb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#ae41fd717f560d32cc54db7e792c48097">jac_Cij</a> (int i, int j, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;ai, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;bj, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Cij)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Jacobian C_ij, given the parameter vectors a_i, b_j, and c.  <a href="#ae41fd717f560d32cc54db7e792c48097"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a8c127c146ce432e5127cf2d64bc35e69">fd_jac_Aij</a> (int i, int j, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;ai, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;bj, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Aij, double stepsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to compute a finite-difference Jacobian A_ij.  <a href="#a8c127c146ce432e5127cf2d64bc35e69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a33fc3a31764ec77f73f0de76a14bfd4e">fd_jac_Bij</a> (int i, int j, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;ai, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;bj, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Bij, double stepsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to compute a finite-difference Jacobian B_ij.  <a href="#a33fc3a31764ec77f73f0de76a14bfd4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#af3d9e54aa97792cccd80d84d2f283e6c">fd_jac_Cij</a> (int i, int j, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;ai, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;bj, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Cij, double stepsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to compute a finite-difference Jacobian C_ij.  <a href="#af3d9e54aa97792cccd80d84d2f283e6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a9149a338304dcbcafcf4d752e7dcd794">compute_weight_ij</a> (int i, int j, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;ai, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;bj, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;fij, double &amp;weight)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If using weighted least squares, compute the weight.  <a href="#a9149a338304dcbcafcf4d752e7dcd794"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#aebab45fe35aa501378fdc110718c3eda">apply_weight_ij</a> (int i, int j, double const &amp;weight, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;fij)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If using weighted least squares, apply the weight to fij.  <a href="#aebab45fe35aa501378fdc110718c3eda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a66aed4a3d6434bde5871270086df8ec8">apply_weight_ij</a> (int i, int j, double const &amp;weight, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Aij, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Bij, <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;Cij)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If using weighted least squares, apply the weight to Aij, Bij, Cij.  <a href="#a66aed4a3d6434bde5871270086df8ec8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#ac281578ff13d6c946f7e7317b94d3d4a">trace</a> (int iteration, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;a, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;b, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;c, <a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after each LM iteration to print debugging etc.  <a href="#ac281578ff13d6c946f7e7317b94d3d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#aa650f3c88ffb9139d6ddcc8f92df95fb">number_of_params_a</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of parameters of a_j.  <a href="#aa650f3c88ffb9139d6ddcc8f92df95fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a2dd2b63684e8e57d9251301f236e77eb">number_of_params_b</a> (int j) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of parameters of b_i.  <a href="#a2dd2b63684e8e57d9251301f236e77eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a31141bf3b8a59f45c2e6fc2f81bc8fc0">number_of_params_c</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of parameters of c.  <a href="#a31141bf3b8a59f45c2e6fc2f81bc8fc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a9a28f2234d336f4b07947b8f073f3fb9">number_of_residuals</a> (int k) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of residuals in the kth residual vector.  <a href="#a9a28f2234d336f4b07947b8f073f3fb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#ab7bfa3612f71086cfa33bbaef48bb8a1">number_of_residuals</a> (int i, int j) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of residuals for x_ij.  <a href="#ab7bfa3612f71086cfa33bbaef48bb8a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a215ac902994bd0298c6cc73f6026759e">index_a</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of aj in a.  <a href="#a215ac902994bd0298c6cc73f6026759e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a74039f92584458ff8c467f527040d452">index_b</a> (int j) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of bj in b.  <a href="#a74039f92584458ff8c467f527040d452"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a2c743c05572c84195e9228e7ce60cc1c">index_e</a> (int k) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return the index of ek in e.  <a href="#a2c743c05572c84195e9228e7ce60cc1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a428a60bdd3d570cf65830e023098e326">number_of_a</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of subsets in <code>a</code>.  <a href="#a428a60bdd3d570cf65830e023098e326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a2d05703e2e6d74c664fae276eb36a1cc">number_of_b</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of subsets in <code>b</code>.  <a href="#a2d05703e2e6d74c664fae276eb36a1cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a2dcfccfbc708881b8175b6ba5f94c714">number_of_e</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of residual vectors.  <a href="#a2dcfccfbc708881b8175b6ba5f94c714"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#acf5e879631deb53038845ba96a9966e1">has_gradient</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the derived class has indicated that gradf has been implemented.  <a href="#acf5e879631deb53038845ba96a9966e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a20a59da3a46d858ac16ccc216c81cffe">has_weights</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the derived class has indicated that.  <a href="#a20a59da3a46d858ac16ccc216c81cffe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvnl__crs__index.html">vnl_crs_index</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a97ed08f452aedd332dc5c866b989f4db">residual_indices</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the residual indexer.  <a href="#a97ed08f452aedd332dc5c866b989f4db"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a99c2bebcb079e853dfe7f987587dd388">failure</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvnl__crs__index.html">vnl_crs_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a77c2fb0d7101cc684355b3864986245a">residual_indices_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#ad8329c3baac4945d1ce25459099ebf7d">indices_a_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a06227e084dcad9fb1466157c707d7957">indices_b_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a406557f256f3c6314873711d1962fe7a">num_params_c_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vcl_vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a33c0f6bdc5d5030572564196230ba2d0">indices_e_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a48891bf8a98a10b997285de1b6b16e22">use_gradient_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a96dae044f302cc38200f41a3d442760e">use_weights_</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvnl__sparse__lst__sqr__function.html#aa55b48507415b9893dad3cc0c727fbbd">dim_warning</a> (unsigned int n_unknowns, unsigned int n_residuals)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Abstract base for sparse least squares functions. </p>
<p><a class="el" href="classvnl__sparse__lst__sqr__function.html" title="Abstract base for sparse least squares functions.">vnl_sparse_lst_sqr_function</a> is an abstract base for functions to be minimized by an optimizer. To define your own function to be minimized, subclass from <a class="el" href="classvnl__sparse__lst__sqr__function.html" title="Abstract base for sparse least squares functions.">vnl_sparse_lst_sqr_function</a>, and implement the pure virtual f (and optionally grad_f).</p>
<p>This differs from a <a class="el" href="classvnl__least__squares__function.html" title="Abstract base for minimising functions.">vnl_least_squares_function</a> in that many entries in the Jacobian are known to be zero, and we don't want to compute them. The particular sparse structure is that described in Hartley and Zisserman section A4.3. It is assumed that the parameter vector can be partitioned into sets A and B. These are further partitioned into subsets {a_1, a_2, ... a_m} and {b_1, b_2, ... b_n}. Likewise, the residual vector X is partitioned into {x_11, x_12, ... x_mn} (not all x_ij are required). We further assume that dx_ij/da_k = 0 for all i != k and dx_ij/db_k = 0 for all j != k.</p>
<p>This implementation further generalizes the concept by allowing for a third set of parameters C that are non-sparse. That is, dx_ij/dC != 0 for all i and j (in general).</p>
<p>An example use case is bundle adjustment where each a_i is the parameters for one of m cameras, each b_j is the parameters of a 3D point, and x_ij is the projection error of the jth point by the ith camera. If type C parameters are used, they might represent the unknown intrinic camera parameters that are assumed to be fixed over all images. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00047">47</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a9ecb52b5acc0992b287010f03cf2569b"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::UseGradient" ref="a9ecb52b5acc0992b287010f03cf2569b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569b">vnl_sparse_lst_sqr_function::UseGradient</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9ecb52b5acc0992b287010f03cf2569bae990b02cef098d80b5c2dd4ee6dcc777"></a><!-- doxytag: member="no_gradient" ref="a9ecb52b5acc0992b287010f03cf2569bae990b02cef098d80b5c2dd4ee6dcc777" args="" -->no_gradient</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9ecb52b5acc0992b287010f03cf2569baada1fa7cbbec1030915b57b0dc34bca1"></a><!-- doxytag: member="use_gradient" ref="a9ecb52b5acc0992b287010f03cf2569baada1fa7cbbec1030915b57b0dc34bca1" args="" -->use_gradient</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00050">50</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf5a66cd06cf170d1ce7327609c7b1b"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::UseWeights" ref="a0cf5a66cd06cf170d1ce7327609c7b1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1b">vnl_sparse_lst_sqr_function::UseWeights</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0cf5a66cd06cf170d1ce7327609c7b1ba2ee7ea7ab050e13d076db90812394491"></a><!-- doxytag: member="no_weights" ref="a0cf5a66cd06cf170d1ce7327609c7b1ba2ee7ea7ab050e13d076db90812394491" args="" -->no_weights</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0cf5a66cd06cf170d1ce7327609c7b1ba2eaadae26a2fe24eef761c05bbd2aa78"></a><!-- doxytag: member="use_weights" ref="a0cf5a66cd06cf170d1ce7327609c7b1ba2eaadae26a2fe24eef761c05bbd2aa78" args="" -->use_weights</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00054">54</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a225d1f672a902804ee875c2068115742"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::vnl_sparse_lst_sqr_function" ref="a225d1f672a902804ee875c2068115742" args="(unsigned int num_a, unsigned int num_params_per_a, unsigned int num_b, unsigned int num_params_per_b, unsigned int num_params_c, unsigned int num_residuals_per_e, UseGradient g=use_gradient, UseWeights w=no_weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vnl_sparse_lst_sqr_function::vnl_sparse_lst_sqr_function </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_params_per_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_params_per_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_params_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_residuals_per_e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569b">UseGradient</a>&#160;</td>
          <td class="paramname"><em>g</em> = <code>use_gradient</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1b">UseWeights</a>&#160;</td>
          <td class="paramname"><em>w</em> = <code>no_weights</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct <a class="el" href="classvnl__sparse__lst__sqr__function.html" title="Abstract base for sparse least squares functions.">vnl_sparse_lst_sqr_function</a>. </p>
<p>Assumes A consists of <code>num_a</code> parameters each of size <code>num_params_per_a</code> Assumes B consists of <code>num_b</code> parameters each of size <code>num_params_per_b</code> Assumes C consists of <code>num_params_c</code> parameters Assumes there is a residual x_ij for all i and j, each of size <code>num_residuals_per_e</code> The optional argument should be no_gradient if the gradf function has not been implemented. Default is use_gradient. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00032">32</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="af4b03e3a8fd78244d1e300be537a5beb"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::vnl_sparse_lst_sqr_function" ref="af4b03e3a8fd78244d1e300be537a5beb" args="(unsigned int num_a, unsigned int num_params_per_a, unsigned int num_b, unsigned int num_params_per_b, unsigned int num_params_c, const vcl_vector&lt; vcl_vector&lt; bool &gt; &gt; &amp;xmask, unsigned int num_residuals_per_e, UseGradient g=use_gradient, UseWeights w=no_weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vnl_sparse_lst_sqr_function::vnl_sparse_lst_sqr_function </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_params_per_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_params_per_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_params_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vcl_vector&lt; vcl_vector&lt; bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>xmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_residuals_per_e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569b">UseGradient</a>&#160;</td>
          <td class="paramname"><em>g</em> = <code>use_gradient</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1b">UseWeights</a>&#160;</td>
          <td class="paramname"><em>w</em> = <code>no_weights</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct <a class="el" href="classvnl__sparse__lst__sqr__function.html" title="Abstract base for sparse least squares functions.">vnl_sparse_lst_sqr_function</a>. </p>
<p>Assumes A consists of <code>num_a</code> parameters each of size <code>num_params_per_a</code> Assumes B consists of <code>num_b</code> parameters each of size <code>num_params_per_b</code> Assumes C consists of <code>num_params_c</code> parameters <code>xmask</code> is a mask for residual availability. residual e_ij exists only if mask[i][j]==true Assumes each available residual has size <code>num_residuals_per_e</code> The optional argument should be no_gradient if the gradf function has not been implemented. Default is use_gradient. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00071">71</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a6a9ca98cf4b5bd9bc12aab1e8169febd"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::vnl_sparse_lst_sqr_function" ref="a6a9ca98cf4b5bd9bc12aab1e8169febd" args="(const vcl_vector&lt; unsigned int &gt; &amp;a_sizes, const vcl_vector&lt; unsigned int &gt; &amp;b_sizes, unsigned int num_params_c, const vcl_vector&lt; unsigned int &gt; &amp;e_sizes, const vcl_vector&lt; vcl_vector&lt; bool &gt; &gt; &amp;xmask, UseGradient g=use_gradient, UseWeights w=no_weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vnl_sparse_lst_sqr_function::vnl_sparse_lst_sqr_function </td>
          <td>(</td>
          <td class="paramtype">const vcl_vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vcl_vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_params_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vcl_vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>e_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vcl_vector&lt; vcl_vector&lt; bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>xmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a9ecb52b5acc0992b287010f03cf2569b">UseGradient</a>&#160;</td>
          <td class="paramname"><em>g</em> = <code>use_gradient</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__sparse__lst__sqr__function.html#a0cf5a66cd06cf170d1ce7327609c7b1b">UseWeights</a>&#160;</td>
          <td class="paramname"><em>w</em> = <code>no_weights</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct <a class="el" href="classvnl__sparse__lst__sqr__function.html" title="Abstract base for sparse least squares functions.">vnl_sparse_lst_sqr_function</a>. </p>
<p>This constructor is the most general </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a_sizes</td><td>is a vector describing the number of parameters for each a_i </td></tr>
    <tr><td class="paramname">b_sizes</td><td>is a vector describing the number of parameters for each b_j </td></tr>
    <tr><td class="paramname">num_params_c</td><td>is the number of C parameters </td></tr>
    <tr><td class="paramname">e_sizes</td><td>is a vector describing the number of parameters for each residual e_ij </td></tr>
    <tr><td class="paramname">xmask</td><td>is a mask for residual availability. residual e_ij exists only if mask[i][j]==true xmask must be a_sizes.size() by b_sizes.size() and contain e_sizes.size() true entries The optional argument should be no_gradient if the gradf function has not been implemented. Default is use_gradient. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00116">116</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a95a99527b961ffdfe04174dfc6c06f4e"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::~vnl_sparse_lst_sqr_function" ref="a95a99527b961ffdfe04174dfc6c06f4e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual vnl_sparse_lst_sqr_function::~vnl_sparse_lst_sqr_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00112">112</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aebab45fe35aa501378fdc110718c3eda"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::apply_weight_ij" ref="aebab45fe35aa501378fdc110718c3eda" args="(int i, int j, double const &amp;weight, vnl_vector&lt; double &gt; &amp;fij)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::apply_weight_ij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fij</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If using weighted least squares, apply the weight to fij. </p>
<p>The default implementation multiplies fij by weight. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00536">536</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a66aed4a3d6434bde5871270086df8ec8"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::apply_weight_ij" ref="a66aed4a3d6434bde5871270086df8ec8" args="(int i, int j, double const &amp;weight, vnl_matrix&lt; double &gt; &amp;Aij, vnl_matrix&lt; double &gt; &amp;Bij, vnl_matrix&lt; double &gt; &amp;Cij)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::apply_weight_ij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Bij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Cij</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If using weighted least squares, apply the weight to Aij, Bij, Cij. </p>
<p>The default implementation multiplies each matrix by weight. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00547">547</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a63940159f2acf016c9d0f54ca418dc15"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::apply_weights" ref="a63940159f2acf016c9d0f54ca418dc15" args="(vnl_vector&lt; double &gt; const &amp;weights, vnl_vector&lt; double &gt; &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::apply_weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If using weighted least squares, apply the weights to residuals f. </p>
<p>The default implementation applies <em>weights</em> by calling apply_weight_ij for each valid pair of i and j. You do not need to overload this method unless you want to provide a more specialized implementation for your problem. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00308">308</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1c07d9c723d8983cbd38121a1dde8eab"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::apply_weights" ref="a1c07d9c723d8983cbd38121a1dde8eab" args="(vnl_vector&lt; double &gt; const &amp;weights, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;A, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;B, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::apply_weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If using weighted least squares, apply the weights to residuals A, B, C. </p>
<p>The default implementation applies <em>weights</em> by calling apply_weight_ij for each valid pair of i and j. You do not need to overload this method unless you want to provide a more specialized implementation for your problem. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00332">332</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a58a26cbe2fc962addf77c048a85629a7"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::clear_failure" ref="a58a26cbe2fc962addf77c048a85629a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::clear_failure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00116">116</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9149a338304dcbcafcf4d752e7dcd794"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::compute_weight_ij" ref="a9149a338304dcbcafcf4d752e7dcd794" args="(int i, int j, vnl_vector&lt; double &gt; const &amp;ai, vnl_vector&lt; double &gt; const &amp;bj, vnl_vector&lt; double &gt; const &amp;c, vnl_vector&lt; double &gt; const &amp;fij, double &amp;weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::compute_weight_ij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>fij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If using weighted least squares, compute the weight. </p>
<p>Return the weight in <em>weight</em>. The default implementation sets weight = 1 </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00522">522</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a356cde9f3976a10132aa29d0a560c4f0"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::compute_weights" ref="a356cde9f3976a10132aa29d0a560c4f0" args="(vnl_vector&lt; double &gt; const &amp;a, vnl_vector&lt; double &gt; const &amp;b, vnl_vector&lt; double &gt; const &amp;c, vnl_vector&lt; double &gt; const &amp;f, vnl_vector&lt; double &gt; &amp;weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::compute_weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If using weighted least squares, compute the weights for each i and j. </p>
<p>Return the weights in <em>weights</em>. The default implementation computes <em>weights</em> by calling compute_weight_ij for each valid pair of i and j. You do not need to overload this method unless you want to provide a more specialized implementation for your problem. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00273">273</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa55b48507415b9893dad3cc0c727fbbd"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::dim_warning" ref="aa55b48507415b9893dad3cc0c727fbbd" args="(unsigned int n_unknowns, unsigned int n_residuals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::dim_warning </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_unknowns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_residuals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00016">16</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a6565a0886db607a05d919ce441f46760"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::f" ref="a6565a0886db607a05d919ce441f46760" args="(vnl_vector&lt; double &gt; const &amp;a, vnl_vector&lt; double &gt; const &amp;b, vnl_vector&lt; double &gt; const &amp;c, vnl_vector&lt; double &gt; &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all residuals. </p>
<p>Given the parameter vectors a, b, and c, compute the vector of residuals f. f has been sized appropriately before the call. The default implementation computes f by calling fij for each valid pair of i and j. You do not need to overload this method unless you want to provide a more efficient implementation for your problem. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00158">158</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a8c127c146ce432e5127cf2d64bc35e69"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::fd_jac_Aij" ref="a8c127c146ce432e5127cf2d64bc35e69" args="(int i, int j, vnl_vector&lt; double &gt; const &amp;ai, vnl_vector&lt; double &gt; const &amp;bj, vnl_vector&lt; double &gt; const &amp;c, vnl_matrix&lt; double &gt; &amp;Aij, double stepsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::fd_jac_Aij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this to compute a finite-difference Jacobian A_ij. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00400">400</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a33fc3a31764ec77f73f0de76a14bfd4e"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::fd_jac_Bij" ref="a33fc3a31764ec77f73f0de76a14bfd4e" args="(int i, int j, vnl_vector&lt; double &gt; const &amp;ai, vnl_vector&lt; double &gt; const &amp;bj, vnl_vector&lt; double &gt; const &amp;c, vnl_matrix&lt; double &gt; &amp;Bij, double stepsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::fd_jac_Bij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Bij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this to compute a finite-difference Jacobian B_ij. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00440">440</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ac4f5d5929317eee273e899941d293a26"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::fd_jac_blocks" ref="ac4f5d5929317eee273e899941d293a26" args="(vnl_vector&lt; double &gt; const &amp;a, vnl_vector&lt; double &gt; const &amp;b, vnl_vector&lt; double &gt; const &amp;c, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;A, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;B, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;C, double stepsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::fd_jac_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the sparse Jacobian in block form using a finite difference approximation. </p>
<p>Given the parameter vectors a, b and c, compute the set of block Jacobians Aij, Bij, and Cij. The finite difference approximation is done independently at each block. All Aij, Bij, and Cij have been sized appropriately before the call. The default implementation computes A, B, and C by calling jac_Aij, jac_Bij, and jac_Cij for each valid pair of i and j. You do not need to overload this method unless you want to provide a more efficient implementation for your problem. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00234">234</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="af3d9e54aa97792cccd80d84d2f283e6c"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::fd_jac_Cij" ref="af3d9e54aa97792cccd80d84d2f283e6c" args="(int i, int j, vnl_vector&lt; double &gt; const &amp;ai, vnl_vector&lt; double &gt; const &amp;bj, vnl_vector&lt; double &gt; const &amp;c, vnl_matrix&lt; double &gt; &amp;Cij, double stepsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::fd_jac_Cij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Cij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this to compute a finite-difference Jacobian C_ij. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00480">480</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae1b137070a9669a787496318e46e4e32"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::fij" ref="ae1b137070a9669a787496318e46e4e32" args="(int i, int j, vnl_vector&lt; double &gt; const &amp;ai, vnl_vector&lt; double &gt; const &amp;bj, vnl_vector&lt; double &gt; const &amp;c, vnl_vector&lt; double &gt; &amp;fij)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::fij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_i_j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the residuals from the ith component of a, the jth component of b. </p>
<p>Given the parameter vectors ai, bj, and c, compute the vector of residuals fij. fij has been sized appropriately before the call. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00355">355</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="acf5e879631deb53038845ba96a9966e1"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::has_gradient" ref="acf5e879631deb53038845ba96a9966e1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vnl_sparse_lst_sqr_function::has_gradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the derived class has indicated that gradf has been implemented. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00314">314</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a20a59da3a46d858ac16ccc216c81cffe"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::has_weights" ref="a20a59da3a46d858ac16ccc216c81cffe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vnl_sparse_lst_sqr_function::has_weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the derived class has indicated that. </p>
<p><em>apply_weights</em> or <em>apply_weight_ij</em> have been implemented </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00318">318</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a215ac902994bd0298c6cc73f6026759e"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::index_a" ref="a215ac902994bd0298c6cc73f6026759e" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::index_a </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the index of aj in a. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00296">296</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a74039f92584458ff8c467f527040d452"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::index_b" ref="a74039f92584458ff8c467f527040d452" args="(int j) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::index_b </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the index of bj in b. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00299">299</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c743c05572c84195e9228e7ce60cc1c"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::index_e" ref="a2c743c05572c84195e9228e7ce60cc1c" args="(int k) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::index_e </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the index of ek in e. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00302">302</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab88e96eb149a1d3229cf66db3451d735"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::jac_Aij" ref="ab88e96eb149a1d3229cf66db3451d735" args="(int i, int j, vnl_vector&lt; double &gt; const &amp;ai, vnl_vector&lt; double &gt; const &amp;bj, vnl_vector&lt; double &gt; const &amp;c, vnl_matrix&lt; double &gt; &amp;Aij)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::jac_Aij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aij</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Jacobian A_ij, given the parameter vectors a_i, b_j, and c. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00366">366</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a96b00b8b39c9eff4942e95e429e6ceb4"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::jac_Bij" ref="a96b00b8b39c9eff4942e95e429e6ceb4" args="(int i, int j, vnl_vector&lt; double &gt; const &amp;ai, vnl_vector&lt; double &gt; const &amp;bj, vnl_vector&lt; double &gt; const &amp;c, vnl_matrix&lt; double &gt; &amp;Bij)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::jac_Bij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Bij</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Jacobian B_ij, given the parameter vectors a_i, b_j, and c. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00377">377</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="adff5800a571932385afcb3b05e581cf7"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::jac_blocks" ref="adff5800a571932385afcb3b05e581cf7" args="(vnl_vector&lt; double &gt; const &amp;a, vnl_vector&lt; double &gt; const &amp;b, vnl_vector&lt; double &gt; const &amp;c, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;A, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;B, vcl_vector&lt; vnl_matrix&lt; double &gt; &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::jac_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_vector&lt; <a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the sparse Jacobian in block form. </p>
<p>Given the parameter vectors a, b, and c, compute the set of block Jacobians Aij, Bij, and Cij. All Aij, Bij, and Cij have been sized appropriately before the call. The default implementation computes A, B, and C by calling jac_Aij, jac_Bij, and jac_Cij for each valid pair of i and j. You do not need to overload this method unless you want to provide a more efficient implementation for your problem. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00194">194</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae41fd717f560d32cc54db7e792c48097"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::jac_Cij" ref="ae41fd717f560d32cc54db7e792c48097" args="(int i, int j, vnl_vector&lt; double &gt; const &amp;ai, vnl_vector&lt; double &gt; const &amp;bj, vnl_vector&lt; double &gt; const &amp;c, vnl_matrix&lt; double &gt; &amp;Cij)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::jac_Cij </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__matrix.html">vnl_matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Cij</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Jacobian C_ij, given the parameter vectors a_i, b_j, and c. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00388">388</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<a class="anchor" id="a428a60bdd3d570cf65830e023098e326"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::number_of_a" ref="a428a60bdd3d570cf65830e023098e326" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::number_of_a </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of subsets in <code>a</code>. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00305">305</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d05703e2e6d74c664fae276eb36a1cc"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::number_of_b" ref="a2d05703e2e6d74c664fae276eb36a1cc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::number_of_b </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of subsets in <code>b</code>. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00308">308</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2dcfccfbc708881b8175b6ba5f94c714"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::number_of_e" ref="a2dcfccfbc708881b8175b6ba5f94c714" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::number_of_e </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of residual vectors. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00311">311</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa650f3c88ffb9139d6ddcc8f92df95fb"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::number_of_params_a" ref="aa650f3c88ffb9139d6ddcc8f92df95fb" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::number_of_params_a </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of parameters of a_j. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00276">276</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2dd2b63684e8e57d9251301f236e77eb"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::number_of_params_b" ref="a2dd2b63684e8e57d9251301f236e77eb" args="(int j) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::number_of_params_b </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of parameters of b_i. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00279">279</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31141bf3b8a59f45c2e6fc2f81bc8fc0"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::number_of_params_c" ref="a31141bf3b8a59f45c2e6fc2f81bc8fc0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::number_of_params_c </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of parameters of c. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00282">282</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a28f2234d336f4b07947b8f073f3fb9"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::number_of_residuals" ref="a9a28f2234d336f4b07947b8f073f3fb9" args="(int k) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::number_of_residuals </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of residuals in the kth residual vector. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00285">285</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7bfa3612f71086cfa33bbaef48bb8a1"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::number_of_residuals" ref="ab7bfa3612f71086cfa33bbaef48bb8a1" args="(int i, int j) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vnl_sparse_lst_sqr_function::number_of_residuals </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of residuals for x_ij. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00288">288</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a97ed08f452aedd332dc5c866b989f4db"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::residual_indices" ref="a97ed08f452aedd332dc5c866b989f4db" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvnl__crs__index.html">vnl_crs_index</a>&amp; vnl_sparse_lst_sqr_function::residual_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a const reference to the residual indexer. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00321">321</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a732102ffae0e6edf6bdc4f055c69d870"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::throw_failure" ref="a732102ffae0e6edf6bdc4f055c69d870" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::throw_failure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00115">115</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac281578ff13d6c946f7e7317b94d3d4a"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::trace" ref="ac281578ff13d6c946f7e7317b94d3d4a" args="(int iteration, vnl_vector&lt; double &gt; const &amp;a, vnl_vector&lt; double &gt; const &amp;b, vnl_vector&lt; double &gt; const &amp;c, vnl_vector&lt; double &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vnl_sparse_lst_sqr_function::trace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvnl__vector.html">vnl_vector</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called after each LM iteration to print debugging etc. </p>

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html#l00559">559</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a99c2bebcb079e853dfe7f987587dd388"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::failure" ref="a99c2bebcb079e853dfe7f987587dd388" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvnl__sparse__lst__sqr__function.html#a99c2bebcb079e853dfe7f987587dd388">vnl_sparse_lst_sqr_function::failure</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00058">58</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad8329c3baac4945d1ce25459099ebf7d"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::indices_a_" ref="ad8329c3baac4945d1ce25459099ebf7d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_vector&lt;unsigned int&gt; <a class="el" href="classvnl__sparse__lst__sqr__function.html#ad8329c3baac4945d1ce25459099ebf7d">vnl_sparse_lst_sqr_function::indices_a_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00325">325</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a06227e084dcad9fb1466157c707d7957"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::indices_b_" ref="a06227e084dcad9fb1466157c707d7957" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_vector&lt;unsigned int&gt; <a class="el" href="classvnl__sparse__lst__sqr__function.html#a06227e084dcad9fb1466157c707d7957">vnl_sparse_lst_sqr_function::indices_b_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00326">326</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33c0f6bdc5d5030572564196230ba2d0"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::indices_e_" ref="a33c0f6bdc5d5030572564196230ba2d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcl_vector&lt;unsigned int&gt; <a class="el" href="classvnl__sparse__lst__sqr__function.html#a33c0f6bdc5d5030572564196230ba2d0">vnl_sparse_lst_sqr_function::indices_e_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00328">328</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a406557f256f3c6314873711d1962fe7a"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::num_params_c_" ref="a406557f256f3c6314873711d1962fe7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classvnl__sparse__lst__sqr__function.html#a406557f256f3c6314873711d1962fe7a">vnl_sparse_lst_sqr_function::num_params_c_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00327">327</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a77c2fb0d7101cc684355b3864986245a"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::residual_indices_" ref="a77c2fb0d7101cc684355b3864986245a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvnl__crs__index.html">vnl_crs_index</a> <a class="el" href="classvnl__sparse__lst__sqr__function.html#a77c2fb0d7101cc684355b3864986245a">vnl_sparse_lst_sqr_function::residual_indices_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00324">324</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a48891bf8a98a10b997285de1b6b16e22"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::use_gradient_" ref="a48891bf8a98a10b997285de1b6b16e22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvnl__sparse__lst__sqr__function.html#a48891bf8a98a10b997285de1b6b16e22">vnl_sparse_lst_sqr_function::use_gradient_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00330">330</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a96dae044f302cc38200f41a3d442760e"></a><!-- doxytag: member="vnl_sparse_lst_sqr_function::use_weights_" ref="a96dae044f302cc38200f41a3d442760e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvnl__sparse__lst__sqr__function.html#a96dae044f302cc38200f41a3d442760e">vnl_sparse_lst_sqr_function::use_weights_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html#l00331">331</a> of file <a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>core/vnl/<a class="el" href="vnl__sparse__lst__sqr__function_8h_source.html">vnl_sparse_lst_sqr_function.h</a></li>
<li>core/vnl/<a class="el" href="vnl__sparse__lst__sqr__function_8cxx_source.html">vnl_sparse_lst_sqr_function.cxx</a></li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:31:05 for core/vnl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
