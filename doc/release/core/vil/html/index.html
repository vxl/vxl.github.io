<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>vil : Core image library</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">vil : Core image library </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>A set of classes to represent and manipulate images</p>
<h2><a class="anchor" id="intro"></a>
Introduction</h2>
<p>Broadly there are two sorts of image one is interested in - images in memory (all parts of which can be accessed directly) and external images (eg in files) which can only be accessed indirectly. In most cases images in files are loaded into memory in one go, where they can then be manipulated. However, for some very large images this is not possible or desirable. In this case it is useful to be able to load in a sub-section of the image, manipulate it, and possible write it out again. vil supports both memory images and external images.</p>
<p>The core class is vil_image_view&lt;T&gt; which gives a view of an image in memory. The only way to get at the pixel data in an image is through a vil_image_view&lt;T&gt;.</p>
<p>Large images (in files) can be accessed through the <a class="el" href="classvil__image__resource.html" title="Abstract representation of an image source or image destination.">vil_image_resource</a> class, but one can only get at the data by asking for a view of it, which loads the requested section into memory and creates a suitable vil_image_view&lt;T&gt;.</p>
<h2><a class="anchor" id="images"></a>
Images</h2>
<p>The vil_image_view&lt;T&gt; represents a view of a multi-plane image of given type. A pointer is stored to the top-left pixel in the first plane of the image (top_left_ptr()) and integers indicating how to get to neighbours in the i (istep()), j (jstep()) and plane (planestep()) directions.</p>
<p>The advantages of this approach are</p>
<ul>
<li>It is actually faster than pointer indirection on most architectures</li>
<li>It allows one to access non-contiguous data as if it were a single plane</li>
<li>One can use it to wrap up other image classes transparently.</li>
<li>It is simple to extend to 3D images, and avoids huge arrays of pointers</li>
</ul>
<p>Note that the same colour image can either be viewed as a one plane image with RGB pixels (using <a class="el" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view</a>&lt;vil_rgb&lt;vxl_byte&gt; &gt;) or as a 3 plane byte image (using vil_image_view&lt;vxl_byte&gt; with nplanes() == 3). </p>
<div class="fragment"><pre class="fragment">
vil_image_view&lt;vil_rgb&lt;vxl_byte&gt; &gt; rgb_image;
rgb_image = vil_load("my_image.jpg");

// Create a 3 plane view of rgb
vil_image_view&lt;vxl_byte &gt; three_plane_image =  rgb_image;
// or explicitly
three_plane_image =  vil_view_as_planes(rgb_image);
// or with less typing
three_plane_image = vil_load("my_image.jpg");

// Now create rgb view of 3 plane image (note: will set view to empty if not possible)
vil_image_view&lt;vil_rgb&lt;vxl_byte&gt; &gt; rgb_image2 = three_plane_image;
// or explicitly
rgb_image2 = vil_view_as_rgb(three_plane_image);

// If you want a greyscale image no matter whether the underlying image is rgb or grey
vil_image_view&lt;vxl_byte&gt; image2 = vil_convert_to_grey_using_average&lt;vxl_byte&gt;(vil_load("my_image.jpg"),vxl_byte());

</pre></div><p>There are some conversions that will try a fast view conversion only.</p>
<ul>
<li>vil_view_as_planes(view): Create a multi-plane view from a multi-component view.</li>
<li>vil_view_as_rgb(view): Create an rgb pixel view from a multi-plane view.</li>
<li>vil_view_as_complex(view): Create a complex pixel view from a multi-plane view.</li>
</ul>
<p>There are some conversions that will process each pixel to do a conversion.</p>
<ul>
<li>vil_convert_to_grey_using_average(view, new_pixel_type): Create a greyscale view from any image.</li>
<li>vil_convert_cast(source, dest): Convert, for example, a byte image to float image</li>
</ul>
<h3><a class="anchor" id="copying"></a>
Copying</h3>
<p>Since the vil_image_view&lt;T&gt; is a `view' of the actual image data, copying one only copies the `view', not the image data itself - you get two views looking at the same chunk of memory. Some cunning smart pointer stuff is used to ensure that the actual data remains as long as a valid view is looking at it. (Note that this may not always be the case, since the view can be of a chunk of memory that the view does not have direct control of, such as a video buffer). This view copying will work between different types of view if it is possible to reconfigure the view very cheaply. If you wish to copy the image data itself, then use the vil_copy_deep(src_im) function. This copies the raw data into a newly created space, and returns a new view of it. Alternatively, use the method dest_im.deep_copy(src_im), or the function vil_copy_reformat(src_im, dest_im).</p>
<p>Example of loading, copying then processing: </p>
<div class="fragment"><pre class="fragment">
vil_image_view&lt;vxl_byte&gt; image;
image = vil_load("test_image.jpg");
vil_image_view&lt;vxl_byte&gt; image2 = vil_copy_deep(image);
my_invert_image(image2);
vil_save(image2,"output_image.jpg");
</pre></div><p>Example of creating an image in memory </p>
<div class="fragment"><pre class="fragment">
unsigned ni=256;
unsigned nj=256;
unsigned nplanes=3;
vil_image_view&lt;vxl_byte&gt; image(ni,nj,nplanes);
for (unsigned p=0;p&lt;nplanes;++p)
  for (unsigned j=0;j&lt;nj;++j)
    for (unsigned i=0;i&lt;ni;++i)
      image(i,j,p) = vxl_byte(i+j+p);
</pre></div><p>Example of creating an image in memory, using pointer arithmetic </p>
<div class="fragment"><pre class="fragment">
  unsigned ni=256;
  unsigned nj=256;
  unsigned nplanes=3;
  vil_image_view&lt;vxl_byte&gt; image(ni,nj,nplanes);
  vxl_byte* plane = image.top_left_ptr();
  for (unsigned p=0;p&lt;nplanes;++p,plane += image.planestep())
  {
    vxl_byte* row = plane;
    for (unsigned j=0;j&lt;nj;++j,row += image.jstep())
    {
      vxl_byte* pixel = row;
      for (unsigned i=0;i&lt;ni;++i,pixel+=image.istep())
        *pixel = vxl_byte(i+10*j+100*p);
    }
  }
</pre></div><h3><a class="anchor" id="set_size"></a>
Resizing</h3>
<p>When one resizes (using set_size) a vil_image_view&lt;T&gt; the view disconnects from the data (which may then be deleted if no other views are connected), allocates a new chunk of memory for the new image and sets the view to look at it.</p>
<p>Note that if the set_size does not change the image size, then nothing is done and the view remains unchanged.</p>
<h3><a class="anchor" id="view_manipulation"></a>
Manipulating Views</h3>
<p>There are a variety of ways one can view the same data, allowing one to appear to change the data simply by changing ones view of it.</p>
<p>For instance one can obtain a transposed view of an image simply by swapping ni-nj and istep-jstep. This is particularly useful when implementing decomposable filters, as one need only write it for one direction, then can apply it to the original image and its transpose. </p>
<div class="fragment"><pre class="fragment">
vil_image_view&lt;vxl_byte&gt; src_image = vil_load("image_file.jpg");
vil_image_view&lt;vxl_byte&gt; tmp_image1, tmp_image2;
vil_exp_filter_i(src_image, tmp_image1, 2.0);  // Apply filter to rows of src_image
vil_exp_filter_i(vil_transpose(tmp_image1), tmp_image2, 2.0);  // Apply filter to cols of tmp_image1
vil_image_view&lt;vxl_byte&gt; filtered_image = vil_transpose(tmp_image2);
// Note that
// vil_exp_filter_i(vil_transpose(tmp_image1),vil_transpose(filtered_image),2.0)
// would only work correctly if filtered_image was already the correct size.
// If it isn't, then the view created by vil_transpose(filtered_image) would
// be resized, and disconnected from filtered_image itself, which would remain
// unchanged.
</pre></div><p>View manipulations include:</p>
<ul>
<li>vil_transpose : Return transposed view</li>
<li>vil_flip_lr : View which reflects along i (ie i -&gt; ni-1-i left/right)</li>
<li>vil_flip_ud : View which reflects along j (ie j -&gt; nj-1-j up/down)</li>
<li>vil_view_as_planes: View rgb&lt;T&gt; data as planes of T</li>
<li>vil_view_as_rgb : View plane data as rgb&lt;T&gt; pixels</li>
<li>vil_crop : View a window into an image</li>
<li>vil_decimate : View a trivially subsampled image</li>
<li>vil_plane : View a single plane of an image</li>
</ul>
<h3><a class="anchor" id="view_ops"></a>
Operations on Views</h3>
<p>Useful simple operations on views include</p>
<ul>
<li>vil_print_all(os,view) : Prints out view in a grid</li>
<li>vil_fill(view,value) : Fills view with value</li>
<li>vil_fill_row(view,j,value) : Fills row j with value</li>
<li>vil_fill_col(view,i,value) : Fills col i with value</li>
<li>vil_fill_mask(view,mask,value) : Fills region defined by boolean mask image</li>
<li>vil_fill_disk(view,ci,cj,r,val): Fills disk in image with value</li>
<li>vil_clamp : Clamp image pixels to given range</li>
<li>vil_histogram_equalise(image) : Apply histogram equalisation</li>
</ul>
<h3><a class="anchor" id="vil_image_view_base_sptr"></a>
vil_image_view_base_sptr</h3>
<p>vil_image_view_base_sptr is used internally by vil, and is not intended for users of vil. Anywhere you see a function returning one of these, (e.g. <a class="el" href="classvil__image__view.html#a4441b157480a1984446d380194c938b6" title="Convenience function for loading an image into an image view.">vil_load()</a> ) you can assign it directly to a vil_image_view&lt;T&gt;. If you want a pixel-type independent image container, see <a class="el" href="classvil__memory__image.html" title="Generic image implementation for PNM files.">vil_memory_image</a> below.</p>
<h2><a class="anchor" id="image_src"></a>
Image resources</h2>
<p>The <a class="el" href="classvil__image__resource.html" title="Abstract representation of an image source or image destination.">vil_image_resource</a> class is an abstract base class for image data, views of which can be obtained (or changed) with the get_view()/put_view() functions. You cannot directly construct one of these <a class="el" href="classvil__image__resource.html" title="Abstract representation of an image source or image destination.">vil_image_resource</a> classes. Instead you use a helper function, which will return a smart pointer - expect to see lots of vil_image_resource_sptr objects. The types of derived classes, and means of creating them are</p>
<ul>
<li>Representing an image in a <a href="file:">file:</a> e.g. <a class="el" href="classvil__pnm__image.html" title="Generic image implementation for PNM files.">vil_pnm_image</a>, <a class="el" href="classvil__jpeg__image.html" title="generic_image implementation for JPEG files.">vil_jpeg_image</a>. These are created using <a class="el" href="classvil__image__resource.html#a06af5804204294c392c46fd23c440ab8" title="Load an image resource object from a file.">vil_load_image_resource()</a>, and <a class="el" href="classvil__image__resource.html#a538047e5970e782c2b5f27cff7a8c02e" title="Make a new image of given format.">vil_new_image_resource()</a></li>
<li><a class="el" href="classvil__memory__image.html" title="Generic image implementation for PNM files.">vil_memory_image</a>: Representing an image in memory (essentially a wrapper around a view.) This is created using <a class="el" href="classvil__image__resource.html#a538047e5970e782c2b5f27cff7a8c02e" title="Make a new image of given format.">vil_new_image_resource()</a> or <a class="el" href="classvil__image__resource.html#a7d991bbca1ecd8b4c0917c36ec4b27c6" title="Make a new image resource that is a wrapper on an existing view&#39;s data.">vil_new_image_resource_of_view()</a>.</li>
<li>Representing a filtered version of an image in a file (without loading in memory): e.g. <a class="el" href="classvil__crop__image__resource.html" title="A generic_image adaptor that behaves like a cropped version of its input.">vil_crop_image_resource</a> and <a class="el" href="classvil__decimate__image__resource.html" title="A generic_image adaptor that behaves like a decimated version of its input.">vil_decimate_image_resource</a>. These are created using the equivalent functions: <a class="el" href="classvil__image__view.html#a33d0f637031fd0eca0e0a3c0caefd972" title="Create a view which is a cropped version of src.">vil_crop()</a>, <a class="el" href="classvil__image__view.html#a0c23f62f861b82a8e0063ebb6f302e60" title="Create a view which is a decimated version of src.">vil_decimate()</a>, etc.</li>
<li>Representing the outcome of an image processing algorithm (see next section) e.g. <a class="el" href="classvil__convolve__1d__resource.html" title="A resource adaptor that behaves like a convolved version of its input.">vil_convolve_1d_resource</a>. These are created using the equivalent functions <a class="el" href="classvil__image__view.html#a15cde13a8582acb71caa6b8ad021cf52" title="Convolve kernel[i] (i in [k_lo,k_hi]) with srcT in i-direction.">vil_convolve_1d()</a>.</li>
</ul>
<p><a class="el" href="classvil__image__resource.html" title="Abstract representation of an image source or image destination.">vil_image_resource</a> objects in most cases only deal with scalar-type pixels. Of course once you get a view of real image data in memory, you can easily convert a multi-planar view into a multi-component view.</p>
<h2><a class="anchor" id="Legacy"></a>
interfaces</h2>
<p>There are two reasons to still use vil1 (currently core/vil1)</p>
<ul>
<li>vil1 has one or two image processing functions and image loaders that have yet to be ported to vil</li>
<li>You may have lots of code that uses vil1, and haven't yet converted to vil.</li>
</ul>
<p>There are several functions to convert between the various types of vil1 and vil images.</p>
<ul>
<li>vil_vil1_to_image_resource(vil1_image): creates a <a class="el" href="classvil__image__resource.html" title="Abstract representation of an image source or image destination.">vil_image_resource</a>.</li>
<li>vil_vil1_to_image_view(vil1_memory_image_of&lt;T&gt;): creates a vil_image_view&lt;T&gt;.</li>
<li>vil_vil1_from_image_view(vil_image_view&lt;T&gt;): creates a vil1_memory_image_of&lt;T&gt;.</li>
</ul>
<h2><a class="anchor" id="Error"></a>
Reporting</h2>
<p>Currently most error reporting either happens by calling vcl_abort, or by returning a null image. The null images reporting in particular will transition to exception-based reporting. You can retain the old behaiour by setting VXL_LEGACY_ERROR_REPORTING with CMake.</p>
<h3><a class="anchor" id="maths"></a>
Mathematics on images</h3>
<p>Functions to evaluate image properties:</p>
<ul>
<li>vil_math_value_range - Get range of values in view</li>
<li>vil_math_sum(sum,im,p) - Sum of elements in plane of view</li>
<li>vil_math_mean - Mean of elements</li>
<li>vil_math_mean_and_variance - Mean and variance over view</li>
<li>vil_math_rms(image,rms_im) - Compute root mean of squares for each (multiplane) pixel</li>
<li>vil_math_rss(image,rss_im) - Compute root sum of squares for each (multiplane) pixel</li>
<li>vil_math_sum_sqr(image,ss_im) - Compute sum of squares for each (multiplane) pixel</li>
<li>vil_math_mean_over_planes(im,mean_im)</li>
</ul>
<p>Functions to modify images:</p>
<ul>
<li>vil_math_scale_values(im,s) : im(x,y,p) = s*im(x,y,p)</li>
<li>vil_math_scale_and_offset_values(im,s,o) : im(x,y,p) = s*im(x,y,p)+o</li>
<li>vil_math_image_sum(imA,imB,im_sum) : im_sum = imA+imB</li>
<li>vil_math_image_difference(imA,imB,im_diff) : im_diff = imA-imB</li>
<li>vil_math_image_abs_difference(imA,imB,im_diff) : im_diff = |imA-imB|</li>
<li>vil_math_image_product(imA,imB,imP) : imP(x,y,p) = imA(x,y,p)*imB(x,y,p)</li>
<li>vil_math_image_ratio(imA,imB,imP) : imP(x,y,p) = imA(x,y,p)/imB(x,y,p)</li>
<li>vil_math_add_image_fraction(imA,fa,imB,fb) : imA = fa*imA + fb*imB (Useful for moving averages!)</li>
<li>vil_math_sqrt(im) : im(x,y,p) = sqrt(im(x,y,p)) or zero if -ive</li>
</ul>
<p>Other related maths functions</p>
<ul>
<li>vil_math_integral_image(imA,im_sum) : Images integrating values</li>
<li>vil_math_integral_sqr_image(imA,im_sum,im_sum_sq) : Images integrating values and square of values</li>
</ul>
<h3><a class="anchor" id="interp"></a>
Interpolating images</h3>
<p>Bilinear interpolation (of single planes of scalar types) can be obtained using</p>
<ul>
<li>vil_bilin_interp : Interpolate, using assert to check if in valid region</li>
<li>vil_bilin_interp_raw : Interpolate, assuming point in valid region (seg fault otherwise)</li>
<li>vil_bilin_interp_safe : Interpolate, returning zero if outside image</li>
<li>vil_bilin_interp_safe_extend : Interpolate, returning nearest edge value if outside</li>
</ul>
<p>Other methods of sampling with bilinear interpolation include:</p>
<ul>
<li>vil_sample_profile_bilin : Sample values along a line</li>
<li>vil_sample_grid_bilin : Sample values over a grid, storing in a vector</li>
<li>vil_resample_bilin : Sample values over a grid, storing in a image</li>
</ul>
<p>Bicubic interpolation: For each of the bilinear interpolation functions there is a corresponding bicubic interpolation function. Just use "bicub" instead of "bilin" in the name.</p>
 
 <hr/>
  <h2><a class="anchor" id="vil_algo"></a>
vil_algo : Computational Imaging Library</h2>
<p>A core level 2 library containing some simple algorithms for manipulating images. Note that the argument order is typically of the form vil_f(src_im,dest_im,params). Examples include</p>
<ul>
<li>vil_convolve_1d - Convolve with 1D filter - all manner of edge effects catered for</li>
<li>vil_convolve_2d - Convolve with 2D filter (no edge effects catered for yet!)</li>
<li>vil_correlate_1d - Similar to vil_convolve_1d but with reversing the kernel</li>
<li>vil_correlate_2d - Similar to vil_convolve_2d but with reversing the kernel</li>
<li>vil_gauss_filter_gen_ntap - Generate an n-tap FIR filter from a Gaussian function</li>
<li>vil_gauss_filter_5tap - Apply 1d Gaussian filter using 5 element kernel</li>
<li>vil_gauss_filter_1d - Apply 1d Gaussian filter of arbitrary SD and kernel width</li>
<li>vil_gauss_filter_2d - Apply 2d Gaussian filter of arbitrary SD and kernel width</li>
<li>vil_exp_filter_i - Apply exponential filter along i axis (fast recursive method)</li>
<li>vil_exp_filter_j - Apply exponential filter along j axis (fast recursive method)</li>
<li>vil_exp_filter_2d - Apply exponential filter along i and j (fast recursive method)</li>
<li>vil_exp_grad_filter_i - Apply exponential gradient filter along i axis (fast recursive method)</li>
<li>vil_exp_grad_filter_j - Apply exponential gradient filter along j axis (fast recursive method)</li>
<li>vil_sobel_3x3 - to generate X/Y gradient images using 3x3 Sobel operators</li>
<li>vil_gauss_reduce - smooth and sub-sample to produce half sized image</li>
<li>vil_median - Compute median over area described by <a class="el" href="classvil__structuring__element.html" title="Structuring element for morphology represented as a list of non-zero pixels.">vil_structuring_element</a></li>
<li>vil_fft_2d_fwd,bwd - Perform in-place 2D FFT on an image of a complex type</li>
<li>vil_suppress_non_max_3x3 - Zero all pixels which are not local maxima</li>
<li>vil_corners - Harris cornerness operator</li>
<li>vil_find_peaks - Locate local peaks in an image</li>
<li>vil_orientations - Compute angle and edge magnitude at each pixel</li>
<li>vil_distance_transform - Apply distance transform to images</li>
<li>vil_histogram_equalise - Replace every pixel by its intensity rank</li>
<li>vil_suppress_non_max_edges - Compute gradient magnitude and zero any non-maximal values</li>
</ul>
<p>See also the vipl library for a more generic image processing interface and more image processing algorithms.</p>
<p>Morphological functions (using <a class="el" href="classvil__structuring__element.html" title="Structuring element for morphology represented as a list of non-zero pixels.">vil_structuring_element</a>)</p>
<ul>
<li>vil_binary_erode</li>
<li>vil_binary_dilate</li>
<li>vil_binary_opening</li>
<li>vil_binary_closing</li>
<li>vil_greyscale_erode</li>
<li>vil_greyscale_dilate</li>
<li>vil_greyscale_opening</li>
<li>vil_greyscale_closing</li>
<li>vil_median</li>
</ul>
<p>Other related maths functions</p>
<ul>
<li>vil_histogram(image,hist,min,max,nbins) : Compute histogram of image values</li>
<li>vil_histogram_byte(image,histo) : Compute histogram from byte image</li>
</ul>
<h3><a class="anchor" id="regions"></a>
Region finding</h3>
<p>The boundaries of thresholded regions can be found using</p>
<ul>
<li>vil_find_4con_boundary_above_threshold</li>
<li>vil_find_4con_boundary_below_threshold (Given a point inside a closed, 4-connected region defined by a threshold, these functions find the 4-connected boundary pixels of the region)</li>
</ul>
<ul>
<li>vil_blob : Functions to find all connected regions in an image</li>
</ul>
<h3><a class="anchor" id="utils"></a>
General utilities</h3>
<ul>
<li>vil_tile_images : Generate single image by tiling together a set of images</li>
</ul>
<h3><a class="anchor" id="conventions"></a>
Parameter Conventions</h3>
<p>For your ease of use, all vil functions and methods adhere to the following parameter conventions:</p>
<ul>
<li>Index types - All pixel index and image size types are unsigned.</li>
<li>Specifying a pixel - func(i,j) assumes plane 0 or func(i,j,p)</li>
<li>Specifying a window - func(i0,ni,j0,nj) window includes all planes.</li>
</ul>
<h2><a class="anchor" id="Examples"></a>
Examples</h2>
<p>There are plenty of working examples in the examples subdirectory - these can be treated as a mini-tutorial.</p>
<h2><a class="anchor" id="Lead"></a>
Lead</h2>
<p>Ian Scott is responsible for co-ordinating significant changes to vil. <a href="http://sourceforge.net/sendmessage.php?touser=261110">http://sourceforge.net/sendmessage.php?touser=261110</a> </p>
</div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:31:45 for core/vil by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
