<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>core/vil/vil_image_view.txx Source File</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">core/vil/vil_image_view.txx</div>  </div>
</div>
<div class="contents">
<a href="vil__image__view_8txx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This is core/vil/vil_image_view.txx</span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef vil_image_view_txx_</span>
<a name="l00003"></a><a class="code" href="vil__image__view_8txx.html#ad32ba6b489d528e5840796af37a35e4d">00003</a> <span class="preprocessor"></span><span class="preprocessor">#define vil_image_view_txx_</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="comment">//:</span>
<a name="l00005"></a>00005 <span class="comment">// \file</span>
<a name="l00006"></a>00006 <span class="comment">// \brief Represent images of one or more planes of Ts.</span>
<a name="l00007"></a>00007 <span class="comment">// \author Ian Scott</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// Note: To keep down size of vil_image_view</span>
<a name="l00010"></a>00010 <span class="comment">// Please think carefully before adding any new methods.</span>
<a name="l00011"></a>00011 <span class="comment">// In particular any methods that provide new views (e.g. vil_plane)</span>
<a name="l00012"></a>00012 <span class="comment">// will be more usefully provided as external functions. - IMS.</span>
<a name="l00013"></a>00013 <span class="comment">// In that case, use the &quot;relates&quot; keyword of Doxygen to link the documentation</span>
<a name="l00014"></a>00014 <span class="comment">// of that function to the vil_image_view class.</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// \verbatim</span>
<a name="l00017"></a>00017 <span class="comment">//  Modifications</span>
<a name="l00018"></a>00018 <span class="comment">//   23 Oct.2003 - Peter Vanroose - Added support for 64-bit int pixels</span>
<a name="l00019"></a>00019 <span class="comment">// \endverbatim</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="vil__image__view_8h.html" title="A base class reference-counting view of some image data.">vil_image_view.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;vcl_string.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;vcl_cassert.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;vcl_cstdlib.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;vcl_cmath.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;vcl_ostream.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="vil__pixel__format_8h.html">vil/vil_pixel_format.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="vil__exception_8h.html" title="Exceptions thrown by vil, and a mechanism for turning them off.">vil/vil_exception.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;vcl_cstring.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;vcl_algorithm.h&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">//=======================================================================</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00036"></a><a class="code" href="classvil__image__view.html#abe88c4db7d2804309bee128d6f1af516">00036</a> <a class="code" href="classvil__image__view.html#a1bc7fe6d0bd55bfa5e904bea240f709a" title="Dflt ctor.">vil_image_view&lt;T&gt;::vil_image_view</a>(<span class="keywordtype">unsigned</span> n_i, <span class="keywordtype">unsigned</span> n_j, <span class="keywordtype">unsigned</span> n_planes,
<a name="l00037"></a>00037                                   <span class="keywordtype">unsigned</span> n_interleaved_planes)
<a name="l00038"></a>00038 : top_left_(0), istep_(n_interleaved_planes)
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040   assert(n_planes==1 || n_interleaved_planes==1);
<a name="l00041"></a>00041   assert(<a class="code" href="vil__pixel__format_8h.html#a1584d4356219c867020df43a66aada05" title="The pixel format enumeration corresponding to the C++ type.">vil_pixel_format_of</a>(T()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800da763ec54acd5a8d28519252c706986209">VIL_PIXEL_FORMAT_UNKNOWN</a> ||
<a name="l00042"></a>00042          n_planes * n_interleaved_planes == 1 ||
<a name="l00043"></a>00043          <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(<a class="code" href="vil__pixel__format_8h.html#a1584d4356219c867020df43a66aada05" title="The pixel format enumeration corresponding to the C++ type.">vil_pixel_format_of</a>(T())) == 1);
<a name="l00044"></a>00044   <a class="code" href="classvil__image__view.html#a9c01939f01ef50314620e26aaacb04d3" title="resize current planes to ni x nj.">set_size</a>(n_i,n_j,n_planes*n_interleaved_planes);
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">//: Set this view to look at someone else&#39;s memory data.</span>
<a name="l00048"></a>00048 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00049"></a><a class="code" href="classvil__image__view.html#ac1a9b9a1da599a83a6b062f1dc5558f2">00049</a> <a class="code" href="classvil__image__view.html#a1bc7fe6d0bd55bfa5e904bea240f709a" title="Dflt ctor.">vil_image_view&lt;T&gt;::vil_image_view</a>(<span class="keyword">const</span> T* top_left, <span class="keywordtype">unsigned</span> n_i, <span class="keywordtype">unsigned</span> n_j, <span class="keywordtype">unsigned</span> n_planes,
<a name="l00050"></a>00050                                   vcl_ptrdiff_t i_step, vcl_ptrdiff_t j_step, vcl_ptrdiff_t plane_step)
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052   set_to_memory(top_left,n_i,n_j,n_planes,i_step,j_step,plane_step);
<a name="l00053"></a>00053 }
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">//: Set this view to look at another view&#39;s data</span>
<a name="l00056"></a>00056 <span class="comment">//  Need to pass the memory chunk to set up the internal smart ptr appropriately</span>
<a name="l00057"></a>00057 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00058"></a><a class="code" href="classvil__image__view.html#ad6f05afebb1891873130405260cfa14d">00058</a> <a class="code" href="classvil__image__view.html#a1bc7fe6d0bd55bfa5e904bea240f709a" title="Dflt ctor.">vil_image_view&lt;T&gt;::vil_image_view</a>(<a class="code" href="classvil__smart__ptr.html">vil_memory_chunk_sptr</a> <span class="keyword">const</span>&amp; mem_chunk,
<a name="l00059"></a>00059                                   <span class="keyword">const</span> T* top_left, <span class="keywordtype">unsigned</span> n_i, <span class="keywordtype">unsigned</span> n_j, <span class="keywordtype">unsigned</span> n_planes,
<a name="l00060"></a>00060                                   vcl_ptrdiff_t i_step, vcl_ptrdiff_t j_step, vcl_ptrdiff_t plane_step)
<a name="l00061"></a>00061  : <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a>(n_i, n_j, n_planes)
<a name="l00062"></a>00062  , top_left_(const_cast&lt;T*&gt;(top_left))
<a name="l00063"></a>00063  , istep_(i_step), jstep_(j_step)
<a name="l00064"></a>00064  , planestep_(plane_step)
<a name="l00065"></a>00065  , ptr_(mem_chunk)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>  <span class="comment">// check view and chunk are in rough agreement</span>
<a name="l00069"></a>00069   <span class="keywordflow">if</span> (mem_chunk) <span class="comment">// if we are doing a view transform on a non-owned image, then mem_chunk will be 0.</span>
<a name="l00070"></a>00070   {
<a name="l00071"></a>00071     <span class="keywordflow">if</span> ( mem_chunk-&gt;size() &lt; n_planes*n_i*n_j*<span class="keyword">sizeof</span>(T) )
<a name="l00072"></a>00072       vcl_cerr &lt;&lt; <span class="stringliteral">&quot;mem_chunk-&gt;size()=&quot;</span> &lt;&lt; mem_chunk-&gt;size() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>
<a name="l00073"></a>00073                &lt;&lt; <span class="stringliteral">&quot;nplanes=&quot;</span> &lt;&lt; n_planes &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>
<a name="l00074"></a>00074                &lt;&lt; <span class="stringliteral">&quot;n_i=&quot;</span> &lt;&lt; n_i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>
<a name="l00075"></a>00075                &lt;&lt; <span class="stringliteral">&quot;n_j=&quot;</span> &lt;&lt; n_j &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>
<a name="l00076"></a>00076                &lt;&lt; <span class="stringliteral">&quot;sizeof(T)=&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(T) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>
<a name="l00077"></a>00077                &lt;&lt; <span class="stringliteral">&quot;n_planes*n_i*n_j*sizeof(T)=&quot;</span> &lt;&lt; n_planes*n_i*n_j*<span class="keyword">sizeof</span>(T) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00078"></a>00078     assert(mem_chunk-&gt;size() &gt;= n_planes*n_i*n_j*<span class="keyword">sizeof</span>(T));
<a name="l00079"></a>00079     <span class="keywordflow">if</span> (top_left  &lt; reinterpret_cast&lt;const T*&gt;(mem_chunk-&gt;data()) ||
<a name="l00080"></a>00080         top_left &gt;= reinterpret_cast&lt;const T*&gt;(reinterpret_cast&lt;const char*&gt;(mem_chunk-&gt;data()) + mem_chunk-&gt;size()))
<a name="l00081"></a>00081       vcl_cerr &lt;&lt; <span class="stringliteral">&quot;top_left at &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(top_left) &lt;&lt; <span class="stringliteral">&quot;, memory_chunk at &quot;</span>
<a name="l00082"></a>00082                &lt;&lt; reinterpret_cast&lt;const void*&gt;(mem_chunk-&gt;data()) &lt;&lt; <span class="stringliteral">&quot;, size &quot;</span> &lt;&lt; mem_chunk-&gt;size()
<a name="l00083"></a>00083                &lt;&lt; <span class="stringliteral">&quot;, size of data type &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(T) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00084"></a>00084     assert(top_left &gt;= reinterpret_cast&lt;const T*&gt;(mem_chunk-&gt;data()) &amp;&amp;
<a name="l00085"></a>00085            (mem_chunk-&gt;size()==0 || top_left  &lt; reinterpret_cast&lt;const T*&gt;(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(mem_chunk-&gt;data()) + mem_chunk-&gt;size())) );
<a name="l00086"></a>00086   }
<a name="l00087"></a>00087 <span class="preprocessor">#endif</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span>}
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="comment">//: Copy constructor</span>
<a name="l00091"></a>00091 <span class="comment">// If this view cannot set itself to view the other data (e.g. because the</span>
<a name="l00092"></a>00092 <span class="comment">// types are incompatible) it will set itself to empty.</span>
<a name="l00093"></a>00093 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00094"></a><a class="code" href="classvil__image__view.html#ad801fd244582777ccde9565030af6812">00094</a> <a class="code" href="classvil__image__view.html#a1bc7fe6d0bd55bfa5e904bea240f709a" title="Dflt ctor.">vil_image_view&lt;T&gt;::vil_image_view</a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a>&amp; that)
<a name="l00095"></a>00095 : <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a>(that.ni(),that.nj(),that.nplanes()),
<a name="l00096"></a>00096   top_left_(0), istep_(0), jstep_(0), planestep_(0), ptr_(0)
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098   <a class="code" href="classvil__image__view.html#a19ec9b7ce52d67ea9ef0a746c46306ce" title="Copy a view. The rhs and lhs will point to the same image data.">operator=</a>( static_cast&lt;vil_image_view_base const&amp;&gt;(that) );
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">//: Sort of copy constructor</span>
<a name="l00102"></a>00102 <span class="comment">// If this view cannot set itself to view the other data (e.g. because the</span>
<a name="l00103"></a>00103 <span class="comment">// types are incompatible) it will set itself to empty.</span>
<a name="l00104"></a>00104 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00105"></a><a class="code" href="classvil__image__view.html#a980c4db836f4ebe47e8285a1fc19398d">00105</a> <a class="code" href="classvil__image__view.html#a1bc7fe6d0bd55bfa5e904bea240f709a" title="Dflt ctor.">vil_image_view&lt;T&gt;::vil_image_view</a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a>&amp; that):
<a name="l00106"></a>00106 top_left_(0), istep_(0), jstep_(0), planestep_(0), ptr_(0)
<a name="l00107"></a>00107 {
<a name="l00108"></a>00108   <a class="code" href="classvil__image__view.html#a19ec9b7ce52d67ea9ef0a746c46306ce" title="Copy a view. The rhs and lhs will point to the same image data.">operator=</a>(that);
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">//: Sort of copy constructor</span>
<a name="l00112"></a>00112 <span class="comment">// If this view cannot set itself to view the other data (e.g. because the</span>
<a name="l00113"></a>00113 <span class="comment">// types are incompatible) it will set itself to empty.</span>
<a name="l00114"></a>00114 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00115"></a><a class="code" href="classvil__image__view.html#afd25ca898792ad9fd59f0022e7d68a0f">00115</a> <a class="code" href="classvil__image__view.html#a1bc7fe6d0bd55bfa5e904bea240f709a" title="Dflt ctor.">vil_image_view&lt;T&gt;::vil_image_view</a>(<span class="keyword">const</span> <a class="code" href="classvil__smart__ptr.html">vil_image_view_base_sptr</a>&amp; that):
<a name="l00116"></a>00116 top_left_(0), istep_(0), jstep_(0), planestep_(0), ptr_(0)
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118   <a class="code" href="classvil__image__view.html#a19ec9b7ce52d67ea9ef0a746c46306ce" title="Copy a view. The rhs and lhs will point to the same image data.">operator=</a>(that);
<a name="l00119"></a>00119 }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">//: Perform deep copy of the src image, placing in this image</span>
<a name="l00122"></a>00122 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00123"></a><a class="code" href="classvil__image__view.html#a24e151a6f4b19094049923a42a0549e8">00123</a> <span class="keywordtype">void</span> <a class="code" href="classvil__image__view.html#a24e151a6f4b19094049923a42a0549e8" title="Make a copy of the data in src and set this to view it.">vil_image_view&lt;T&gt;::deep_copy</a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a>&amp; src)
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125   set_size(src.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),src.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),src.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>());
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <span class="keywordflow">if</span> (src.<a class="code" href="classvil__image__view.html#a1be0bc44cbf938095ec536d4d099b516" title="True if data all in one unbroken block and top_left_ptr() is lowest data address.">is_contiguous</a>() &amp;&amp; this-&gt;is_contiguous())
<a name="l00128"></a>00128   {
<a name="l00129"></a>00129     istep_=src.<a class="code" href="classvil__image__view.html#a7209229fad95e3603016f2b452e53fa1" title="Add this to a pixel pointer to move one column left.">istep_</a>; jstep_= src.<a class="code" href="classvil__image__view.html#ab7aa059e5615fea30ef83b0926221014" title="Add this to a pixel pointer to move one row down.">jstep_</a>; planestep_ = src.<a class="code" href="classvil__image__view.html#ad6afe4aee3c0ca407c21f9aa0e7d31a4" title="Add this to a pixel pointer to move one plane back.">planestep_</a>;
<a name="l00130"></a>00130     <span class="keywordflow">if</span> (src.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()&gt;0 &amp;&amp; src.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()&gt;0 &amp;&amp; src.<a class="code" href="classvil__image__view.html#ae5506ce4f9f5c1ff90688108dac67036" title="Add this to your pixel pointer to get pixel on next plane.">planestep</a>()&gt;=0)
<a name="l00131"></a>00131     {
<a name="l00132"></a>00132       vcl_memcpy(top_left_,src.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),src.<a class="code" href="classvil__image__view__base.html#ad9be33d94e81b6957af71b2e030cef6a" title="The number of pixels.">size</a>()*<span class="keyword">sizeof</span>(T));
<a name="l00133"></a>00133       <span class="keywordflow">return</span>;
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     <a class="code" href="classvil__image__view.html#a2a9412a7152f70839fade2f9c710d42f">const_iterator</a> s_it = src.<a class="code" href="classvil__image__view.html#ac2d29a6c774764d898a080dfe85343a5">begin</a>();
<a name="l00136"></a>00136     <a class="code" href="classvil__image__view.html#ab5fd77ef0fdc76394d037b66fac8999f">iterator</a> d_it = begin();
<a name="l00137"></a>00137     <a class="code" href="classvil__image__view.html#a2a9412a7152f70839fade2f9c710d42f">const_iterator</a> end_it = src.<a class="code" href="classvil__image__view.html#a99c222bc7c1567504dc513abf36c898c">end</a>();
<a name="l00138"></a>00138     <span class="keywordflow">while</span> (s_it!=end_it) {*d_it = *s_it; ++s_it; ++d_it; }
<a name="l00139"></a>00139     <span class="keywordflow">return</span>;
<a name="l00140"></a>00140   }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="keyword">const</span> vcl_ptrdiff_t s_planestep = src.<a class="code" href="classvil__image__view.html#ae5506ce4f9f5c1ff90688108dac67036" title="Add this to your pixel pointer to get pixel on next plane.">planestep</a>();
<a name="l00143"></a>00143   <span class="keyword">const</span> vcl_ptrdiff_t s_istep = src.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>();
<a name="l00144"></a>00144   <span class="keyword">const</span> vcl_ptrdiff_t s_jstep = src.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>();
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   <span class="comment">// Do a deep copy</span>
<a name="l00147"></a>00147   <span class="comment">// This is potentially inefficient</span>
<a name="l00148"></a>00148   <span class="keyword">const</span> T* src_data = src.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>();
<a name="l00149"></a>00149   T* data = top_left_;
<a name="l00150"></a>00150   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0;p&lt;nplanes_;++p,src_data += s_planestep,data += planestep_)
<a name="l00151"></a>00151   {
<a name="l00152"></a>00152     T* row = data;
<a name="l00153"></a>00153     <span class="keyword">const</span> T* src_row = src_data;
<a name="l00154"></a>00154     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;j&lt;nj_;++j,row += jstep_,src_row += s_jstep)
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156       T* p = row;
<a name="l00157"></a>00157       <span class="keyword">const</span> T* sp = src_row;
<a name="l00158"></a>00158       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;ni_;++i,p+=istep_,sp+=s_istep) *p = *sp;
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160   }
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">// Notes on convert_components_from_planes() and convert_planes_from_components()</span>
<a name="l00164"></a>00164 <span class="comment">// These are used by the operator= to provide the appropriate smart conversion</span>
<a name="l00165"></a>00165 <span class="comment">// behaviour for the various types.</span>
<a name="l00166"></a>00166 <span class="comment">// I don&#39;t think that C++ templates support full pattern matching,</span>
<a name="l00167"></a>00167 <span class="comment">// so we have to provide one template instantiation to cover the general</span>
<a name="l00168"></a>00168 <span class="comment">// compound pixel case (the range of which is possibly infinite)</span>
<a name="l00169"></a>00169 <span class="comment">// We then specialise for all the scalar pixel cases (there are only so</span>
<a name="l00170"></a>00170 <span class="comment">// many scalar types).</span>
<a name="l00171"></a>00171 <span class="comment">// I guess someone could merge all the scalar specialisations using</span>
<a name="l00172"></a>00172 <span class="comment">// macros and substantially reduce the length of this code.</span>
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">//: Convert planes to components from planes, or do nothing if types are wrong.</span>
<a name="l00176"></a>00176 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00177"></a><a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a">00177</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp;lhs,
<a name="l00178"></a>00178                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180   <span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type comp_type;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="keyword">const</span> <span class="keywordtype">int</span> ncomp =
<a name="l00183"></a>00183     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(<a class="code" href="vil__pixel__format_8h.html#a1584d4356219c867020df43a66aada05" title="The pixel format enumeration corresponding to the C++ type.">vil_pixel_format_of</a>(T()));
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800d" title="Describes the type of the concrete data.">vil_pixel_format</a> fmt = <a class="code" href="vil__pixel__format_8h.html#a1584d4356219c867020df43a66aada05" title="The pixel format enumeration corresponding to the C++ type.">vil_pixel_format_of</a>(T());
<a name="l00186"></a>00186   <span class="keywordflow">if</span> (<span class="comment">// both sides have equal component types and rhs has scalar pixels and</span>
<a name="l00187"></a>00187       rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>() == <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(fmt) &amp;&amp;
<a name="l00188"></a>00188       <span class="comment">// lhs has number of components equal to rhs&#39;s number of planes.</span>
<a name="l00189"></a>00189       ncomp == (int)rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() )
<a name="l00190"></a>00190   {
<a name="l00191"></a>00191     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;comp_type&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;comp_type&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00192"></a>00192     <span class="comment">// Check that the steps are suitable for viewing as components</span>
<a name="l00193"></a>00193     <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view.html#ae5506ce4f9f5c1ff90688108dac67036" title="Add this to your pixel pointer to get pixel on next plane.">planestep</a>() != 1 || vcl_abs((<span class="keywordtype">int</span>)rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>())&lt;ncomp || vcl_abs((<span class="keywordtype">int</span>)rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>())&lt;ncomp ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00194"></a>00194     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T &gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(),
<a name="l00195"></a>00195                              <span class="keyword">reinterpret_cast&lt;</span>T const*<span class="keyword">&gt;</span>(rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>()),
<a name="l00196"></a>00196                              rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),1,
<a name="l00197"></a>00197                              rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()/ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()/ncomp,1);
<a name="l00198"></a>00198     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00199"></a>00199   }
<a name="l00200"></a>00200   <span class="keywordflow">else</span>
<a name="l00201"></a>00201     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 VCL_DEFINE_SPECIALIZATION
<a name="l00206"></a><a class="code" href="vil__image__view_8txx.html#af22bf787fd51aa86ec29be50f987a59b">00206</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;float&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00207"></a>00207                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00208"></a>00208 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}  <span class="comment">// when lhs has scalar pixels, don&#39;t attempt conversion</span>
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 VCL_DEFINE_SPECIALIZATION
<a name="l00211"></a><a class="code" href="vil__image__view_8txx.html#a9e3cfcdd5a3ad34f49acd1d0da5ae215">00211</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;double&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00212"></a>00212                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00213"></a>00213 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 VCL_DEFINE_SPECIALIZATION
<a name="l00216"></a><a class="code" href="vil__image__view_8txx.html#a0fea2e89a357963903fd02956b98043f">00216</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html">vil_image_view&lt;bool&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00217"></a>00217                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00218"></a>00218 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 VCL_DEFINE_SPECIALIZATION
<a name="l00221"></a><a class="code" href="vil__image__view_8txx.html#ab0ce9d597edd65baacced7adbbcb9f12">00221</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_sbyte&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00222"></a>00222                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00223"></a>00223 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 VCL_DEFINE_SPECIALIZATION
<a name="l00226"></a><a class="code" href="vil__image__view_8txx.html#a5fa63215bdb89b9763062f2141dafd80">00226</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_byte&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00227"></a>00227                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00228"></a>00228 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 VCL_DEFINE_SPECIALIZATION
<a name="l00231"></a><a class="code" href="vil__image__view_8txx.html#aa9d6538073ce6159f3934f1f2a4f4651">00231</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_16&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00232"></a>00232                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00233"></a>00233 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 VCL_DEFINE_SPECIALIZATION
<a name="l00236"></a><a class="code" href="vil__image__view_8txx.html#a2263254ab1cd909c8bf1b79c5c3d3c60">00236</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_16&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00237"></a>00237                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00238"></a>00238 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 VCL_DEFINE_SPECIALIZATION
<a name="l00241"></a><a class="code" href="vil__image__view_8txx.html#ab008a7ec77d70e0b850ff13d3b5361a5">00241</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_32&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00242"></a>00242                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00243"></a>00243 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 VCL_DEFINE_SPECIALIZATION
<a name="l00246"></a><a class="code" href="vil__image__view_8txx.html#a95a2b63d302c1b49c6ea0046d06c9af4">00246</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_32&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00247"></a>00247                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00248"></a>00248 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="preprocessor">#if VXL_HAS_INT_64</span>
<a name="l00251"></a>00251 <span class="preprocessor"></span>
<a name="l00252"></a>00252 VCL_DEFINE_SPECIALIZATION
<a name="l00253"></a>00253 <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_64&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00254"></a>00254                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00255"></a>00255 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 VCL_DEFINE_SPECIALIZATION
<a name="l00258"></a>00258 <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_64&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00259"></a>00259                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs_base*/</span>)
<a name="l00260"></a>00260 {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="preprocessor">#endif</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span>
<a name="l00264"></a>00264 <span class="comment">//: Convert components to planes from planes, or do nothing if types are wrong.</span>
<a name="l00265"></a>00265 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00266"></a><a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88">00266</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp; <span class="comment">/*lhs*/</span>,
<a name="l00267"></a>00267                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; <span class="comment">/*rhs*/</span>)
<a name="l00268"></a>00268 { <span class="keywordflow">return</span> <span class="keyword">false</span>;} <span class="comment">// when lhs has non-scalar pixels, don&#39;t attempt conversion</span>
<a name="l00269"></a>00269 <span class="comment">// except for the following typical cases</span>
<a name="l00270"></a>00270 VCL_DEFINE_SPECIALIZATION
<a name="l00271"></a><a class="code" href="vil__image__view_8txx.html#aa90f4549bdf0333d52f36a8b42651bf4">00271</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view</a>&lt;<a class="code" href="structvil__rgb.html" title="This is the appropriate pixel type for 24-bit colour images.">vil_rgb&lt;vxl_byte&gt;</a> &gt; &amp; lhs,
<a name="l00272"></a>00272                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; rhs)
<a name="l00273"></a>00273 {
<a name="l00274"></a>00274   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() != 3)
<a name="l00275"></a>00275     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00276"></a>00276   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()!=<a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800da7e558fc5ba55dbb9c32658e7960b83f4">VIL_PIXEL_FORMAT_BYTE</a>)
<a name="l00277"></a>00277     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00278"></a>00278   <span class="keywordtype">unsigned</span> ni = rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(), nj = rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>();
<a name="l00279"></a>00279   <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_byte&gt;</a> &amp;rhsv = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_byte&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs);
<a name="l00280"></a>00280   lhs= *(<span class="keyword">new</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vil_rgb&lt;vxl_byte&gt;</a> &gt;(ni, nj));
<a name="l00281"></a>00281   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j&lt;nj; ++j)
<a name="l00282"></a>00282     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i&lt;ni; ++i){
<a name="l00283"></a>00283       lhs(i,j).r = rhsv(i,j,0); lhs(i, j).g = rhsv(i,j,1); lhs(i, j).b = rhsv(i,j,2);
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 VCL_DEFINE_SPECIALIZATION
<a name="l00289"></a><a class="code" href="vil__image__view_8txx.html#af881b020f443cd9743fd66e0d6f058a3">00289</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view</a>&lt;<a class="code" href="structvil__rgba.html" title="This is the appropriate pixel type for RGBA colour images.">vil_rgba&lt;vxl_uint_16&gt;</a> &gt; &amp; lhs,
<a name="l00290"></a>00290                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; rhs)
<a name="l00291"></a>00291 {
<a name="l00292"></a>00292   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() != 4)
<a name="l00293"></a>00293     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00294"></a>00294   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()!=<a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800dabecb5c0033517756dc112ccd18f97073">VIL_PIXEL_FORMAT_UINT_16</a>)
<a name="l00295"></a>00295     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00296"></a>00296   <span class="keywordtype">unsigned</span> ni = rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(), nj = rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>();
<a name="l00297"></a>00297   <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_16&gt;</a> &amp;rhsv = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_16&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs);
<a name="l00298"></a>00298   lhs = *(<span class="keyword">new</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vil_rgba&lt;vxl_uint_16&gt;</a> &gt;(ni, nj));
<a name="l00299"></a>00299   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j&lt;nj; ++j)
<a name="l00300"></a>00300     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i&lt;ni; ++i){
<a name="l00301"></a>00301       lhs(i, j).r = rhsv(i,j,0); lhs(i, j).g = rhsv(i,j,1); lhs(i, j).b = rhsv(i,j,2);
<a name="l00302"></a>00302       lhs(i, j).a = rhsv(i,j,3);
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00305"></a>00305 }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 VCL_DEFINE_SPECIALIZATION
<a name="l00308"></a><a class="code" href="vil__image__view_8txx.html#a5d7cd3539b2f7afe013e9837e74e250a">00308</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_byte&gt;</a> &amp;lhs,
<a name="l00309"></a>00309                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00312"></a>00312     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00315"></a>00315       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00316"></a>00316       <span class="comment">// both sides have equal component types</span>
<a name="l00317"></a>00317       <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800da7e558fc5ba55dbb9c32658e7960b83f4">VIL_PIXEL_FORMAT_BYTE</a>)
<a name="l00318"></a>00318   {
<a name="l00319"></a>00319     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00320"></a>00320     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_byte&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_byte&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_byte&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00323"></a>00323                                    rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00324"></a>00324                                    rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00325"></a>00325     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00326"></a>00326   }
<a name="l00327"></a>00327   <span class="keywordflow">else</span>
<a name="l00328"></a>00328     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00329"></a>00329 }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 VCL_DEFINE_SPECIALIZATION
<a name="l00332"></a><a class="code" href="vil__image__view_8txx.html#a920edb39559e00556a919d7636b30f11">00332</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_sbyte&gt;</a> &amp;lhs,
<a name="l00333"></a>00333                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00334"></a>00334 {
<a name="l00335"></a>00335   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00336"></a>00336     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00339"></a>00339       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00340"></a>00340       <span class="comment">// both sides have equal component types</span>
<a name="l00341"></a>00341       <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800da20c3ae85fdecfa20b5ecf12f8894efeb">VIL_PIXEL_FORMAT_SBYTE</a>)
<a name="l00342"></a>00342   {
<a name="l00343"></a>00343     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00344"></a>00344     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_sbyte&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_sbyte&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_sbyte&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00347"></a>00347                                     rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00348"></a>00348                                     rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00349"></a>00349     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00350"></a>00350   }
<a name="l00351"></a>00351   <span class="keywordflow">else</span>
<a name="l00352"></a>00352     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 VCL_DEFINE_SPECIALIZATION
<a name="l00356"></a><a class="code" href="vil__image__view_8txx.html#a3cb4db70a60ab6ebde44cb03c16f4048">00356</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_16&gt;</a> &amp;lhs,
<a name="l00357"></a>00357                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00360"></a>00360     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00363"></a>00363       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00364"></a>00364       <span class="comment">// both sides have equal component types</span>
<a name="l00365"></a>00365       <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800dabecb5c0033517756dc112ccd18f97073">VIL_PIXEL_FORMAT_UINT_16</a>)
<a name="l00366"></a>00366   {
<a name="l00367"></a>00367     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00368"></a>00368     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_16&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_16&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_16&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00371"></a>00371                                       rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00372"></a>00372                                       rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00373"></a>00373     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00374"></a>00374   }
<a name="l00375"></a>00375   <span class="keywordflow">else</span>
<a name="l00376"></a>00376     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00377"></a>00377 }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 VCL_DEFINE_SPECIALIZATION
<a name="l00380"></a><a class="code" href="vil__image__view_8txx.html#a0b4afb62402018c89c501162a5803e0a">00380</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_16&gt;</a> &amp;lhs,
<a name="l00381"></a>00381                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00382"></a>00382 {
<a name="l00383"></a>00383   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00384"></a>00384     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00387"></a>00387       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00388"></a>00388       <span class="comment">// both sides have equal component types</span>
<a name="l00389"></a>00389       <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800daba50e1cdc6e602c7e314fa82066027a3">VIL_PIXEL_FORMAT_INT_16</a>)
<a name="l00390"></a>00390   {
<a name="l00391"></a>00391     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00392"></a>00392     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_16&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_16&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_16&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00395"></a>00395                                      rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00396"></a>00396                                      rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00397"></a>00397     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00398"></a>00398   }
<a name="l00399"></a>00399   <span class="keywordflow">else</span>
<a name="l00400"></a>00400     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00401"></a>00401 }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 VCL_DEFINE_SPECIALIZATION
<a name="l00404"></a><a class="code" href="vil__image__view_8txx.html#a7bac5990f8f306081f6154c9b08d1c5d">00404</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_32&gt;</a> &amp;lhs,
<a name="l00405"></a>00405                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00406"></a>00406 {
<a name="l00407"></a>00407   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00408"></a>00408     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00411"></a>00411       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00412"></a>00412       <span class="comment">// both sides have equal component types</span>
<a name="l00413"></a>00413        <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800da355f2de6abb4cb81d9ca9cfcad7dd0fa">VIL_PIXEL_FORMAT_UINT_32</a>)
<a name="l00414"></a>00414   {
<a name="l00415"></a>00415     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00416"></a>00416     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_32&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_32&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00417"></a>00417 
<a name="l00418"></a>00418     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_32&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00419"></a>00419                                       rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00420"></a>00420                                       rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00421"></a>00421     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00422"></a>00422   }
<a name="l00423"></a>00423   <span class="keywordflow">else</span>
<a name="l00424"></a>00424     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 VCL_DEFINE_SPECIALIZATION
<a name="l00428"></a><a class="code" href="vil__image__view_8txx.html#aa978889802cbc247fa19a0440b46b849">00428</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_32&gt;</a> &amp;lhs,
<a name="l00429"></a>00429                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00430"></a>00430 {
<a name="l00431"></a>00431   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00432"></a>00432     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00433"></a>00433 
<a name="l00434"></a>00434   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00435"></a>00435       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00436"></a>00436       <span class="comment">// both sides have equal component types</span>
<a name="l00437"></a>00437       <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800da65f175b4a4049f8457bc8c4f772b9f5d">VIL_PIXEL_FORMAT_INT_32</a>)
<a name="l00438"></a>00438   {
<a name="l00439"></a>00439     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00440"></a>00440     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_32&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_32&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_32&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00443"></a>00443                                      rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00444"></a>00444                                      rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00445"></a>00445     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00446"></a>00446   }
<a name="l00447"></a>00447   <span class="keywordflow">else</span>
<a name="l00448"></a>00448     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="preprocessor">#if VXL_HAS_INT_64</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span>
<a name="l00453"></a>00453 VCL_DEFINE_SPECIALIZATION
<a name="l00454"></a>00454 <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_64&gt;</a> &amp;lhs,
<a name="l00455"></a>00455                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00458"></a>00458     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00459"></a>00459 
<a name="l00460"></a>00460   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00461"></a>00461       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00462"></a>00462       <span class="comment">// both sides have equal component types</span>
<a name="l00463"></a>00463        <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == VIL_PIXEL_FORMAT_UINT_64)
<a name="l00464"></a>00464   {
<a name="l00465"></a>00465     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00466"></a>00466     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_64&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_64&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_uint_64&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00469"></a>00469                                       rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00470"></a>00470                                       rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00471"></a>00471     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00472"></a>00472   }
<a name="l00473"></a>00473   <span class="keywordflow">else</span>
<a name="l00474"></a>00474     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 VCL_DEFINE_SPECIALIZATION
<a name="l00478"></a>00478 <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_64&gt;</a> &amp;lhs,
<a name="l00479"></a>00479                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00482"></a>00482     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00483"></a>00483 
<a name="l00484"></a>00484   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00485"></a>00485       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00486"></a>00486       <span class="comment">// both sides have equal component types</span>
<a name="l00487"></a>00487       <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == VIL_PIXEL_FORMAT_INT_64)
<a name="l00488"></a>00488   {
<a name="l00489"></a>00489     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00490"></a>00490     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_64&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_64&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;vxl_int_64&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00493"></a>00493                                      rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00494"></a>00494                                      rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00495"></a>00495     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00496"></a>00496   }
<a name="l00497"></a>00497   <span class="keywordflow">else</span>
<a name="l00498"></a>00498     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="preprocessor">#endif // VXL_HAS_INT_64</span>
<a name="l00502"></a>00502 <span class="preprocessor"></span>
<a name="l00503"></a>00503 VCL_DEFINE_SPECIALIZATION
<a name="l00504"></a><a class="code" href="vil__image__view_8txx.html#a481705bab85f76e0a6386ad17385fa73">00504</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;float&gt;</a> &amp;lhs,
<a name="l00505"></a>00505                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00506"></a>00506 {
<a name="l00507"></a>00507   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00508"></a>00508     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00511"></a>00511       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00512"></a>00512       <span class="comment">// both sides have equal component types</span>
<a name="l00513"></a>00513       <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800da8d2e38094a68770dcad0e6637d5ce3ba">VIL_PIXEL_FORMAT_FLOAT</a>)
<a name="l00514"></a>00514   {
<a name="l00515"></a>00515     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00516"></a>00516     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;float&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;float&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;float&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00519"></a>00519                                 rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00520"></a>00520                                 rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00521"></a>00521     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00522"></a>00522   }
<a name="l00523"></a>00523   <span class="keywordflow">else</span>
<a name="l00524"></a>00524     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00525"></a>00525 }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 VCL_DEFINE_SPECIALIZATION
<a name="l00528"></a><a class="code" href="vil__image__view_8txx.html#ac53f910a5e88355c707e66b928f92ad9">00528</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(<a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;double&gt;</a> &amp;lhs,
<a name="l00529"></a>00529                                            <span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs_base)
<a name="l00530"></a>00530 {
<a name="l00531"></a>00531   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncomp =
<a name="l00532"></a>00532     <a class="code" href="vil__pixel__format_8cxx.html#a2637b810a0cdc48160ea51da1dd19831" title="Return the number of components in pixel format f.">vil_pixel_format_num_components</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>());
<a name="l00533"></a>00533 
<a name="l00534"></a>00534   <span class="keywordflow">if</span> (<span class="comment">// rhs has just 1 plane</span>
<a name="l00535"></a>00535       rhs_base.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() == 1 &amp;&amp;
<a name="l00536"></a>00536       <span class="comment">// both sides have equal component types</span>
<a name="l00537"></a>00537       <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(rhs_base.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>()) == <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800da57e197d362a17a1777b1ff69ee82e8ec">VIL_PIXEL_FORMAT_DOUBLE</a>)
<a name="l00538"></a>00538   {
<a name="l00539"></a>00539     <span class="comment">// cheat by casting to component type, not pixel type (because we don&#39;t know full pixel type at compile time.)</span>
<a name="l00540"></a>00540     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;double&gt;</a> &amp;rhs = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;double&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs_base);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542     lhs = <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;double&gt;</a>(rhs.<a class="code" href="classvil__image__view.html#a5960a6adf6356d61788becddfdaed7ff" title="Smart pointer to the object holding the data for this view.">memory_chunk</a>(), rhs.<a class="code" href="classvil__image__view.html#a68e0987062ee5e3abd7f0cbbf9801257" title="Pointer to the first (top left in plane 0) pixel.">top_left_ptr</a>(),
<a name="l00543"></a>00543                                  rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(),rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(),ncomp,
<a name="l00544"></a>00544                                  rhs.<a class="code" href="classvil__image__view.html#a7c7c608ffc3f95abcccef6395fdfdc90" title="Add this to your pixel pointer to get next i pixel.">istep</a>()*ncomp,rhs.<a class="code" href="classvil__image__view.html#a1ed72e80d54cd1abc3eec9c97de565c2" title="Add this to your pixel pointer to get next j pixel.">jstep</a>()*ncomp,1);
<a name="l00545"></a>00545     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00546"></a>00546   }
<a name="l00547"></a>00547   <span class="keywordflow">else</span>
<a name="l00548"></a>00548     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00553"></a><a class="code" href="classvil__image__view.html#a19ec9b7ce52d67ea9ef0a746c46306ce">00553</a> <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp; <a class="code" href="classvil__image__view.html#a19ec9b7ce52d67ea9ef0a746c46306ce" title="Copy a view. The rhs and lhs will point to the same image data.">vil_image_view&lt;T&gt;::operator= </a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp; rhs)
<a name="l00554"></a>00554 {
<a name="l00555"></a>00555   <span class="keywordflow">return</span> operator=( static_cast&lt;vil_image_view_base const&amp;&gt;(rhs) );
<a name="l00556"></a>00556 }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00560"></a><a class="code" href="classvil__image__view.html#a37119af9cfb9371091c8e21558b22254">00560</a> <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp; <a class="code" href="classvil__image__view.html#a19ec9b7ce52d67ea9ef0a746c46306ce" title="Copy a view. The rhs and lhs will point to the same image data.">vil_image_view&lt;T&gt;::operator= </a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp; rhs)
<a name="l00561"></a>00561 {
<a name="l00562"></a>00562   <span class="keywordflow">if</span> (static_cast&lt;const vil_image_view_base*&gt;(<span class="keyword">this</span>) == &amp;rhs)
<a name="l00563"></a>00563     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>() == pixel_format())
<a name="l00566"></a>00566   {
<a name="l00567"></a>00567     <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp;that = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a>&amp;<span class="keyword">&gt;</span>(rhs);
<a name="l00568"></a>00568     ni_=that.<a class="code" href="classvil__image__view__base.html#a369b4ef96e02e50008687b1b73a40892" title="Number of columns.">ni_</a>;
<a name="l00569"></a>00569     nj_=that.<a class="code" href="classvil__image__view__base.html#a6a76c11ba42071bdb58181282b48e387" title="Number of rasters.">nj_</a>;
<a name="l00570"></a>00570     nplanes_=that.<a class="code" href="classvil__image__view__base.html#a09ec9b0e0b4fcc7e084bdc20a069b2fa" title="Number of planes.">nplanes_</a>;
<a name="l00571"></a>00571     istep_=that.<a class="code" href="classvil__image__view.html#a7209229fad95e3603016f2b452e53fa1" title="Add this to a pixel pointer to move one column left.">istep_</a>;
<a name="l00572"></a>00572     jstep_=that.<a class="code" href="classvil__image__view.html#ab7aa059e5615fea30ef83b0926221014" title="Add this to a pixel pointer to move one row down.">jstep_</a>;
<a name="l00573"></a>00573     planestep_=that.<a class="code" href="classvil__image__view.html#ad6afe4aee3c0ca407c21f9aa0e7d31a4" title="Add this to a pixel pointer to move one plane back.">planestep_</a>;
<a name="l00574"></a>00574     top_left_=that.<a class="code" href="classvil__image__view.html#adf083d8780bd52f3a6d42cb02b8e8c3b" title="Pointer to pixel at origin.">top_left_</a>;
<a name="l00575"></a>00575     ptr_=that.<a class="code" href="classvil__image__view.html#a11af5651bc8159fce8fb1d342a08dc38" title="Reference to actual image data.">ptr_</a>;
<a name="l00576"></a>00576     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00577"></a>00577   }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="keywordflow">if</span> (<a class="code" href="vil__image__view_8txx.html#a75a700e53730370635d78bb132e74b9a" title="Convert planes to components from planes, or do nothing if types are wrong.">convert_components_from_planes</a>(*<span class="keyword">this</span>, rhs))
<a name="l00580"></a>00580     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00581"></a>00581 
<a name="l00582"></a>00582   <span class="keywordflow">if</span> (<a class="code" href="vil__image__view_8txx.html#a4b7bf74ee6cc42521c3a8941feb71f88" title="Convert components to planes from planes, or do nothing if types are wrong.">convert_planes_from_components</a>(*<span class="keyword">this</span>, rhs))
<a name="l00583"></a>00583     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   <a class="code" href="vil__exception_8h.html#af05bbe26d928dd228040d0543b000fd1" title="Throw an exception indicating a potential problem.">vil_exception_warning</a>(<a class="code" href="classvil__exception__pixel__formats__incompatible.html" title="Indicates that a function call failed because the pixel types were incompatible.">vil_exception_pixel_formats_incompatible</a>(
<a name="l00586"></a>00586     rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>(), this-&gt;pixel_format(), <span class="stringliteral">&quot;vil_image_view::operator =&quot;</span>) );
<a name="l00587"></a>00587   set_to_memory(0, 0, 0, 0, 0, 0, 0);
<a name="l00588"></a>00588   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00589"></a>00589 }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 <span class="comment">//=======================================================================</span>
<a name="l00593"></a>00593 
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00596"></a><a class="code" href="classvil__image__view.html#a9c01939f01ef50314620e26aaacb04d3">00596</a> <span class="keywordtype">void</span> <a class="code" href="classvil__image__view.html#a9c01939f01ef50314620e26aaacb04d3" title="resize current planes to ni x nj.">vil_image_view&lt;T&gt;::set_size</a>(<span class="keywordtype">unsigned</span> n_i, <span class="keywordtype">unsigned</span> n_j)
<a name="l00597"></a>00597 {
<a name="l00598"></a>00598   <span class="keywordflow">if</span> ( nplanes_ &gt; 0 )
<a name="l00599"></a>00599     set_size(n_i, n_j, nplanes_);
<a name="l00600"></a>00600   <span class="keywordflow">else</span>
<a name="l00601"></a>00601     set_size(n_i, n_j, 1);
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 <span class="comment">//: True if data all in one unbroken block and top_left_ptr() is lowest data address</span>
<a name="l00605"></a>00605 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00606"></a><a class="code" href="classvil__image__view.html#a1be0bc44cbf938095ec536d4d099b516">00606</a> <span class="keywordtype">bool</span> <a class="code" href="classvil__image__view.html#a1be0bc44cbf938095ec536d4d099b516" title="True if data all in one unbroken block and top_left_ptr() is lowest data address.">vil_image_view&lt;T&gt;::is_contiguous</a>()<span class="keyword"> const</span>
<a name="l00607"></a>00607 <span class="keyword"></span>{
<a name="l00608"></a>00608   <span class="comment">// For a contiguous image, the smallest step size should be 1, the</span>
<a name="l00609"></a>00609   <span class="comment">// next step size should be the width of corresponding to the</span>
<a name="l00610"></a>00610   <span class="comment">// smallest step size, and so on. So, sort the step sizes and check</span>
<a name="l00611"></a>00611   <span class="comment">// if this is the case.</span>
<a name="l00612"></a>00612 
<a name="l00613"></a>00613   <span class="comment">// Sort the step sizes in ascending order, and keep the</span>
<a name="l00614"></a>00614   <span class="comment">// corresponding widths.</span>
<a name="l00615"></a>00615 
<a name="l00616"></a>00616   vcl_ptrdiff_t s1, s2, s3;
<a name="l00617"></a>00617   <span class="keywordtype">unsigned</span> n1, n2;
<a name="l00618"></a>00618   <span class="keywordflow">if</span> ( istep_ &lt; jstep_ )
<a name="l00619"></a>00619     <span class="keywordflow">if</span> ( jstep_ &lt; planestep_ )
<a name="l00620"></a>00620     {
<a name="l00621"></a>00621       s1 = istep_; s2 = jstep_; s3 = planestep_;
<a name="l00622"></a>00622       n1 = ni_;    n2 = nj_;  <span class="comment">//  n3 = nplanes_;</span>
<a name="l00623"></a>00623     }
<a name="l00624"></a>00624     <span class="keywordflow">else</span> <span class="comment">// planestep_ &lt; jstep_</span>
<a name="l00625"></a>00625       <span class="keywordflow">if</span> ( istep_ &lt; planestep_ )
<a name="l00626"></a>00626       {
<a name="l00627"></a>00627         s1 = istep_; s2 = planestep_; s3 = jstep_;
<a name="l00628"></a>00628         n1 = ni_;    n2 = nplanes_; <span class="comment">//  n3 = nj_;</span>
<a name="l00629"></a>00629       }
<a name="l00630"></a>00630       <span class="keywordflow">else</span> <span class="comment">// planestep_ &lt; istep_</span>
<a name="l00631"></a>00631       {
<a name="l00632"></a>00632         s1 = planestep_; s2 = istep_; s3 = jstep_;
<a name="l00633"></a>00633         n1 = nplanes_;   n2 = ni_;  <span class="comment">//  n3 = nj_;</span>
<a name="l00634"></a>00634       }
<a name="l00635"></a>00635   <span class="keywordflow">else</span> <span class="comment">// jstep &lt; istep_</span>
<a name="l00636"></a>00636     <span class="keywordflow">if</span> ( jstep_ &lt; planestep_ )
<a name="l00637"></a>00637       <span class="keywordflow">if</span> ( istep_ &lt; planestep_ )
<a name="l00638"></a>00638       {
<a name="l00639"></a>00639         s1 = jstep_; s2 = istep_; s3 = planestep_;
<a name="l00640"></a>00640         n1 = nj_;    n2 = ni_;  <span class="comment">//  n3 = nplanes_;</span>
<a name="l00641"></a>00641       }
<a name="l00642"></a>00642       <span class="keywordflow">else</span> <span class="comment">// planestep_ &lt; istep_</span>
<a name="l00643"></a>00643       {
<a name="l00644"></a>00644         s1 = jstep_; s2 = planestep_; s3 = istep_;
<a name="l00645"></a>00645         n1 = nj_;    n2 = nplanes_;  <span class="comment">// n3 = ni_;</span>
<a name="l00646"></a>00646       }
<a name="l00647"></a>00647     <span class="keywordflow">else</span> <span class="comment">// planestep_ &lt; jstep_</span>
<a name="l00648"></a>00648     {
<a name="l00649"></a>00649       s1 = planestep_; s2 = jstep_; s3 = istep_;
<a name="l00650"></a>00650       n1 = nplanes_;   n2 = nj_;  <span class="comment">//  n3 = ni_;</span>
<a name="l00651"></a>00651     }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <span class="keywordflow">return</span> s1 == 1 &amp;&amp;
<a name="l00654"></a>00654          s2 &gt; 0 &amp;&amp; unsigned(s2) == n1 &amp;&amp;
<a name="l00655"></a>00655          s3 &gt; 0 &amp;&amp; unsigned(s3) == n1*n2;
<a name="l00656"></a>00656 }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 <span class="comment">//=======================================================================</span>
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00661"></a><a class="code" href="classvil__image__view.html#a4de6c8960b8a10ef38849720043bd64a">00661</a> <span class="keywordtype">void</span> <a class="code" href="classvil__image__view.html#a9c01939f01ef50314620e26aaacb04d3" title="resize current planes to ni x nj.">vil_image_view&lt;T&gt;::set_size</a>(<span class="keywordtype">unsigned</span> n_i, <span class="keywordtype">unsigned</span> n_j, <span class="keywordtype">unsigned</span> n_planes)
<a name="l00662"></a>00662 {
<a name="l00663"></a>00663   <span class="keywordflow">if</span> (n_i==ni_ &amp;&amp; n_j==nj_ &amp;&amp; n_planes==nplanes_) <span class="keywordflow">return</span>;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665   release_memory();
<a name="l00666"></a>00666 
<a name="l00667"></a>00667   <a class="code" href="vil__pixel__format_8h.html#a6f749d91364b0bcb661189f4a154800d" title="Describes the type of the concrete data.">vil_pixel_format</a> fmt = <a class="code" href="vil__pixel__format_8h.html#a1584d4356219c867020df43a66aada05" title="The pixel format enumeration corresponding to the C++ type.">vil_pixel_format_of</a>(T());
<a name="l00668"></a>00668   ptr_ = <span class="keyword">new</span> <a class="code" href="classvil__memory__chunk.html" title="Ref. counted block of data on the heap.">vil_memory_chunk</a>(<span class="keyword">sizeof</span>(T)*n_planes*n_j*n_i,
<a name="l00669"></a>00669                               <a class="code" href="vil__pixel__format_8cxx.html#a0589722cd843f9c7790df385fbb29a13" title="Return the number of components in pixel format f.">vil_pixel_format_component_format</a>(fmt));
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   ni_ = n_i;
<a name="l00672"></a>00672   nj_ = n_j;
<a name="l00673"></a>00673   nplanes_ = n_planes;
<a name="l00674"></a>00674   <span class="comment">// When the image view was in interleaved mode before entering this function,</span>
<a name="l00675"></a>00675   <span class="comment">// check whether the new number of planes is the same as the istep_.</span>
<a name="l00676"></a>00676   <span class="comment">// If the two agree, remain in the interleaved mode, which is desired by the constructor.</span>
<a name="l00677"></a>00677   <span class="comment">// Otherwise, make istep_=1 and thus no longer interleaved.</span>
<a name="l00678"></a>00678   <span class="keywordflow">if</span> (istep_==0 || <span class="keywordtype">int</span>(istep_) != <span class="keywordtype">int</span>(n_planes)) istep_ = 1;
<a name="l00679"></a>00679   jstep_ = n_i*istep_;
<a name="l00680"></a>00680   planestep_ = istep_==1 ? n_i*n_j : 1;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682   top_left_ = <span class="keyword">reinterpret_cast&lt;</span>T*<span class="keyword">&gt;</span>(ptr_-&gt;data());
<a name="l00683"></a>00683   assert( (istep_==1 &amp;&amp; (<span class="keywordtype">int</span>)planestep_==<span class="keywordtype">int</span>(n_i*n_j)) || (planestep_==1 &amp;&amp; (<span class="keywordtype">int</span>)istep_==(<span class="keywordtype">int</span>)n_planes) );
<a name="l00684"></a>00684 }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 <span class="comment">//: Set this view to look at someone else&#39;s memory.</span>
<a name="l00688"></a>00688 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00689"></a><a class="code" href="classvil__image__view.html#a9ee5bf83390f0ef6f9c0bce93e5b466e">00689</a> <span class="keywordtype">void</span> <a class="code" href="classvil__image__view.html#a9ee5bf83390f0ef6f9c0bce93e5b466e" title="Set this view to look at someone else&#39;s memory data.">vil_image_view&lt;T&gt;::set_to_memory</a>(<span class="keyword">const</span> T* top_left,
<a name="l00690"></a>00690                                       <span class="keywordtype">unsigned</span> n_i, <span class="keywordtype">unsigned</span> n_j, <span class="keywordtype">unsigned</span> n_planes,
<a name="l00691"></a>00691                                       vcl_ptrdiff_t i_step, vcl_ptrdiff_t j_step, vcl_ptrdiff_t plane_step)
<a name="l00692"></a>00692 {
<a name="l00693"></a>00693   release_memory();
<a name="l00694"></a>00694   top_left_ = <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(top_left);  <span class="comment">// Remove const, as view may end up manipulating data</span>
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   ni_ = n_i;
<a name="l00697"></a>00697   nj_ = n_j;
<a name="l00698"></a>00698   nplanes_ = n_planes;
<a name="l00699"></a>00699   istep_ = i_step;
<a name="l00700"></a>00700   jstep_ = j_step;
<a name="l00701"></a>00701   planestep_ = plane_step;
<a name="l00702"></a>00702 }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="comment">//=======================================================================</span>
<a name="l00706"></a>00706 <span class="comment">//: Fill view with given value</span>
<a name="l00707"></a>00707 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00708"></a><a class="code" href="classvil__image__view.html#a6fd591632020e490abb5e4493a52dbba">00708</a> <span class="keywordtype">void</span> <a class="code" href="classvil__image__view.html#a6fd591632020e490abb5e4493a52dbba" title="Fill view with given value.">vil_image_view&lt;T&gt;::fill</a>(T value)
<a name="l00709"></a>00709 {
<a name="l00710"></a>00710   T* plane = top_left_;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712   <span class="keywordflow">if</span> (is_contiguous())
<a name="l00713"></a>00713   {
<a name="l00714"></a>00714     vcl_fill(begin(), end(), value);
<a name="l00715"></a>00715     <span class="keywordflow">return</span>;
<a name="l00716"></a>00716   }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   <span class="keywordflow">if</span> (istep_==1)
<a name="l00719"></a>00719   {
<a name="l00720"></a>00720     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0;p&lt;nplanes_;++p,plane += planestep_)
<a name="l00721"></a>00721     {
<a name="l00722"></a>00722       T* row = plane;
<a name="l00723"></a>00723       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;j&lt;nj_;++j,row += jstep_)
<a name="l00724"></a>00724       {
<a name="l00725"></a>00725         <span class="keywordtype">int</span> i = ni_;
<a name="l00726"></a>00726         <span class="keywordflow">while</span> (i!=0) { row[--i]=value; }
<a name="l00727"></a>00727       }
<a name="l00728"></a>00728     }
<a name="l00729"></a>00729     <span class="keywordflow">return</span>;
<a name="l00730"></a>00730   }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732   <span class="keywordflow">if</span> (jstep_==1)
<a name="l00733"></a>00733   {
<a name="l00734"></a>00734     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0;p&lt;nplanes_;++p,plane += planestep_)
<a name="l00735"></a>00735     {
<a name="l00736"></a>00736       T* col = plane;
<a name="l00737"></a>00737       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;ni_;++i,col += istep_)
<a name="l00738"></a>00738       {
<a name="l00739"></a>00739         <span class="keywordtype">int</span> j = nj_;
<a name="l00740"></a>00740         <span class="keywordflow">while</span> (j!=0) { col[--j]=value; }
<a name="l00741"></a>00741       }
<a name="l00742"></a>00742     }
<a name="l00743"></a>00743     <span class="keywordflow">return</span>;
<a name="l00744"></a>00744   }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0;p&lt;nplanes_;++p,plane += planestep_)
<a name="l00747"></a>00747   {
<a name="l00748"></a>00748     T* row = plane;
<a name="l00749"></a>00749     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;j&lt;nj_;++j,row += jstep_)
<a name="l00750"></a>00750     {
<a name="l00751"></a>00751       T* p = row;
<a name="l00752"></a>00752       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;ni_;++i,p+=istep_) *p = value;
<a name="l00753"></a>00753     }
<a name="l00754"></a>00754   }
<a name="l00755"></a>00755 }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 <span class="comment">//=======================================================================</span>
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00760"></a><a class="code" href="classvil__image__view.html#a43348044da424294a8753acf3fc1fb3c">00760</a> <span class="keywordtype">bool</span> <a class="code" href="classvil__image__view.html#a43348044da424294a8753acf3fc1fb3c" title="True if this is (or is derived from) class s.">vil_image_view&lt;T&gt;::is_class</a>(vcl_string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span>
<a name="l00761"></a>00761 <span class="keyword"></span>{
<a name="l00762"></a>00762   <span class="keywordflow">return</span> s==<a class="code" href="classvil__image__view.html#af32acac32731dd980315e7ea60489b25" title="Return class name.">vil_image_view&lt;T&gt;::is_a</a>() || <a class="code" href="classvil__image__view__base.html#aa84ca2e485febc431d2b80e072da9056" title="True if this is (or is derived from) class s.">vil_image_view_base::is_class</a>(s);
<a name="l00763"></a>00763 }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 <span class="comment">//=======================================================================</span>
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00768"></a><a class="code" href="classvil__image__view.html#a4fbbc0548234684bbbf9bebf5d2e5ec1">00768</a> <span class="keywordtype">void</span> <a class="code" href="classvil__image__view.html#a4fbbc0548234684bbbf9bebf5d2e5ec1" title="Print a 1-line summary of contents.">vil_image_view&lt;T&gt;::print</a>(vcl_ostream&amp; os)<span class="keyword"> const</span>
<a name="l00769"></a>00769 <span class="keyword"></span>{
<a name="l00770"></a>00770   os&lt;&lt;nplanes_&lt;&lt;<span class="stringliteral">&quot; planes, each &quot;</span>&lt;&lt;ni_&lt;&lt;<span class="stringliteral">&quot; x &quot;</span>&lt;&lt;nj_;
<a name="l00771"></a>00771 }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 <span class="comment">//=======================================================================</span>
<a name="l00774"></a>00774 <span class="comment">//: True if they share same view of same image data.</span>
<a name="l00775"></a>00775 <span class="comment">//  This does not do a deep equality on image data. If the images point</span>
<a name="l00776"></a>00776 <span class="comment">//  to different image data objects that contain identical images, then</span>
<a name="l00777"></a>00777 <span class="comment">//  the result will still be false.</span>
<a name="l00778"></a>00778 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00779"></a><a class="code" href="classvil__image__view.html#af35784a26c807ed83d3fbcdf66ca7880">00779</a> <span class="keywordtype">bool</span> <a class="code" href="classvil__image__view.html#af35784a26c807ed83d3fbcdf66ca7880" title="True if they share same view of same image data.">vil_image_view&lt;T&gt;::operator==</a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a> &amp;rhs)<span class="keyword"> const</span>
<a name="l00780"></a>00780 <span class="keyword"></span>{
<a name="l00781"></a>00781   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>() != pixel_format()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00782"></a>00782 
<a name="l00783"></a>00783   <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp; other = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp;<span class="keyword">&gt;</span>(rhs);
<a name="l00784"></a>00784 
<a name="l00785"></a>00785   <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   <span class="keywordflow">if</span> (!(<span class="keywordtype">bool</span>) *<span class="keyword">this</span> &amp;&amp; !(bool)other) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00788"></a>00788   <span class="keywordflow">return</span> ptr_  == other.<a class="code" href="classvil__image__view.html#a11af5651bc8159fce8fb1d342a08dc38" title="Reference to actual image data.">ptr_</a> &amp;&amp;
<a name="l00789"></a>00789     top_left_  == other.top_left_ &amp;&amp;
<a name="l00790"></a>00790     nplanes_   == other.nplanes_ &amp;&amp;
<a name="l00791"></a>00791     ni_        == other.ni_ &amp;&amp;
<a name="l00792"></a>00792     nj_        == other.nj_ &amp;&amp;
<a name="l00793"></a>00793     (nplanes_ &lt;= 1 || planestep_ == other.planestep_) &amp;&amp;
<a name="l00794"></a>00794     istep_     == other.istep_ &amp;&amp;
<a name="l00795"></a>00795     jstep_     == other.jstep_;
<a name="l00796"></a>00796 }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="comment">//=======================================================================</span>
<a name="l00799"></a>00799 <span class="comment">//: Provides an ordering.</span>
<a name="l00800"></a>00800 <span class="comment">//  Useful for ordered containers.</span>
<a name="l00801"></a>00801 <span class="comment">//  There is no guaranteed meaning to the less than operator, except that</span>
<a name="l00802"></a>00802 <span class="comment">//  (a&lt;b &amp;&amp; b&lt;a)  is false and  !(a&lt;b) &amp;&amp; !(b&lt;a)  is equivalent to  a==b</span>
<a name="l00803"></a>00803 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00804"></a><a class="code" href="classvil__image__view.html#a2a64214d9130a7baf2b10603182343b2">00804</a> <span class="keywordtype">bool</span> <a class="code" href="classvil__image__view.html#a2a64214d9130a7baf2b10603182343b2" title="Provides an ordering.">vil_image_view&lt;T&gt;::operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a>&amp; rhs)<span class="keyword"> const</span>
<a name="l00805"></a>00805 <span class="keyword"></span>{
<a name="l00806"></a>00806   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>() != pixel_format()) <span class="keywordflow">return</span> pixel_format() &lt; rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>();
<a name="l00807"></a>00807 
<a name="l00808"></a>00808   <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp; other = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp;<span class="keyword">&gt;</span>(rhs);
<a name="l00809"></a>00809   <span class="keywordflow">if</span> (ptr_ != other.<a class="code" href="classvil__image__view.html#a11af5651bc8159fce8fb1d342a08dc38" title="Reference to actual image data.">ptr_</a>) <span class="keywordflow">return</span> ptr_&lt;other.<a class="code" href="classvil__image__view.html#a11af5651bc8159fce8fb1d342a08dc38" title="Reference to actual image data.">ptr_</a>;
<a name="l00810"></a>00810   <span class="keywordflow">if</span> (!(<span class="keywordtype">bool</span>) *<span class="keyword">this</span> &amp;&amp; !(bool)other) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00811"></a>00811   <span class="keywordflow">if</span> (nplanes_ != other.nplanes_) <span class="keywordflow">return</span> nplanes_ &lt; other.nplanes_;
<a name="l00812"></a>00812   <span class="keywordflow">if</span> (ni_ != other.ni_) <span class="keywordflow">return</span> ni_ &lt; other.ni_;
<a name="l00813"></a>00813   <span class="keywordflow">if</span> (nj_ != other.nj_) <span class="keywordflow">return</span> nj_ &lt; other.nj_;
<a name="l00814"></a>00814   <span class="keywordflow">if</span> (planestep_ != other.planestep_) <span class="keywordflow">return</span> planestep_ &lt; other.planestep_;
<a name="l00815"></a>00815   <span class="keywordflow">if</span> (istep_ != other.istep_) <span class="keywordflow">return</span> istep_ &lt; other.istep_;
<a name="l00816"></a>00816   <span class="keywordflow">return</span> jstep_ &lt; other.jstep_;
<a name="l00817"></a>00817 }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="comment">//=======================================================================</span>
<a name="l00821"></a>00821 <span class="comment">//: Provides an ordering.</span>
<a name="l00822"></a>00822 <span class="comment">//  Useful for ordered containers.</span>
<a name="l00823"></a>00823 <span class="comment">//  There is no guaranteed meaning to the less than operator, except that</span>
<a name="l00824"></a>00824 <span class="comment">//  (a&gt;b) is equivalent to (b&lt;a)</span>
<a name="l00825"></a>00825 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00826"></a><a class="code" href="classvil__image__view.html#a6514f1e450f6f83a54b0cd604a406ead">00826</a> <span class="keywordtype">bool</span> <a class="code" href="classvil__image__view.html#a6514f1e450f6f83a54b0cd604a406ead" title="Provides an ordering.">vil_image_view&lt;T&gt;::operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view__base.html" title="An abstract base class of smart pointers to actual image data in memory.">vil_image_view_base</a>&amp; rhs)<span class="keyword"> const</span>
<a name="l00827"></a>00827 <span class="keyword"></span>{
<a name="l00828"></a>00828   <span class="keywordflow">if</span> (rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>() != pixel_format()) <span class="keywordflow">return</span> pixel_format() &gt; rhs.<a class="code" href="classvil__image__view__base.html#af6ea1a289fe4e897d4c3a7ed8d2caaf0" title="Return a description of the concrete data pixel type.">pixel_format</a>();
<a name="l00829"></a>00829 
<a name="l00830"></a>00830   <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp; other = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp;<span class="keyword">&gt;</span>(rhs);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832   <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   <span class="keywordflow">if</span> (ptr_ != other.<a class="code" href="classvil__image__view.html#a11af5651bc8159fce8fb1d342a08dc38" title="Reference to actual image data.">ptr_</a>) <span class="keywordflow">return</span> ptr_&gt;other.<a class="code" href="classvil__image__view.html#a11af5651bc8159fce8fb1d342a08dc38" title="Reference to actual image data.">ptr_</a>;
<a name="l00835"></a>00835   <span class="keywordflow">if</span> (!(<span class="keywordtype">bool</span>) *<span class="keyword">this</span> &amp;&amp; !(bool)other) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00836"></a>00836   <span class="keywordflow">if</span> (nplanes_ != other.nplanes_) <span class="keywordflow">return</span> nplanes_ &gt; other.nplanes_;
<a name="l00837"></a>00837   <span class="keywordflow">if</span> (ni_ != other.ni_) <span class="keywordflow">return</span> ni_ &gt; other.ni_;
<a name="l00838"></a>00838   <span class="keywordflow">if</span> (nj_ != other.nj_) <span class="keywordflow">return</span> nj_ &gt; other.nj_;
<a name="l00839"></a>00839   <span class="keywordflow">if</span> (planestep_ != other.planestep_) <span class="keywordflow">return</span> planestep_ &gt; other.planestep_;
<a name="l00840"></a>00840   <span class="keywordflow">if</span> (istep_ != other.istep_) <span class="keywordflow">return</span> istep_ &gt; other.istep_;
<a name="l00841"></a>00841   <span class="keywordflow">return</span> jstep_ &gt; other.jstep_;
<a name="l00842"></a>00842 }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 
<a name="l00845"></a>00845 <span class="comment">//=======================================================================</span>
<a name="l00846"></a>00846 <span class="comment">//: True if the actual images are identical.</span>
<a name="l00847"></a>00847 <span class="comment">// $\bigwedge_{i,j,p} {\textstyle src}(i,j,p) == {\textstyle dest}(i,j,p)$</span>
<a name="l00848"></a>00848 <span class="comment">// The data may be formatted differently in each memory chunk.</span>
<a name="l00849"></a>00849 <span class="comment">//  O(size).</span>
<a name="l00850"></a>00850 <span class="comment">// \relatesalso vil_image_view</span>
<a name="l00851"></a>00851 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00852"></a><a class="code" href="vil__image__view_8txx.html#ae6285651019d9b0932905feb98618733">00852</a> <span class="keywordtype">bool</span> <a class="code" href="classvil__image__view.html#ae6285651019d9b0932905feb98618733" title="True if the actual images are identical.">vil_image_view_deep_equality</a>(<span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp;lhs,
<a name="l00853"></a>00853                                   <span class="keyword">const</span> <a class="code" href="classvil__image__view.html" title="Concrete view of image data of type T held in memory.">vil_image_view&lt;T&gt;</a> &amp;rhs)
<a name="l00854"></a>00854 {
<a name="l00855"></a>00855   <span class="keywordflow">if</span> (lhs.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() != rhs.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>() ||
<a name="l00856"></a>00856       lhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>() != rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>() ||
<a name="l00857"></a>00857       lhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>() != rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>())
<a name="l00858"></a>00858     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt; rhs.<a class="code" href="classvil__image__view__base.html#adb221bda92a1c0f7f4842af116428b11" title="Number of planes.">nplanes</a>(); ++p)
<a name="l00861"></a>00861     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; rhs.<a class="code" href="classvil__image__view__base.html#a44859c72206da7d18728cb2bbf8ae829" title="Height.">nj</a>(); ++j)
<a name="l00862"></a>00862       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; rhs.<a class="code" href="classvil__image__view__base.html#a9ea9ad565387a61dccf38fc80a266c2a" title="Width.">ni</a>(); ++i)
<a name="l00863"></a>00863         <span class="keywordflow">if</span> (!(rhs(i,j,p) == lhs(i,j,p)))
<a name="l00864"></a>00864           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00865"></a>00865   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00866"></a>00866 }
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 <span class="comment">//=======================================================================</span>
<a name="l00869"></a>00869 
<a name="l00870"></a>00870 <span class="comment">// Specializations must be declared in all translation units where</span>
<a name="l00871"></a>00871 <span class="comment">// they are used.  Since we do not know what instantiations will be</span>
<a name="l00872"></a>00872 <span class="comment">// defined, and each requires a specialization, we define the primary</span>
<a name="l00873"></a>00873 <span class="comment">// template of is_a to call a function that will be declared and</span>
<a name="l00874"></a>00874 <span class="comment">// specialized only in the instantiation translation units.</span>
<a name="l00875"></a>00875 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; vcl_string <a class="code" href="vil__image__view_8txx.html#ad013d07b531c1972e5e9e2984bfc8283">vil_image_view_type_name</a>(T*);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00878"></a><a class="code" href="classvil__image__view.html#af32acac32731dd980315e7ea60489b25">00878</a> vcl_string <a class="code" href="classvil__image__view.html#af32acac32731dd980315e7ea60489b25" title="Return class name.">vil_image_view&lt;T&gt;::is_a</a>()<span class="keyword"> const</span>
<a name="l00879"></a>00879 <span class="keyword"></span>{
<a name="l00880"></a>00880   <span class="keywordflow">return</span> <a class="code" href="vil__image__view_8txx.html#ad013d07b531c1972e5e9e2984bfc8283">vil_image_view_type_name</a>(static_cast&lt;T*&gt;(0));
<a name="l00881"></a>00881 }
<a name="l00882"></a>00882 
<a name="l00883"></a><a class="code" href="vil__image__view_8txx.html#aa441392537bf9de9505971b20dd9582e">00883</a> <span class="preprocessor">#define VIL_IMAGE_VIEW_INSTANTIATE(T) \</span>
<a name="l00884"></a>00884 <span class="preprocessor">VCL_DEFINE_SPECIALIZATION vcl_string vil_image_view_type_name(T*) \</span>
<a name="l00885"></a>00885 <span class="preprocessor">{ return vcl_string(&quot;vil_image_view&lt;&quot; #T &quot;&gt;&quot;); } \</span>
<a name="l00886"></a>00886 <span class="preprocessor">template class vil_image_view&lt;T &gt;; \</span>
<a name="l00887"></a>00887 <span class="preprocessor">template bool vil_image_view_deep_equality(const vil_image_view&lt;T &gt;&amp;, \</span>
<a name="l00888"></a>00888 <span class="preprocessor">                                           const vil_image_view&lt;T &gt;&amp;)</span>
<a name="l00889"></a>00889 <span class="preprocessor"></span>
<a name="l00890"></a>00890 <span class="preprocessor">#endif // vil_image_view_txx_</span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 1 2013 17:31:48 for core/vil by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
